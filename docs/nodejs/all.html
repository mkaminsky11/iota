<h2>global</h2>
<ul>
<li>{Object} The global namespace object.</li>
</ul>
<p>In browsers, the top-level scope is the global scope. That means that in
browsers if you&#39;re in the global scope <code class="language-javascript">var something</code> will define a global
variable. In Node this is different. The top-level scope is not the global
scope; <code class="language-javascript">var something</code> inside a Node module will be local to that module.

</p>
<!--next-->
<h2>process</h2>
<ul>
<li>{Object}</li>
</ul>
<p>The process object. See the <a>process object</a> section.

</p>
<!--next-->
<h2>console</h2>

<ul>
<li>{Object}</li>
</ul>
<p>Used to print to stdout and stderr. See the <a>console</a> section.

</p>
<!--next-->
<h2>Class: Buffer</h2>

<ul>
<li>{Function}</li>
</ul>
<p>Used to handle binary data. See the <a>buffer section</a>

</p>
<!--next-->
<h2>require()</h2>

<ul>
<li>{Function}</li>
</ul>
<p>To require modules. See the <a>Modules</a> section.  <code class="language-javascript">require</code> isn&#39;t actually a
global but rather local to each module.

</p>
<!--next-->
<h2>require.resolve()</h2>
<p>Use the internal <code class="language-javascript">require()</code> machinery to look up the location of a module,
but rather than loading the module, just return the resolved filename.

</p>
<!--next-->
<h2>require.cache</h2>
<div class="signature"><ul>
<li><span class="type">Object</span></li>
</div></ul>
<p>Modules are cached in this object when they are required. By deleting a key
value from this object, the next <code class="language-javascript">require</code> will reload the module.

</p>
<!--next-->
<h2>require.extensions</h2>
<pre class="stability">Stability: 0 - Deprecated</pre><div class="signature"><ul>
<li><span class="type">Object</span></li>
</div></ul>
<p>Instruct <code class="language-javascript">require</code> on how to handle certain file extensions.

</p>
<p>Process files with the extension <code class="language-javascript">.sjs</code> as <code class="language-javascript">.js</code>:

</p>
<pre><code class="language-javascript">require.extensions[&#39;.sjs&#39;] = require.extensions[&#39;.js&#39;];</code></pre>
<p><strong>Deprecated</strong>  In the past, this list has been used to load
non-JavaScript modules into Node by compiling them on-demand.
However, in practice, there are much better ways to do this, such as
loading modules via some other Node program, or compiling them to
JavaScript ahead of time.

</p>
<p>Since the Module system is locked, this feature will probably never go
away.  However, it may have subtle bugs and complexities that are best
left untouched.

</p>
<!--next-->
<h2>__filename</h2>

<ul>
<li>{String}</li>
</ul>
<p>The filename of the code being executed.  This is the resolved absolute path
of this code file.  For a main program this is not necessarily the same
filename used in the command line.  The value inside a module is the path
to that module file.

</p>
<p>Example: running <code class="language-javascript">node example.js</code> from <code class="language-javascript">/Users/mjr</code>

</p>
<pre><code class="language-javascript">console.log(__filename);
// /Users/mjr/example.js</code></pre>
<p><code class="language-javascript">__filename</code> isn&#39;t actually a global but rather local to each module.

</p>
<!--next-->
<h2>__dirname</h2>

<ul>
<li>{String}</li>
</ul>
<p>The name of the directory that the currently executing script resides in.

</p>
<p>Example: running <code class="language-javascript">node example.js</code> from <code class="language-javascript">/Users/mjr</code>

</p>
<pre><code class="language-javascript">console.log(__dirname);
// /Users/mjr</code></pre>
<p><code class="language-javascript">__dirname</code> isn&#39;t actually a global but rather local to each module.


</p>
<!--next-->
<h2>module</h2>

<ul>
<li>{Object}</li>
</ul>
<p>A reference to the current module. In particular
<code class="language-javascript">module.exports</code> is used for defining what a module exports and makes
available through <code class="language-javascript">require()</code>.

</p>
<p><code class="language-javascript">module</code> isn&#39;t actually a global but rather local to each module.

</p>
<p>See the <a>module system documentation</a> for more information.

</p>
<!--next-->
<h2>exports</h2>

<p>A reference to the <code class="language-javascript">module.exports</code> that is shorter to type.
See <a>module system documentation</a> for details on when to use <code class="language-javascript">exports</code> and
when to use <code class="language-javascript">module.exports</code>.

</p>
<p><code class="language-javascript">exports</code> isn&#39;t actually a global but rather local to each module.

</p>
<p>See the <a>module system documentation</a> for more information.

</p>
<p>See the <a>module section</a> for more information.

</p>
<!--next-->
<h2>setTimeout(cb, ms)</h2>
<p>Run callback <code class="language-javascript">cb</code> after <em>at least</em> <code class="language-javascript">ms</code> milliseconds. The actual delay depends
on external factors like OS timer granularity and system load.

</p>
<p>The timeout must be in the range of 1-2,147,483,647 inclusive. If the value is
outside that range, it&#39;s changed to 1 millisecond. Broadly speaking, a timer
cannot span more than 24.8 days.

</p>
<p>Returns an opaque value that represents the timer.

</p>
<!--next-->
<h2>clearTimeout(t)</h2>
<p>Stop a timer that was previously created with <code class="language-javascript">setTimeout()</code>. The callback will
not execute.

</p>
<!--next-->
<h2>setInterval(cb, ms)</h2>
<p>Run callback <code class="language-javascript">cb</code> repeatedly every <code class="language-javascript">ms</code> milliseconds. Note that the actual
interval may vary, depending on external factors like OS timer granularity and
system load. It&#39;s never less than <code class="language-javascript">ms</code> but it may be longer.

</p>
<p>The interval must be in the range of 1-2,147,483,647 inclusive. If the value is
outside that range, it&#39;s changed to 1 millisecond. Broadly speaking, a timer
cannot span more than 24.8 days.

</p>
<p>Returns an opaque value that represents the timer.

</p>
<!--next-->
<h2>clearInterval(t)</h2>
<p>Stop a timer that was previously created with <code class="language-javascript">setInterval()</code>. The callback
will not execute.

</p>

<p>The timer functions are global variables. See the <a>timers</a> section.

</p>

<!--next-->
<h2>console.log([data][, ...])</h2>
<p>Prints to stdout with newline. This function can take multiple arguments in a
<code class="language-javascript">printf()</code>-like way. Example:

</p>
<pre><code class="language-javascript">var count = 5;
console.log(&#39;count: %d&#39;, count);
// prints &#39;count: 5&#39;</code></pre>
<p>If formatting elements are not found in the first string then <code class="language-javascript">util.inspect</code>
is used on each argument.  See <a>util.format()</a> for more information.

</p>
<!--next-->
<h2>console.info([data][, ...])</h2>
<p>Same as <code class="language-javascript">console.log</code>.

</p>
<!--next-->
<h2>console.error([data][, ...])</h2>
<p>Same as <code class="language-javascript">console.log</code> but prints to stderr.

</p>
<!--next-->
<h2>console.warn([data][, ...])</h2>
<p>Same as <code class="language-javascript">console.error</code>.

</p>
<!--next-->
<h2>console.dir(obj[, options])</h2>
<p>Uses <code class="language-javascript">util.inspect</code> on <code class="language-javascript">obj</code> and prints resulting string to stdout. This function
bypasses any custom <code class="language-javascript">inspect()</code> function on <code class="language-javascript">obj</code>. An optional <em>options</em> object
may be passed that alters certain aspects of the formatted string:

</p>
<ul>
<li><p><code class="language-javascript">showHidden</code> - if <code class="language-javascript">true</code> then the object&#39;s non-enumerable properties will be
shown too. Defaults to <code class="language-javascript">false</code>.</p>
</li>
<li><p><code class="language-javascript">depth</code> - tells <code class="language-javascript">inspect</code> how many times to recurse while formatting the
object. This is useful for inspecting large complicated objects. Defaults to
<code class="language-javascript">2</code>. To make it recurse indefinitely pass <code class="language-javascript">null</code>.</p>
</li>
<li><p><code class="language-javascript">colors</code> - if <code class="language-javascript">true</code>, then the output will be styled with ANSI color codes.
Defaults to <code class="language-javascript">false</code>. Colors are customizable, see below.</p>
</li>
</ul>
<!--next-->
<h2>console.time(label)</h2>
<p>Mark a time.

</p>
<!--next-->
<h2>console.timeEnd(label)</h2>
<p>Finish timer, record output. Example:

</p>
<pre><code class="language-javascript">console.time(&#39;100-elements&#39;);
for (var i = 0; i &lt; 100; i++) {
  ;
}
console.timeEnd(&#39;100-elements&#39;);
// prints 100-elements: 262ms</code></pre>
<!--next-->
<h2>console.trace(message[, ...])</h2>
<p>Print to stderr <code class="language-javascript">&#39;Trace :&#39;</code>, followed by the formatted message and stack trace
to the current position.

</p>
<!--next-->
<h2>console.assert(value[, message][, ...])</h2>
<p>Similar to <a>assert.ok()</a>, but the error message is formatted as
<code class="language-javascript">util.format(message...)</code>.

</p>

<!--next-->
<h2>setTimeout(callback, delay[, arg][, ...])</h2>
<p>To schedule execution of a one-time <code class="language-javascript">callback</code> after <code class="language-javascript">delay</code> milliseconds. Returns a
<code class="language-javascript">timeoutObject</code> for possible use with <code class="language-javascript">clearTimeout()</code>. Optionally you can
also pass arguments to the callback.

</p>
<p>It is important to note that your callback will probably not be called in exactly
<code class="language-javascript">delay</code> milliseconds - Node.js makes no guarantees about the exact timing of when
the callback will fire, nor of the ordering things will fire in. The callback will
be called as close as possible to the time specified.

</p>
<!--next-->
<h2>clearTimeout(timeoutObject)</h2>
<p>Prevents a timeout from triggering.

</p>
<!--next-->
<h2>setInterval(callback, delay[, arg][, ...])</h2>
<p>To schedule the repeated execution of <code class="language-javascript">callback</code> every <code class="language-javascript">delay</code> milliseconds.
Returns a <code class="language-javascript">intervalObject</code> for possible use with <code class="language-javascript">clearInterval()</code>. Optionally
you can also pass arguments to the callback.

</p>
<!--next-->
<h2>clearInterval(intervalObject)</h2>
<p>Stops an interval from triggering.

</p>
<!--next-->
<h2>unref()</h2>
<p>The opaque value returned by <code class="language-javascript">setTimeout</code> and <code class="language-javascript">setInterval</code> also has the method
<code class="language-javascript">timer.unref()</code> which will allow you to create a timer that is active but if
it is the only item left in the event loop won&#39;t keep the program running.
If the timer is already <code class="language-javascript">unref</code>d calling <code class="language-javascript">unref</code> again will have no effect.

</p>
<p>In the case of <code class="language-javascript">setTimeout</code> when you <code class="language-javascript">unref</code> you create a separate timer that
will wakeup the event loop, creating too many of these may adversely effect
event loop performance -- use wisely.

</p>
<!--next-->
<h2>ref()</h2>
<p>If you had previously <code class="language-javascript">unref()</code>d a timer you can call <code class="language-javascript">ref()</code> to explicitly
request the timer hold the program open. If the timer is already <code class="language-javascript">ref</code>d calling
<code class="language-javascript">ref</code> again will have no effect.

</p>
<!--next-->
<h2>setImmediate(callback[, arg][, ...])</h2>
<p>To schedule the &quot;immediate&quot; execution of <code class="language-javascript">callback</code> after I/O events
callbacks and before <code class="language-javascript">setTimeout</code> and <code class="language-javascript">setInterval</code> . Returns an
<code class="language-javascript">immediateObject</code> for possible use with <code class="language-javascript">clearImmediate()</code>. Optionally you
can also pass arguments to the callback.

</p>
<p>Callbacks for immediates are queued in the order in which they were created.
The entire callback queue is processed every event loop iteration. If you queue
an immediate from inside an executing callback, that immediate won&#39;t fire
until the next event loop iteration.

</p>
<!--next-->
<h2>clearImmediate(immediateObject)</h2>
<p>Stops an immediate from triggering.

</p>
<!--next-->
<h2>Modules</h2>
<pre class="stability">Stability: 5 - Locked</pre>

<p>Node has a simple module loading system.  In Node, files and modules are in
one-to-one correspondence.  As an example, <code class="language-javascript">foo.js</code> loads the module
<code class="language-javascript">circle.js</code> in the same directory.

</p>
<p>The contents of <code class="language-javascript">foo.js</code>:

</p>
<pre><code class="language-javascript">var circle = require(&#39;./circle.js&#39;);
console.log( &#39;The area of a circle of radius 4 is &#39;
           + circle.area(4));</code></pre>
<p>The contents of <code class="language-javascript">circle.js</code>:

</p>
<pre><code class="language-javascript">var PI = Math.PI;

exports.area = function (r) {
  return PI * r * r;
};

exports.circumference = function (r) {
  return 2 * PI * r;
};</code></pre>
<p>The module <code class="language-javascript">circle.js</code> has exported the functions <code class="language-javascript">area()</code> and
<code class="language-javascript">circumference()</code>.  To add functions and objects to the root of your module,
you can add them to the special <code class="language-javascript">exports</code> object.

</p>
<p>Variables local to the module will be private, as though the module was wrapped
in a function. In this example the variable <code class="language-javascript">PI</code> is private to <code class="language-javascript">circle.js</code>.

</p>
<p>If you want the root of your module&#39;s export to be a function (such as a
constructor) or if you want to export a complete object in one assignment
instead of building it one property at a time, assign it to <code class="language-javascript">module.exports</code>
instead of <code class="language-javascript">exports</code>.

</p>
<p>Below, <code class="language-javascript">bar.js</code> makes use of the <code class="language-javascript">square</code> module, which exports a constructor:

</p>
<pre><code class="language-javascript">var square = require(&#39;./square.js&#39;);
var mySquare = square(2);
console.log(&#39;The area of my square is &#39; + mySquare.area());</code></pre>
<p>The <code class="language-javascript">square</code> module is defined in <code class="language-javascript">square.js</code>:

</p>
<pre><code class="language-javascript">// assigning to exports will not modify module, must use module.exports
module.exports = function(width) {
  return {
    area: function() {
      return width * width;
    }
  };
}</code></pre>
<p>The module system is implemented in the <code class="language-javascript">require(&quot;module&quot;)</code> module.

</p>
<!--next-->
<h2>Cycles</h2>
<p>When there are circular <code class="language-javascript">require()</code> calls, a module might not have finished
executing when it is returned.

</p>
<p>Consider this situation:

</p>
<p><code class="language-javascript">a.js</code>:

</p>
<pre><code class="language-javascript">console.log(&#39;a starting&#39;);
exports.done = false;
var b = require(&#39;./b.js&#39;);
console.log(&#39;in a, b.done = %j&#39;, b.done);
exports.done = true;
console.log(&#39;a done&#39;);</code></pre>
<p><code class="language-javascript">b.js</code>:

</p>
<pre><code class="language-javascript">console.log(&#39;b starting&#39;);
exports.done = false;
var a = require(&#39;./a.js&#39;);
console.log(&#39;in b, a.done = %j&#39;, a.done);
exports.done = true;
console.log(&#39;b done&#39;);</code></pre>
<p><code class="language-javascript">main.js</code>:

</p>
<pre><code class="language-javascript">console.log(&#39;main starting&#39;);
var a = require(&#39;./a.js&#39;);
var b = require(&#39;./b.js&#39;);
console.log(&#39;in main, a.done=%j, b.done=%j&#39;, a.done, b.done);</code></pre>
<p>When <code class="language-javascript">main.js</code> loads <code class="language-javascript">a.js</code>, then <code class="language-javascript">a.js</code> in turn loads <code class="language-javascript">b.js</code>.  At that
point, <code class="language-javascript">b.js</code> tries to load <code class="language-javascript">a.js</code>.  In order to prevent an infinite
loop, an <strong>unfinished copy</strong> of the <code class="language-javascript">a.js</code> exports object is returned to the
<code class="language-javascript">b.js</code> module.  <code class="language-javascript">b.js</code> then finishes loading, and its <code class="language-javascript">exports</code> object is
provided to the <code class="language-javascript">a.js</code> module.

</p>
<p>By the time <code class="language-javascript">main.js</code> has loaded both modules, they&#39;re both finished.
The output of this program would thus be:

</p>
<pre><code class="language-javascript">$ node main.js
main starting
a starting
b starting
in b, a.done = false
b done
in a, b.done = true
a done
in main, a.done=true, b.done=true</code></pre>
<p>If you have cyclic module dependencies in your program, make sure to
plan accordingly.

</p>
<!--next-->
<h2>Core Modules</h2>
<p>Node has several modules compiled into the binary.  These modules are
described in greater detail elsewhere in this documentation.

</p>
<p>The core modules are defined in node&#39;s source in the <code class="language-javascript">lib/</code> folder.

</p>
<p>Core modules are always preferentially loaded if their identifier is
passed to <code class="language-javascript">require()</code>.  For instance, <code class="language-javascript">require(&#39;http&#39;)</code> will always
return the built in HTTP module, even if there is a file by that name.

</p>
<!--next-->
<h2>File Modules</h2>
<p>If the exact filename is not found, then node will attempt to load the
required filename with the added extension of <code class="language-javascript">.js</code>, <code class="language-javascript">.json</code>, and then <code class="language-javascript">.node</code>.

</p>
<p><code class="language-javascript">.js</code> files are interpreted as JavaScript text files, and <code class="language-javascript">.json</code> files are
parsed as JSON text files. <code class="language-javascript">.node</code> files are interpreted as compiled addon
modules loaded with <code class="language-javascript">dlopen</code>.

</p>
<p>A module prefixed with <code class="language-javascript">&#39;/&#39;</code> is an absolute path to the file.  For
example, <code class="language-javascript">require(&#39;/home/marco/foo.js&#39;)</code> will load the file at
<code class="language-javascript">/home/marco/foo.js</code>.

</p>
<p>A module prefixed with <code class="language-javascript">&#39;./&#39;</code> is relative to the file calling <code class="language-javascript">require()</code>.
That is, <code class="language-javascript">circle.js</code> must be in the same directory as <code class="language-javascript">foo.js</code> for
<code class="language-javascript">require(&#39;./circle&#39;)</code> to find it.

</p>
<p>Without a leading &#39;/&#39; or &#39;./&#39; to indicate a file, the module is either a
&quot;core module&quot; or is loaded from a <code class="language-javascript">node_modules</code> folder.

</p>
<p>If the given path does not exist, <code class="language-javascript">require()</code> will throw an Error with its
<code class="language-javascript">code</code> property set to <code class="language-javascript">&#39;MODULE_NOT_FOUND&#39;</code>.

</p>
<!--next-->
<h2>Loading from <code class="language-javascript">node_modules</code> Folders</h2>
<p>If the module identifier passed to <code class="language-javascript">require()</code> is not a native module,
and does not begin with <code class="language-javascript">&#39;/&#39;</code>, <code class="language-javascript">&#39;../&#39;</code>, or <code class="language-javascript">&#39;./&#39;</code>, then node starts at the
parent directory of the current module, and adds <code class="language-javascript">/node_modules</code>, and
attempts to load the module from that location.

</p>
<p>If it is not found there, then it moves to the parent directory, and so
on, until the root of the file system is reached.

</p>
<p>For example, if the file at <code class="language-javascript">&#39;/home/ry/projects/foo.js&#39;</code> called
<code class="language-javascript">require(&#39;bar.js&#39;)</code>, then node would look in the following locations, in
this order:

</p>
<ul>
<li><code class="language-javascript">/home/ry/projects/node_modules/bar.js</code></li>
<li><code class="language-javascript">/home/ry/node_modules/bar.js</code></li>
<li><code class="language-javascript">/home/node_modules/bar.js</code></li>
<li><code class="language-javascript">/node_modules/bar.js</code></li>
</ul>
<p>This allows programs to localize their dependencies, so that they do not
clash.

</p>
<p>You can require specific files or sub modules distributed with a module by
including a path suffix after the module name. For instance
<code class="language-javascript">require(&#39;example-module/path/to/file&#39;)</code> would resolve <code class="language-javascript">path/to/file</code>
relative to where <code class="language-javascript">example-module</code> is located. The suffixed path follows the
same module resolution semantics.

</p>
<!--next-->
<h2>Folders as Modules</h2>
<p>It is convenient to organize programs and libraries into self-contained
directories, and then provide a single entry point to that library.
There are three ways in which a folder may be passed to <code class="language-javascript">require()</code> as
an argument.

</p>
<p>The first is to create a <code class="language-javascript">package.json</code> file in the root of the folder,
which specifies a <code class="language-javascript">main</code> module.  An example package.json file might
look like this:

</p>
<pre><code class="language-javascript">{ &quot;name&quot; : &quot;some-library&quot;,
  &quot;main&quot; : &quot;./lib/some-library.js&quot; }</code></pre>
<p>If this was in a folder at <code class="language-javascript">./some-library</code>, then
<code class="language-javascript">require(&#39;./some-library&#39;)</code> would attempt to load
<code class="language-javascript">./some-library/lib/some-library.js</code>.

</p>
<p>This is the extent of Node&#39;s awareness of package.json files.

</p>
<p>If there is no package.json file present in the directory, then node
will attempt to load an <code class="language-javascript">index.js</code> or <code class="language-javascript">index.node</code> file out of that
directory.  For example, if there was no package.json file in the above
example, then <code class="language-javascript">require(&#39;./some-library&#39;)</code> would attempt to load:

</p>
<ul>
<li><code class="language-javascript">./some-library/index.js</code></li>
<li><code class="language-javascript">./some-library/index.node</code></li>
</ul>
<!--next-->
<h2>Caching</h2>
<p>Modules are cached after the first time they are loaded.  This means
(among other things) that every call to <code class="language-javascript">require(&#39;foo&#39;)</code> will get
exactly the same object returned, if it would resolve to the same file.

</p>
<p>Multiple calls to <code class="language-javascript">require(&#39;foo&#39;)</code> may not cause the module code to be
executed multiple times.  This is an important feature.  With it,
&quot;partially done&quot; objects can be returned, thus allowing transitive
dependencies to be loaded even when they would cause cycles.

</p>
<p>If you want to have a module execute code multiple times, then export a
function, and call that function.

</p>
<!--next-->
<h2>Module Caching Caveats</h2>
<p>Modules are cached based on their resolved filename.  Since modules may
resolve to a different filename based on the location of the calling
module (loading from <code class="language-javascript">node_modules</code> folders), it is not a <em>guarantee</em>
that <code class="language-javascript">require(&#39;foo&#39;)</code> will always return the exact same object, if it
would resolve to different files.

</p>
<!--next-->
<h2>The <code class="language-javascript">module</code> Object</h2>
<!-- name=module -->

<ul>
<li>{Object}</li>
</ul>
<p>In each module, the <code class="language-javascript">module</code> free variable is a reference to the object
representing the current module.  For convenience, <code class="language-javascript">module.exports</code> is
also accessible via the <code class="language-javascript">exports</code> module-global. <code class="language-javascript">module</code> isn&#39;t actually
a global but rather local to each module.

</p>
<!--next-->
<h2>module.exports</h2>
<div class="signature"><ul>
<li><span class="type">Object</span></li>
</div></ul>
<p>The <code class="language-javascript">module.exports</code> object is created by the Module system. Sometimes this is not
acceptable; many want their module to be an instance of some class. To do this,
assign the desired export object to <code class="language-javascript">module.exports</code>. Note that assigning the
desired object to <code class="language-javascript">exports</code> will simply rebind the local <code class="language-javascript">exports</code> variable,
which is probably not what you want to do.

</p>
<p>For example suppose we were making a module called <code class="language-javascript">a.js</code>

</p>
<pre><code class="language-javascript">var EventEmitter = require(&#39;events&#39;).EventEmitter;

module.exports = new EventEmitter();

// Do some work, and after some time emit
// the &#39;ready&#39; event from the module itself.
setTimeout(function() {
  module.exports.emit(&#39;ready&#39;);
}, 1000);</code></pre>
<p>Then in another file we could do

</p>
<pre><code class="language-javascript">var a = require(&#39;./a&#39;);
a.on(&#39;ready&#39;, function() {
  console.log(&#39;module a is ready&#39;);
});</code></pre>
<p>Note that assignment to <code class="language-javascript">module.exports</code> must be done immediately. It cannot be
done in any callbacks.  This does not work:

</p>
<p>x.js:

</p>
<pre><code class="language-javascript">setTimeout(function() {
  module.exports = { a: &quot;hello&quot; };
}, 0);</code></pre>
<p>y.js:

</p>
<pre><code class="language-javascript">var x = require(&#39;./x&#39;);
console.log(x.a);</code></pre>
<h4>exports alias</h4>
<p>The <code class="language-javascript">exports</code> variable that is available within a module starts as a reference
to <code class="language-javascript">module.exports</code>. As with any variable, if you assign a new value to it, it
is no longer bound to the previous value.

</p>
<p>To illustrate the behaviour, imagine this hypothetical implementation of
<code class="language-javascript">require()</code>:

</p>
<pre><code class="language-javascript">function require(...) {
  // ...
  function (module, exports) {
    // Your module code here
    exports = some_func;        // re-assigns exports, exports is no longer
                                // a shortcut, and nothing is exported.
    module.exports = some_func; // makes your module export 0
  } (module, module.exports);
  return module;
}</code></pre>
<p>As a guideline, if the relationship between <code class="language-javascript">exports</code> and <code class="language-javascript">module.exports</code>
seems like magic to you, ignore <code class="language-javascript">exports</code> and only use <code class="language-javascript">module.exports</code>.

</p>
<!--next-->
<h2>module.require(id)</h2>
<div class="signature"><ul>
<li><code class="language-javascript">id</code> <span class="type">String</span></li>
<li>Return: <span class="type">Object</span> <code class="language-javascript">module.exports</code> from the resolved module</li>
</div></ul>
<p>The <code class="language-javascript">module.require</code> method provides a way to load a module as if
<code class="language-javascript">require()</code> was called from the original module.

</p>
<p>Note that in order to do this, you must get a reference to the <code class="language-javascript">module</code>
object.  Since <code class="language-javascript">require()</code> returns the <code class="language-javascript">module.exports</code>, and the <code class="language-javascript">module</code> is
typically <em>only</em> available within a specific module&#39;s code, it must be
explicitly exported in order to be used.


</p>
<!--next-->
<h2>module.id</h2>
<div class="signature"><ul>
<li><span class="type">String</span></li>
</div></ul>
<p>The identifier for the module.  Typically this is the fully resolved
filename.


</p>
<!--next-->
<h2>module.filename</h2>
<div class="signature"><ul>
<li><span class="type">String</span></li>
</div></ul>
<p>The fully resolved filename to the module.


</p>
<!--next-->
<h2>module.loaded</h2>
<div class="signature"><ul>
<li><span class="type">Boolean</span></li>
</div></ul>
<p>Whether or not the module is done loading, or is in the process of
loading.


</p>
<!--next-->
<h2>module.parent</h2>
<div class="signature"><ul>
<li><span class="type">Module Object</span></li>
</div></ul>
<p>The module that required this one.


</p>
<!--next-->
<h2>module.children</h2>
<div class="signature"><ul>
<li><span class="type">Array</span></li>
</div></ul>
<p>The module objects required by this one.



</p>
<!--next-->
<h2>All Together...</h2>
<!-- type=misc -->

<p>To get the exact filename that will be loaded when <code class="language-javascript">require()</code> is called, use
the <code class="language-javascript">require.resolve()</code> function.

</p>
<p>Putting together all of the above, here is the high-level algorithm
in pseudocode of what require.resolve does:

</p>
<pre><code class="language-javascript">require(X) from module at path Y
1. If X is a core module,
   a. return the core module
   b. STOP
2. If X begins with &#39;./&#39; or &#39;/&#39; or &#39;../&#39;
   a. LOAD_AS_FILE(Y + X)
   b. LOAD_AS_DIRECTORY(Y + X)
3. LOAD_NODE_MODULES(X, dirname(Y))
4. THROW &quot;not found&quot;

LOAD_AS_FILE(X)
1. If X is a file, load X as JavaScript text.  STOP
2. If X.js is a file, load X.js as JavaScript text.  STOP
3. If X.json is a file, parse X.json to a JavaScript Object.  STOP
4. If X.node is a file, load X.node as binary addon.  STOP

LOAD_AS_DIRECTORY(X)
1. If X/package.json is a file,
   a. Parse X/package.json, and look for &quot;main&quot; field.
   b. let M = X + (json main field)
   c. LOAD_AS_FILE(M)
2. If X/index.js is a file, load X/index.js as JavaScript text.  STOP
3. If X/index.json is a file, parse X/index.json to a JavaScript object. STOP
4. If X/index.node is a file, load X/index.node as binary addon.  STOP

LOAD_NODE_MODULES(X, START)
1. let DIRS=NODE_MODULES_PATHS(START)
2. for each DIR in DIRS:
   a. LOAD_AS_FILE(DIR/X)
   b. LOAD_AS_DIRECTORY(DIR/X)

NODE_MODULES_PATHS(START)
1. let PARTS = path split(START)
2. let I = count of PARTS - 1
3. let DIRS = []
4. while I &gt;= 0,
   a. if PARTS[I] = &quot;node_modules&quot; CONTINUE
   c. DIR = path join(PARTS[0 .. I] + &quot;node_modules&quot;)
   b. DIRS = DIRS + DIR
   c. let I = I - 1
5. return DIRS</code></pre>
<!--next-->
<h2>Loading from the global folders</h2>
<!-- type=misc -->

<p>If the <code class="language-javascript">NODE_PATH</code> environment variable is set to a colon-delimited list
of absolute paths, then node will search those paths for modules if they
are not found elsewhere.  (Note: On Windows, <code class="language-javascript">NODE_PATH</code> is delimited by
semicolons instead of colons.)

</p>
<p>Additionally, node will search in the following locations:

</p>
<ul>
<li>1: <code class="language-javascript">$HOME/.node_modules</code></li>
<li>2: <code class="language-javascript">$HOME/.node_libraries</code></li>
<li>3: <code class="language-javascript">$PREFIX/lib/node</code></li>
</ul>
<p>Where <code class="language-javascript">$HOME</code> is the user&#39;s home directory, and <code class="language-javascript">$PREFIX</code> is node&#39;s
configured <code class="language-javascript">node_prefix</code>.

</p>
<p>These are mostly for historic reasons.  You are highly encouraged to
place your dependencies locally in <code class="language-javascript">node_modules</code> folders.  They will be
loaded faster, and more reliably.

</p>
<!--next-->
<h2>Accessing the main module</h2>
<!-- type=misc -->

<p>When a file is run directly from Node, <code class="language-javascript">require.main</code> is set to its
<code class="language-javascript">module</code>. That means that you can determine whether a file has been run
directly by testing

</p>
<pre><code class="language-javascript">require.main === module</code></pre>
<p>For a file <code class="language-javascript">foo.js</code>, this will be <code class="language-javascript">true</code> if run via <code class="language-javascript">node foo.js</code>, but
<code class="language-javascript">false</code> if run by <code class="language-javascript">require(&#39;./foo&#39;)</code>.

</p>
<p>Because <code class="language-javascript">module</code> provides a <code class="language-javascript">filename</code> property (normally equivalent to
<code class="language-javascript">__filename</code>), the entry point of the current application can be obtained
by checking <code class="language-javascript">require.main.filename</code>.

</p>
<!--next-->
<h2>Addenda: Package Manager Tips</h2>
<!-- type=misc -->

<p>The semantics of Node&#39;s <code class="language-javascript">require()</code> function were designed to be general
enough to support a number of sane directory structures. Package manager
programs such as <code class="language-javascript">dpkg</code>, <code class="language-javascript">rpm</code>, and <code class="language-javascript">npm</code> will hopefully find it possible to
build native packages from Node modules without modification.

</p>
<p>Below we give a suggested directory structure that could work:

</p>
<p>Let&#39;s say that we wanted to have the folder at
<code class="language-javascript">/usr/lib/node/&lt;some-package&gt;/&lt;some-version&gt;</code> hold the contents of a
specific version of a package.

</p>
<p>Packages can depend on one another. In order to install package <code class="language-javascript">foo</code>, you
may have to install a specific version of package <code class="language-javascript">bar</code>.  The <code class="language-javascript">bar</code> package
may itself have dependencies, and in some cases, these dependencies may even
collide or form cycles.

</p>
<p>Since Node looks up the <code class="language-javascript">realpath</code> of any modules it loads (that is,
resolves symlinks), and then looks for their dependencies in the
<code class="language-javascript">node_modules</code> folders as described above, this situation is very simple to
resolve with the following architecture:

</p>
<ul>
<li><code class="language-javascript">/usr/lib/node/foo/1.2.3/</code> - Contents of the <code class="language-javascript">foo</code> package, version 1.2.3.</li>
<li><code class="language-javascript">/usr/lib/node/bar/4.3.2/</code> - Contents of the <code class="language-javascript">bar</code> package that <code class="language-javascript">foo</code>
depends on.</li>
<li><code class="language-javascript">/usr/lib/node/foo/1.2.3/node_modules/bar</code> - Symbolic link to
<code class="language-javascript">/usr/lib/node/bar/4.3.2/</code>.</li>
<li><code class="language-javascript">/usr/lib/node/bar/4.3.2/node_modules/*</code> - Symbolic links to the packages
that <code class="language-javascript">bar</code> depends on.</li>
</ul>
<p>Thus, even if a cycle is encountered, or if there are dependency
conflicts, every module will be able to get a version of its dependency
that it can use.

</p>
<p>When the code in the <code class="language-javascript">foo</code> package does <code class="language-javascript">require(&#39;bar&#39;)</code>, it will get the
version that is symlinked into <code class="language-javascript">/usr/lib/node/foo/1.2.3/node_modules/bar</code>.
Then, when the code in the <code class="language-javascript">bar</code> package calls <code class="language-javascript">require(&#39;quux&#39;)</code>, it&#39;ll get
the version that is symlinked into
<code class="language-javascript">/usr/lib/node/bar/4.3.2/node_modules/quux</code>.

</p>
<p>Furthermore, to make the module lookup process even more optimal, rather
than putting packages directly in <code class="language-javascript">/usr/lib/node</code>, we could put them in
<code class="language-javascript">/usr/lib/node_modules/&lt;name&gt;/&lt;version&gt;</code>.  Then node will not bother
looking for missing dependencies in <code class="language-javascript">/usr/node_modules</code> or <code class="language-javascript">/node_modules</code>.

</p>
<p>In order to make modules available to the node REPL, it might be useful to
also add the <code class="language-javascript">/usr/lib/node_modules</code> folder to the <code class="language-javascript">$NODE_PATH</code> environment
variable.  Since the module lookups using <code class="language-javascript">node_modules</code> folders are all
relative, and based on the real path of the files making the calls to
<code class="language-javascript">require()</code>, the packages themselves can be anywhere.

</p>
<!--next-->
<h2>Addons</h2>
<p>Addons are dynamically linked shared objects. They can provide glue to C and
C++ libraries. The API (at the moment) is rather complex, involving
knowledge of several libraries:

</p>
<ul>
<li><p>V8 JavaScript, a C++ library. Used for interfacing with JavaScript:
creating objects, calling functions, etc.  Documented mostly in the
<code class="language-javascript">v8.h</code> header file (<code class="language-javascript">deps/v8/include/v8.h</code> in the Node source
tree), which is also available
<a>online</a>.</p>
</li>
<li><p><a>libuv</a>, C event loop library.
Anytime one needs to wait for a file descriptor to become readable,
wait for a timer, or wait for a signal to be received one will need
to interface with libuv. That is, if you perform any I/O, libuv will
need to be used.</p>
</li>
<li><p>Internal Node libraries. Most importantly is the <code class="language-javascript">node::ObjectWrap</code>
class which you will likely want to derive from.</p>
</li>
<li><p>Others. Look in <code class="language-javascript">deps/</code> for what else is available.</p>
</li>
</ul>
<p>Node statically compiles all its dependencies into the executable.
When compiling your module, you don&#39;t need to worry about linking to
any of these libraries.

</p>
<p>All of the following examples are available for
<a>download</a> and may be
used as a starting-point for your own Addon.

</p>
<!--next-->
<h2>Hello world</h2>
<p>To get started let&#39;s make a small Addon which is the C++ equivalent of
the following JavaScript code:

</p>
<pre><code class="language-javascript">module.exports.hello = function() { return &#39;world&#39;; };</code></pre>
<p>First we create a file <code class="language-javascript">hello.cc</code>:

</p>
<pre><code class="language-javascript">// hello.cc
#include &lt;node.h&gt;

using namespace v8;

void Method(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {
  Isolate* isolate = Isolate::GetCurrent();
  HandleScope scope(isolate);
  args.GetReturnValue().Set(String::NewFromUtf8(isolate, &quot;world&quot;));
}

void init(Handle&lt;Object&gt; exports) {
  NODE_SET_METHOD(exports, &quot;hello&quot;, Method);
}

NODE_MODULE(addon, init)</code></pre>
<p>Note that all Node addons must export an initialization function:

</p>
<pre><code class="language-javascript">void Initialize (Handle&lt;Object&gt; exports);
NODE_MODULE(module_name, Initialize)</code></pre>
<p>There is no semi-colon after <code class="language-javascript">NODE_MODULE</code> as it&#39;s not a function (see
<code class="language-javascript">node.h</code>).

</p>
<p>The <code class="language-javascript">module_name</code> needs to match the filename of the final binary (minus the
.node suffix).

</p>
<p>The source code needs to be built into <code class="language-javascript">addon.node</code>, the binary Addon. To
do this we create a file called <code class="language-javascript">binding.gyp</code> which describes the configuration
to build your module in a JSON-like format. This file gets compiled by
<a>node-gyp</a>.

</p>
<pre><code class="language-javascript">{
  &quot;targets&quot;: [
    {
      &quot;target_name&quot;: &quot;addon&quot;,
      &quot;sources&quot;: [ &quot;hello.cc&quot; ]
    }
  ]
}</code></pre>
<p>The next step is to generate the appropriate project build files for the
current platform. Use <code class="language-javascript">node-gyp configure</code> for that.

</p>
<p>Now you will have either a <code class="language-javascript">Makefile</code> (on Unix platforms) or a <code class="language-javascript">vcxproj</code> file
(on Windows) in the <code class="language-javascript">build/</code> directory. Next invoke the <code class="language-javascript">node-gyp build</code>
command.

</p>
<p>Now you have your compiled <code class="language-javascript">.node</code> bindings file! The compiled bindings end up
in <code class="language-javascript">build/Release/</code>.

</p>
<p>You can now use the binary addon in a Node project <code class="language-javascript">hello.js</code> by pointing
<code class="language-javascript">require</code> to the recently built <code class="language-javascript">hello.node</code> module:

</p>
<pre><code class="language-javascript">// hello.js
var addon = require(&#39;./build/Release/addon&#39;);

console.log(addon.hello()); // &#39;world&#39;</code></pre>
<p>Please see patterns below for further information or
</p>
<p><a>https://github.com/arturadib/node-qt</a> for an example in production.


</p>
<!--next-->
<h2>Addon patterns</h2>
<p>Below are some addon patterns to help you get started. Consult the online
<a>v8 reference</a> for help with the various v8
calls, and v8&#39;s <a>Embedder&#39;s Guide</a>
for an explanation of several concepts used such as handles, scopes,
function templates, etc.

</p>
<p>In order to use these examples you need to compile them using <code class="language-javascript">node-gyp</code>.
Create the following <code class="language-javascript">binding.gyp</code> file:

</p>
<pre><code class="language-javascript">{
  &quot;targets&quot;: [
    {
      &quot;target_name&quot;: &quot;addon&quot;,
      &quot;sources&quot;: [ &quot;addon.cc&quot; ]
    }
  ]
}</code></pre>
<p>In cases where there is more than one <code class="language-javascript">.cc</code> file, simply add the file name to
the <code class="language-javascript">sources</code> array, e.g.:

</p>
<pre><code class="language-javascript">&quot;sources&quot;: [&quot;addon.cc&quot;, &quot;myexample.cc&quot;]</code></pre>
<p>Now that you have your <code class="language-javascript">binding.gyp</code> ready, you can configure and build the
addon:

</p>
<pre><code class="language-javascript">$ node-gyp configure build</code></pre>
<!--next-->
<h2>Function arguments</h2>
<p>The following pattern illustrates how to read arguments from JavaScript
function calls and return a result. This is the main and only needed source
<code class="language-javascript">addon.cc</code>:

</p>
<pre><code class="language-javascript">// addon.cc
#include &lt;node.h&gt;

using namespace v8;

void Add(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {
  Isolate* isolate = Isolate::GetCurrent();
  HandleScope scope(isolate);

  if (args.Length() &lt; 2) {
    isolate-&gt;ThrowException(Exception::TypeError(
        String::NewFromUtf8(isolate, &quot;Wrong number of arguments&quot;)));
    return;
  }

  if (!args[0]-&gt;IsNumber() || !args[1]-&gt;IsNumber()) {
    isolate-&gt;ThrowException(Exception::TypeError(
        String::NewFromUtf8(isolate, &quot;Wrong arguments&quot;)));
    return;
  }

  double value = args[0]-&gt;NumberValue() + args[1]-&gt;NumberValue();
  Local&lt;Number&gt; num = Number::New(isolate, value);

  args.GetReturnValue().Set(num);
}

void Init(Handle&lt;Object&gt; exports) {
  NODE_SET_METHOD(exports, &quot;add&quot;, Add);
}

NODE_MODULE(addon, Init)</code></pre>
<p>You can test it with the following JavaScript snippet:

</p>
<pre><code class="language-javascript">// test.js
var addon = require(&#39;./build/Release/addon&#39;);

console.log( &#39;This should be eight:&#39;, addon.add(3,5) );</code></pre>
<!--next-->
<h2>Callbacks</h2>
<p>You can pass JavaScript functions to a C++ function and execute them from
there. Here&#39;s <code class="language-javascript">addon.cc</code>:

</p>
<pre><code class="language-javascript">// addon.cc
#include &lt;node.h&gt;

using namespace v8;

void RunCallback(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {
  Isolate* isolate = Isolate::GetCurrent();
  HandleScope scope(isolate);

  Local&lt;Function&gt; cb = Local&lt;Function&gt;::Cast(args[0]);
  const unsigned argc = 1;
  Local&lt;Value&gt; argv[argc] = { String::NewFromUtf8(isolate, &quot;hello world&quot;) };
  cb-&gt;Call(isolate-&gt;GetCurrentContext()-&gt;Global(), argc, argv);
}

void Init(Handle&lt;Object&gt; exports, Handle&lt;Object&gt; module) {
  NODE_SET_METHOD(module, &quot;exports&quot;, RunCallback);
}

NODE_MODULE(addon, Init)</code></pre>
<p>Note that this example uses a two-argument form of <code class="language-javascript">Init()</code> that receives
the full <code class="language-javascript">module</code> object as the second argument. This allows the addon
to completely overwrite <code class="language-javascript">exports</code> with a single function instead of
adding the function as a property of <code class="language-javascript">exports</code>.

</p>
<p>To test it run the following JavaScript snippet:

</p>
<pre><code class="language-javascript">// test.js
var addon = require(&#39;./build/Release/addon&#39;);

addon(function(msg){
  console.log(msg); // &#39;hello world&#39;
});</code></pre>
<!--next-->
<h2>Object factory</h2>
<p>You can create and return new objects from within a C++ function with this
<code class="language-javascript">addon.cc</code> pattern, which returns an object with property <code class="language-javascript">msg</code> that echoes
the string passed to <code class="language-javascript">createObject()</code>:

</p>
<pre><code class="language-javascript">// addon.cc
#include &lt;node.h&gt;

using namespace v8;

void CreateObject(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {
  Isolate* isolate = Isolate::GetCurrent();
  HandleScope scope(isolate);

  Local&lt;Object&gt; obj = Object::New(isolate);
  obj-&gt;Set(String::NewFromUtf8(isolate, &quot;msg&quot;), args[0]-&gt;ToString());

  args.GetReturnValue().Set(obj);
}

void Init(Handle&lt;Object&gt; exports, Handle&lt;Object&gt; module) {
  NODE_SET_METHOD(module, &quot;exports&quot;, CreateObject);
}

NODE_MODULE(addon, Init)</code></pre>
<p>To test it in JavaScript:

</p>
<pre><code class="language-javascript">// test.js
var addon = require(&#39;./build/Release/addon&#39;);

var obj1 = addon(&#39;hello&#39;);
var obj2 = addon(&#39;world&#39;);
console.log(obj1.msg+&#39; &#39;+obj2.msg); // &#39;hello world&#39;</code></pre>
<!--next-->
<h2>Function factory</h2>
<p>This pattern illustrates how to create and return a JavaScript function that
wraps a C++ function:

</p>
<pre><code class="language-javascript">// addon.cc
#include &lt;node.h&gt;

using namespace v8;

void MyFunction(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {
  Isolate* isolate = Isolate::GetCurrent();
  HandleScope scope(isolate);
  args.GetReturnValue().Set(String::NewFromUtf8(isolate, &quot;hello world&quot;));
}

void CreateFunction(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {
  Isolate* isolate = Isolate::GetCurrent();
  HandleScope scope(isolate);

  Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::New(isolate, MyFunction);
  Local&lt;Function&gt; fn = tpl-&gt;GetFunction();

  // omit this to make it anonymous
  fn-&gt;SetName(String::NewFromUtf8(isolate, &quot;theFunction&quot;));

  args.GetReturnValue().Set(fn);
}

void Init(Handle&lt;Object&gt; exports, Handle&lt;Object&gt; module) {
  NODE_SET_METHOD(module, &quot;exports&quot;, CreateFunction);
}

NODE_MODULE(addon, Init)</code></pre>
<p>To test:

</p>
<pre><code class="language-javascript">// test.js
var addon = require(&#39;./build/Release/addon&#39;);

var fn = addon();
console.log(fn()); // &#39;hello world&#39;</code></pre>
<!--next-->
<h2>Wrapping C++ objects</h2>
<p>Here we will create a wrapper for a C++ object/class <code class="language-javascript">MyObject</code> that can be
instantiated in JavaScript through the <code class="language-javascript">new</code> operator. First prepare the main
module <code class="language-javascript">addon.cc</code>:

</p>
<pre><code class="language-javascript">// addon.cc
#include &lt;node.h&gt;
#include &quot;myobject.h&quot;

using namespace v8;

void InitAll(Handle&lt;Object&gt; exports) {
  MyObject::Init(exports);
}

NODE_MODULE(addon, InitAll)</code></pre>
<p>Then in <code class="language-javascript">myobject.h</code> make your wrapper inherit from <code class="language-javascript">node::ObjectWrap</code>:

</p>
<pre><code class="language-javascript">// myobject.h
#ifndef MYOBJECT_H
#define MYOBJECT_H

#include &lt;node.h&gt;
#include &lt;node_object_wrap.h&gt;

class MyObject : public node::ObjectWrap {
 public:
  static void Init(v8::Handle&lt;v8::Object&gt; exports);

 private:
  explicit MyObject(double value = 0);
  ~MyObject();

  static void New(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args);
  static void PlusOne(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args);
  static v8::Persistent&lt;v8::Function&gt; constructor;
  double value_;
};

#endif</code></pre>
<p>And in <code class="language-javascript">myobject.cc</code> implement the various methods that you want to expose.
Here we expose the method <code class="language-javascript">plusOne</code> by adding it to the constructor&#39;s
prototype:

</p>
<pre><code class="language-javascript">// myobject.cc
#include &quot;myobject.h&quot;

using namespace v8;

Persistent&lt;Function&gt; MyObject::constructor;

MyObject::MyObject(double value) : value_(value) {
}

MyObject::~MyObject() {
}

void MyObject::Init(Handle&lt;Object&gt; exports) {
  Isolate* isolate = Isolate::GetCurrent();

  // Prepare constructor template
  Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::New(isolate, New);
  tpl-&gt;SetClassName(String::NewFromUtf8(isolate, &quot;MyObject&quot;));
  tpl-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(1);

  // Prototype
  NODE_SET_PROTOTYPE_METHOD(tpl, &quot;plusOne&quot;, PlusOne);

  constructor.Reset(isolate, tpl-&gt;GetFunction());
  exports-&gt;Set(String::NewFromUtf8(isolate, &quot;MyObject&quot;),
               tpl-&gt;GetFunction());
}

void MyObject::New(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {
  Isolate* isolate = Isolate::GetCurrent();
  HandleScope scope(isolate);

  if (args.IsConstructCall()) {
    // Invoked as constructor: `new MyObject(...)`
    double value = args[0]-&gt;IsUndefined() ? 0 : args[0]-&gt;NumberValue();
    MyObject* obj = new MyObject(value);
    obj-&gt;Wrap(args.This());
    args.GetReturnValue().Set(args.This());
  } else {
    // Invoked as plain function `MyObject(...)`, turn into construct call.
    const int argc = 1;
    Local&lt;Value&gt; argv[argc] = { args[0] };
    Local&lt;Function&gt; cons = Local&lt;Function&gt;::New(isolate, constructor);
    args.GetReturnValue().Set(cons-&gt;NewInstance(argc, argv));
  }
}

void MyObject::PlusOne(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {
  Isolate* isolate = Isolate::GetCurrent();
  HandleScope scope(isolate);

  MyObject* obj = ObjectWrap::Unwrap&lt;MyObject&gt;(args.Holder());
  obj-&gt;value_ += 1;

  args.GetReturnValue().Set(Number::New(isolate, obj-&gt;value_));
}</code></pre>
<p>Test it with:

</p>
<pre><code class="language-javascript">// test.js
var addon = require(&#39;./build/Release/addon&#39;);

var obj = new addon.MyObject(10);
console.log( obj.plusOne() ); // 11
console.log( obj.plusOne() ); // 12
console.log( obj.plusOne() ); // 13</code></pre>
<!--next-->
<h2>Factory of wrapped objects</h2>
<p>This is useful when you want to be able to create native objects without
explicitly instantiating them with the <code class="language-javascript">new</code> operator in JavaScript, e.g.

</p>
<pre><code class="language-javascript">var obj = addon.createObject();
// instead of:
// var obj = new addon.Object();</code></pre>
<p>Let&#39;s register our <code class="language-javascript">createObject</code> method in <code class="language-javascript">addon.cc</code>:

</p>
<pre><code class="language-javascript">// addon.cc
#include &lt;node.h&gt;
#include &quot;myobject.h&quot;

using namespace v8;

void CreateObject(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {
  Isolate* isolate = Isolate::GetCurrent();
  HandleScope scope(isolate);
  MyObject::NewInstance(args);
}

void InitAll(Handle&lt;Object&gt; exports, Handle&lt;Object&gt; module) {
  MyObject::Init();

  NODE_SET_METHOD(module, &quot;exports&quot;, CreateObject);
}

NODE_MODULE(addon, InitAll)</code></pre>
<p>In <code class="language-javascript">myobject.h</code> we now introduce the static method <code class="language-javascript">NewInstance</code> that takes
care of instantiating the object (i.e. it does the job of <code class="language-javascript">new</code> in JavaScript):

</p>
<pre><code class="language-javascript">// myobject.h
#ifndef MYOBJECT_H
#define MYOBJECT_H

#include &lt;node.h&gt;
#include &lt;node_object_wrap.h&gt;

class MyObject : public node::ObjectWrap {
 public:
  static void Init();
  static void NewInstance(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args);

 private:
  explicit MyObject(double value = 0);
  ~MyObject();

  static void New(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args);
  static void PlusOne(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args);
  static v8::Persistent&lt;v8::Function&gt; constructor;
  double value_;
};

#endif</code></pre>
<p>The implementation is similar to the above in <code class="language-javascript">myobject.cc</code>:

</p>
<pre><code class="language-javascript">// myobject.cc
#include &lt;node.h&gt;
#include &quot;myobject.h&quot;

using namespace v8;

Persistent&lt;Function&gt; MyObject::constructor;

MyObject::MyObject(double value) : value_(value) {
}

MyObject::~MyObject() {
}

void MyObject::Init() {
  Isolate* isolate = Isolate::GetCurrent();
  // Prepare constructor template
  Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::New(isolate, New);
  tpl-&gt;SetClassName(String::NewFromUtf8(isolate, &quot;MyObject&quot;));
  tpl-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(1);

  // Prototype
  NODE_SET_PROTOTYPE_METHOD(tpl, &quot;plusOne&quot;, PlusOne);

  constructor.Reset(isolate, tpl-&gt;GetFunction());
}

void MyObject::New(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {
  Isolate* isolate = Isolate::GetCurrent();
  HandleScope scope(isolate);

  if (args.IsConstructCall()) {
    // Invoked as constructor: `new MyObject(...)`
    double value = args[0]-&gt;IsUndefined() ? 0 : args[0]-&gt;NumberValue();
    MyObject* obj = new MyObject(value);
    obj-&gt;Wrap(args.This());
    args.GetReturnValue().Set(args.This());
  } else {
    // Invoked as plain function `MyObject(...)`, turn into construct call.
    const int argc = 1;
    Local&lt;Value&gt; argv[argc] = { args[0] };
    Local&lt;Function&gt; cons = Local&lt;Function&gt;::New(isolate, constructor);
    args.GetReturnValue().Set(cons-&gt;NewInstance(argc, argv));
  }
}

void MyObject::NewInstance(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {
  Isolate* isolate = Isolate::GetCurrent();
  HandleScope scope(isolate);

  const unsigned argc = 1;
  Handle&lt;Value&gt; argv[argc] = { args[0] };
  Local&lt;Function&gt; cons = Local&lt;Function&gt;::New(isolate, constructor);
  Local&lt;Object&gt; instance = cons-&gt;NewInstance(argc, argv);

  args.GetReturnValue().Set(instance);
}

void MyObject::PlusOne(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {
  Isolate* isolate = Isolate::GetCurrent();
  HandleScope scope(isolate);

  MyObject* obj = ObjectWrap::Unwrap&lt;MyObject&gt;(args.Holder());
  obj-&gt;value_ += 1;

  args.GetReturnValue().Set(Number::New(isolate, obj-&gt;value_));
}</code></pre>
<p>Test it with:

</p>
<pre><code class="language-javascript">// test.js
var createObject = require(&#39;./build/Release/addon&#39;);

var obj = createObject(10);
console.log( obj.plusOne() ); // 11
console.log( obj.plusOne() ); // 12
console.log( obj.plusOne() ); // 13

var obj2 = createObject(20);
console.log( obj2.plusOne() ); // 21
console.log( obj2.plusOne() ); // 22
console.log( obj2.plusOne() ); // 23</code></pre>
<!--next-->
<h2>Passing wrapped objects around</h2>
<p>In addition to wrapping and returning C++ objects, you can pass them around
by unwrapping them with Node&#39;s <code class="language-javascript">node::ObjectWrap::Unwrap</code> helper function.
In the following <code class="language-javascript">addon.cc</code> we introduce a function <code class="language-javascript">add()</code> that can take on two
<code class="language-javascript">MyObject</code> objects:

</p>
<pre><code class="language-javascript">// addon.cc
#include &lt;node.h&gt;
#include &lt;node_object_wrap.h&gt;
#include &quot;myobject.h&quot;

using namespace v8;

void CreateObject(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {
  Isolate* isolate = Isolate::GetCurrent();
  HandleScope scope(isolate);
  MyObject::NewInstance(args);
}

void Add(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {
  Isolate* isolate = Isolate::GetCurrent();
  HandleScope scope(isolate);

  MyObject* obj1 = node::ObjectWrap::Unwrap&lt;MyObject&gt;(
      args[0]-&gt;ToObject());
  MyObject* obj2 = node::ObjectWrap::Unwrap&lt;MyObject&gt;(
      args[1]-&gt;ToObject());

  double sum = obj1-&gt;value() + obj2-&gt;value();
  args.GetReturnValue().Set(Number::New(isolate, sum));
}

void InitAll(Handle&lt;Object&gt; exports) {
  MyObject::Init();

  NODE_SET_METHOD(exports, &quot;createObject&quot;, CreateObject);
  NODE_SET_METHOD(exports, &quot;add&quot;, Add);
}

NODE_MODULE(addon, InitAll)</code></pre>
<p>To make things interesting we introduce a public method in <code class="language-javascript">myobject.h</code> so we
can probe private values after unwrapping the object:

</p>
<pre><code class="language-javascript">// myobject.h
#ifndef MYOBJECT_H
#define MYOBJECT_H

#include &lt;node.h&gt;
#include &lt;node_object_wrap.h&gt;

class MyObject : public node::ObjectWrap {
 public:
  static void Init();
  static void NewInstance(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args);
  inline double value() const { return value_; }

 private:
  explicit MyObject(double value = 0);
  ~MyObject();

  static void New(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args);
  static v8::Persistent&lt;v8::Function&gt; constructor;
  double value_;
};

#endif</code></pre>
<p>The implementation of <code class="language-javascript">myobject.cc</code> is similar as before:

</p>
<pre><code class="language-javascript">// myobject.cc
#include &lt;node.h&gt;
#include &quot;myobject.h&quot;

using namespace v8;

Persistent&lt;Function&gt; MyObject::constructor;

MyObject::MyObject(double value) : value_(value) {
}

MyObject::~MyObject() {
}

void MyObject::Init() {
  Isolate* isolate = Isolate::GetCurrent();

  // Prepare constructor template
  Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::New(isolate, New);
  tpl-&gt;SetClassName(String::NewFromUtf8(isolate, &quot;MyObject&quot;));
  tpl-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(1);

  constructor.Reset(isolate, tpl-&gt;GetFunction());
}

void MyObject::New(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {
  Isolate* isolate = Isolate::GetCurrent();
  HandleScope scope(isolate);

  if (args.IsConstructCall()) {
    // Invoked as constructor: `new MyObject(...)`
    double value = args[0]-&gt;IsUndefined() ? 0 : args[0]-&gt;NumberValue();
    MyObject* obj = new MyObject(value);
    obj-&gt;Wrap(args.This());
    args.GetReturnValue().Set(args.This());
  } else {
    // Invoked as plain function `MyObject(...)`, turn into construct call.
    const int argc = 1;
    Local&lt;Value&gt; argv[argc] = { args[0] };
    Local&lt;Function&gt; cons = Local&lt;Function&gt;::New(isolate, constructor);
    args.GetReturnValue().Set(cons-&gt;NewInstance(argc, argv));
  }
}

void MyObject::NewInstance(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {
  Isolate* isolate = Isolate::GetCurrent();
  HandleScope scope(isolate);

  const unsigned argc = 1;
  Handle&lt;Value&gt; argv[argc] = { args[0] };
  Local&lt;Function&gt; cons = Local&lt;Function&gt;::New(isolate, constructor);
  Local&lt;Object&gt; instance = cons-&gt;NewInstance(argc, argv);

  args.GetReturnValue().Set(instance);
}</code></pre>
<p>Test it with:

</p>
<pre><code class="language-javascript">// test.js
var addon = require(&#39;./build/Release/addon&#39;);

var obj1 = addon.createObject(10);
var obj2 = addon.createObject(20);
var result = addon.add(obj1, obj2);

console.log(result); // 30</code></pre>
<!--next-->
<h2>process</h2>

<p>The <code class="language-javascript">process</code> object is a global object and can be accessed from anywhere.
It is an instance of <a>EventEmitter</a>.

</p>
<!--next-->
<h2>Exit Codes</h2>
<p>Node will normally exit with a <code class="language-javascript">0</code> status code when no more async
operations are pending.  The following status codes are used in other
cases:

</p>
<ul>
<li><code class="language-javascript">1</code> <strong>Uncaught Fatal Exception</strong> - There was an uncaught exception,
and it was not handled by a domain or an <code class="language-javascript">uncaughtException</code> event
handler.</li>
<li><code class="language-javascript">2</code> - Unused (reserved by Bash for builtin misuse)</li>
<li><code class="language-javascript">3</code> <strong>Internal JavaScript Parse Error</strong> - The JavaScript source code
internal in Node&#39;s bootstrapping process caused a parse error.  This
is extremely rare, and generally can only happen during development
of Node itself.</li>
<li><code class="language-javascript">4</code> <strong>Internal JavaScript Evaluation Failure</strong> - The JavaScript
source code internal in Node&#39;s bootstrapping process failed to
return a function value when evaluated.  This is extremely rare, and
generally can only happen during development of Node itself.</li>
<li><code class="language-javascript">5</code> <strong>Fatal Error</strong> - There was a fatal unrecoverable error in V8.
Typically a message will be printed to stderr with the prefix <code class="language-javascript">FATAL
ERROR</code>.</li>
<li><code class="language-javascript">6</code> <strong>Non-function Internal Exception Handler</strong> - There was an
uncaught exception, but the internal fatal exception handler
function was somehow set to a non-function, and could not be called.</li>
<li><code class="language-javascript">7</code> <strong>Internal Exception Handler Run-Time Failure</strong> - There was an
uncaught exception, and the internal fatal exception handler
function itself threw an error while attempting to handle it.  This
can happen, for example, if a <code class="language-javascript">process.on(&#39;uncaughtException&#39;)</code> or
<code class="language-javascript">domain.on(&#39;error&#39;)</code> handler throws an error.</li>
<li><code class="language-javascript">8</code> - Unused.  In previous versions of Node, exit code 8 sometimes
indicated an uncaught exception.</li>
<li><code class="language-javascript">9</code> - <strong>Invalid Argument</strong> - Either an unknown option was specified,
or an option requiring a value was provided without a value.</li>
<li><code class="language-javascript">10</code> <strong>Internal JavaScript Run-Time Failure</strong> - The JavaScript
source code internal in Node&#39;s bootstrapping process threw an error
when the bootstrapping function was called.  This is extremely rare,
and generally can only happen during development of Node itself.</li>
<li><code class="language-javascript">12</code> <strong>Invalid Debug Argument</strong> - The <code class="language-javascript">--debug</code> and/or <code class="language-javascript">--debug-brk</code>
options were set, but an invalid port number was chosen.</li>
<li><code class="language-javascript">&gt;128</code> <strong>Signal Exits</strong> - If Node receives a fatal signal such as
<code class="language-javascript">SIGKILL</code> or <code class="language-javascript">SIGHUP</code>, then its exit code will be <code class="language-javascript">128</code> plus the
value of the signal code.  This is a standard Unix practice, since
exit codes are defined to be 7-bit integers, and signal exits set
the high-order bit, and then contain the value of the signal code.</li>
</ul>
<!--next-->
<h2>Event: &#39;exit&#39;</h2>
<p>Emitted when the process is about to exit. There is no way to prevent the
exiting of the event loop at this point, and once all <code class="language-javascript">exit</code> listeners have
finished running the process will exit. Therefore you <strong>must</strong> only perform
<strong>synchronous</strong> operations in this handler. This is a good hook to perform
checks on the module&#39;s state (like for unit tests). The callback takes one
argument, the code the process is exiting with.

</p>
<p>Example of listening for <code class="language-javascript">exit</code>:

</p>
<pre><code class="language-javascript">process.on(&#39;exit&#39;, function(code) {
  // do *NOT* do this
  setTimeout(function() {
    console.log(&#39;This will not run&#39;);
  }, 0);
  console.log(&#39;About to exit with code:&#39;, code);
});</code></pre>
<!--next-->
<h2>Event: &#39;beforeExit&#39;</h2>
<p>This event is emitted when node empties it&#39;s event loop and has nothing else to
schedule. Normally, node exits when there is no work scheduled, but a listener
for &#39;beforeExit&#39; can make asynchronous calls, and cause node to continue.

</p>
<p>&#39;beforeExit&#39; is not emitted for conditions causing explicit termination, such as
<code class="language-javascript">process.exit()</code> or uncaught exceptions, and should not be used as an
alternative to the &#39;exit&#39; event unless the intention is to schedule more work.


</p>
<!--next-->
<h2>Event: &#39;uncaughtException&#39;</h2>
<p>Emitted when an exception bubbles all the way back to the event loop. If a
listener is added for this exception, the default action (which is to print
a stack trace and exit) will not occur.

</p>
<p>Example of listening for <code class="language-javascript">uncaughtException</code>:

</p>
<pre><code class="language-javascript">process.on(&#39;uncaughtException&#39;, function(err) {
  console.log(&#39;Caught exception: &#39; + err);
});

setTimeout(function() {
  console.log(&#39;This will still run.&#39;);
}, 500);

// Intentionally cause an exception, but don&#39;t catch it.
nonexistentFunc();
console.log(&#39;This will not run.&#39;);</code></pre>
<p>Note that <code class="language-javascript">uncaughtException</code> is a very crude mechanism for exception
handling.

</p>
<p>Don&#39;t use it, use <a>domains</a> instead. If you do use it, restart
your application after every unhandled exception!

</p>
<p>Do <em>not</em> use it as the node.js equivalent of <code class="language-javascript">On Error Resume Next</code>. An
unhandled exception means your application - and by extension node.js itself -
is in an undefined state. Blindly resuming means <em>anything</em> could happen.

</p>
<p>Think of resuming as pulling the power cord when you are upgrading your system.
Nine out of ten times nothing happens - but the 10th time, your system is bust.

</p>
<p>You have been warned.

</p>
<!--next-->
<h2>Signal Events</h2>
<!--type=event-->

<p>Emitted when the processes receives a signal. See sigaction(2) for a list of
standard POSIX signal names such as SIGINT, SIGHUP, etc.

</p>
<p>Example of listening for <code class="language-javascript">SIGINT</code>:

</p>
<pre><code class="language-javascript">// Start reading from stdin so we don&#39;t exit.
process.stdin.resume();

process.on(&#39;SIGINT&#39;, function() {
  console.log(&#39;Got SIGINT.  Press Control-D to exit.&#39;);
});</code></pre>
<p>An easy way to send the <code class="language-javascript">SIGINT</code> signal is with <code class="language-javascript">Control-C</code> in most terminal
programs.

</p>
<p>Note:

</p>
<ul>
<li><code class="language-javascript">SIGUSR1</code> is reserved by node.js to start the debugger.  It&#39;s possible to
install a listener but that won&#39;t stop the debugger from starting.</li>
<li><code class="language-javascript">SIGTERM</code> and <code class="language-javascript">SIGINT</code> have default handlers on non-Windows platforms that resets
the terminal mode before exiting with code <code class="language-javascript">128 + signal number</code>. If one of
these signals has a listener installed, its default behaviour will be removed
(node will no longer exit).</li>
<li><code class="language-javascript">SIGPIPE</code> is ignored by default, it can have a listener installed.</li>
<li><code class="language-javascript">SIGHUP</code> is generated on Windows when the console window is closed, and on other
platforms under various similar conditions, see signal(7). It can have a
listener installed, however node will be unconditionally terminated by Windows
about 10 seconds later. On non-Windows platforms, the default behaviour of
<code class="language-javascript">SIGHUP</code> is to terminate node, but once a listener has been installed its
default behaviour will be removed.</li>
<li><code class="language-javascript">SIGTERM</code> is not supported on Windows, it can be listened on.</li>
<li><code class="language-javascript">SIGINT</code> from the terminal is supported on all platforms, and can usually be
generated with <code class="language-javascript">CTRL+C</code> (though this may be configurable). It is not generated
when terminal raw mode is enabled.</li>
<li><code class="language-javascript">SIGBREAK</code> is delivered on Windows when <code class="language-javascript">CTRL+BREAK</code> is pressed, on non-Windows
platforms it can be listened on, but there is no way to send or generate it.</li>
<li><code class="language-javascript">SIGWINCH</code> is delivered when the console has been resized. On Windows, this will
only happen on write to the console when the cursor is being moved, or when a
readable tty is used in raw mode.</li>
<li><code class="language-javascript">SIGKILL</code> cannot have a listener installed, it will unconditionally terminate
node on all platforms.</li>
<li><code class="language-javascript">SIGSTOP</code> cannot have a listener installed.</li>
</ul>
<p>Note that Windows does not support sending Signals, but node offers some
emulation with <code class="language-javascript">process.kill()</code>, and <code class="language-javascript">child_process.kill()</code>:
- Sending signal <code class="language-javascript">0</code> can be used to search for the existence of a process
- Sending <code class="language-javascript">SIGINT</code>, <code class="language-javascript">SIGTERM</code>, and <code class="language-javascript">SIGKILL</code> cause the unconditional exit of the
  target process.

</p>
<!--next-->
<h2>process.stdout</h2>
<p>A <code class="language-javascript">Writable Stream</code> to <code class="language-javascript">stdout</code> (on fd <code class="language-javascript">1</code>).

</p>
<p>Example: the definition of <code class="language-javascript">console.log</code>

</p>
<pre><code class="language-javascript">console.log = function(d) {
  process.stdout.write(d + &#39;\n&#39;);
};</code></pre>
<p><code class="language-javascript">process.stderr</code> and <code class="language-javascript">process.stdout</code> are unlike other streams in Node in
that they cannot be closed (<code class="language-javascript">end()</code> will throw), they never emit the <code class="language-javascript">finish</code>
event and that writes are usually blocking.

</p>
<ul>
<li>They are blocking in the case that they refer to regular files or TTY file
descriptors.</li>
<li>In the case they refer to pipes:<ul>
<li>They are blocking in Linux/Unix.</li>
<li>They are non-blocking like other streams in Windows.</li>
</ul>
</li>
</ul>
<p>To check if Node is being run in a TTY context, read the <code class="language-javascript">isTTY</code> property
on <code class="language-javascript">process.stderr</code>, <code class="language-javascript">process.stdout</code>, or <code class="language-javascript">process.stdin</code>:

</p>
<pre><code class="language-javascript">$ node -p &quot;Boolean(process.stdin.isTTY)&quot;
true
$ echo &quot;foo&quot; | node -p &quot;Boolean(process.stdin.isTTY)&quot;
false

$ node -p &quot;Boolean(process.stdout.isTTY)&quot;
true
$ node -p &quot;Boolean(process.stdout.isTTY)&quot; | cat
false</code></pre>
<p>See <a>the tty docs</a> for more information.

</p>
<!--next-->
<h2>process.stderr</h2>
<p>A writable stream to stderr (on fd <code class="language-javascript">2</code>).

</p>
<p><code class="language-javascript">process.stderr</code> and <code class="language-javascript">process.stdout</code> are unlike other streams in Node in
that they cannot be closed (<code class="language-javascript">end()</code> will throw), they never emit the <code class="language-javascript">finish</code>
event and that writes are usually blocking.

</p>
<ul>
<li>They are blocking in the case that they refer to regular files or TTY file
descriptors.</li>
<li>In the case they refer to pipes:<ul>
<li>They are blocking in Linux/Unix.</li>
<li>They are non-blocking like other streams in Windows.</li>
</ul>
</li>
</ul>
<!--next-->
<h2>process.stdin</h2>
<p>A <code class="language-javascript">Readable Stream</code> for stdin (on fd <code class="language-javascript">0</code>).

</p>
<p>Example of opening standard input and listening for both events:

</p>
<pre><code class="language-javascript">process.stdin.setEncoding(&#39;utf8&#39;);

process.stdin.on(&#39;readable&#39;, function() {
  var chunk = process.stdin.read();
  if (chunk !== null) {
    process.stdout.write(&#39;data: &#39; + chunk);
  }
});

process.stdin.on(&#39;end&#39;, function() {
  process.stdout.write(&#39;end&#39;);
});</code></pre>
<p>As a Stream, <code class="language-javascript">process.stdin</code> can also be used in &quot;old&quot; mode that is compatible
with scripts written for node prior v0.10.
For more information see
<a>Stream compatibility</a>.

</p>
<p>In &quot;old&quot; Streams mode the stdin stream is paused by default, so one
must call <code class="language-javascript">process.stdin.resume()</code> to read from it. Note also that calling
<code class="language-javascript">process.stdin.resume()</code> itself would switch stream to &quot;old&quot; mode.

</p>
<p>If you are starting a new project you should prefer a more recent &quot;new&quot; Streams
mode over &quot;old&quot; one.

</p>
<!--next-->
<h2>process.argv</h2>
<p>An array containing the command line arguments.  The first element will be
&#39;node&#39;, the second element will be the name of the JavaScript file.  The
next elements will be any additional command line arguments.

</p>
<pre><code class="language-javascript">// print process.argv
process.argv.forEach(function(val, index, array) {
  console.log(index + &#39;: &#39; + val);
});</code></pre>
<p>This will generate:

</p>
<pre><code class="language-javascript">$ node process-2.js one two=three four
0: node
1: /Users/mjr/work/node/process-2.js
2: one
3: two=three
4: four</code></pre>
<!--next-->
<h2>process.execPath</h2>
<p>This is the absolute pathname of the executable that started the process.

</p>
<p>Example:

</p>
<pre><code class="language-javascript">/usr/local/bin/node</code></pre>
<!--next-->
<h2>process.execArgv</h2>
<p>This is the set of node-specific command line options from the
executable that started the process.  These options do not show up in
<code class="language-javascript">process.argv</code>, and do not include the node executable, the name of
the script, or any options following the script name. These options
are useful in order to spawn child processes with the same execution
environment as the parent.

</p>
<p>Example:

</p>
<pre><code class="language-javascript">$ node --harmony script.js --version</code></pre>
<p>results in process.execArgv:

</p>
<pre><code class="language-javascript">[&#39;--harmony&#39;]</code></pre>
<p>and process.argv:

</p>
<pre><code class="language-javascript">[&#39;/usr/local/bin/node&#39;, &#39;script.js&#39;, &#39;--version&#39;]</code></pre>
<!--next-->
<h2>process.abort()</h2>
<p>This causes node to emit an abort. This will cause node to exit and
generate a core file.

</p>
<!--next-->
<h2>process.chdir(directory)</h2>
<p>Changes the current working directory of the process or throws an exception if that fails.

</p>
<pre><code class="language-javascript">console.log(&#39;Starting directory: &#39; + process.cwd());
try {
  process.chdir(&#39;/tmp&#39;);
  console.log(&#39;New directory: &#39; + process.cwd());
}
catch (err) {
  console.log(&#39;chdir: &#39; + err);
}</code></pre>
<!--next-->
<h2>process.cwd()</h2>
<p>Returns the current working directory of the process.

</p>
<pre><code class="language-javascript">console.log(&#39;Current directory: &#39; + process.cwd());</code></pre>
<!--next-->
<h2>process.env</h2>
<p>An object containing the user environment. See environ(7).

</p>
<p>An example of this object looks like:

</p>
<pre><code class="language-javascript">{ TERM: &#39;xterm-256color&#39;,
  SHELL: &#39;/usr/local/bin/bash&#39;,
  USER: &#39;maciej&#39;,
  PATH: &#39;~/.bin/:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin&#39;,
  PWD: &#39;/Users/maciej&#39;,
  EDITOR: &#39;vim&#39;,
  SHLVL: &#39;1&#39;,
  HOME: &#39;/Users/maciej&#39;,
  LOGNAME: &#39;maciej&#39;,
  _: &#39;/usr/local/bin/node&#39; }</code></pre>
<p>You can write to this object, but changes won&#39;t be reflected outside of your
process. That means that the following won&#39;t work:

</p>
<pre><code class="language-javascript">node -e &#39;process.env.foo = &quot;bar&quot;&#39; &amp;&amp; echo $foo</code></pre>
<p>But this will:

</p>
<pre><code class="language-javascript">process.env.foo = &#39;bar&#39;;
console.log(process.env.foo);</code></pre>
<!--next-->
<h2>process.exit([code])</h2>
<p>Ends the process with the specified <code class="language-javascript">code</code>.  If omitted, exit uses the
&#39;success&#39; code <code class="language-javascript">0</code>.

</p>
<p>To exit with a &#39;failure&#39; code:

</p>
<pre><code class="language-javascript">process.exit(1);</code></pre>
<p>The shell that executed node should see the exit code as 1.


</p>
<!--next-->
<h2>process.exitCode</h2>
<p>A number which will be the process exit code, when the process either
exits gracefully, or is exited via <code class="language-javascript">process.exit()</code> without specifying
a code.

</p>
<p>Specifying a code to <code class="language-javascript">process.exit(code)</code> will override any previous
setting of <code class="language-javascript">process.exitCode</code>.


</p>
<!--next-->
<h2>process.getgid()</h2>
<p>Note: this function is only available on POSIX platforms (i.e. not Windows,
Android)

</p>
<p>Gets the group identity of the process. (See getgid(2).)
This is the numerical group id, not the group name.

</p>
<pre><code class="language-javascript">if (process.getgid) {
  console.log(&#39;Current gid: &#39; + process.getgid());
}</code></pre>
<!--next-->
<h2>process.setgid(id)</h2>
<p>Note: this function is only available on POSIX platforms (i.e. not Windows,
Android)

</p>
<p>Sets the group identity of the process. (See setgid(2).)  This accepts either
a numerical ID or a groupname string. If a groupname is specified, this method
blocks while resolving it to a numerical ID.

</p>
<pre><code class="language-javascript">if (process.getgid &amp;&amp; process.setgid) {
  console.log(&#39;Current gid: &#39; + process.getgid());
  try {
    process.setgid(501);
    console.log(&#39;New gid: &#39; + process.getgid());
  }
  catch (err) {
    console.log(&#39;Failed to set gid: &#39; + err);
  }
}</code></pre>
<!--next-->
<h2>process.getuid()</h2>
<p>Note: this function is only available on POSIX platforms (i.e. not Windows,
Android)

</p>
<p>Gets the user identity of the process. (See getuid(2).)
This is the numerical userid, not the username.

</p>
<pre><code class="language-javascript">if (process.getuid) {
  console.log(&#39;Current uid: &#39; + process.getuid());
}</code></pre>
<!--next-->
<h2>process.setuid(id)</h2>
<p>Note: this function is only available on POSIX platforms (i.e. not Windows,
Android)

</p>
<p>Sets the user identity of the process. (See setuid(2).)  This accepts either
a numerical ID or a username string.  If a username is specified, this method
blocks while resolving it to a numerical ID.

</p>
<pre><code class="language-javascript">if (process.getuid &amp;&amp; process.setuid) {
  console.log(&#39;Current uid: &#39; + process.getuid());
  try {
    process.setuid(501);
    console.log(&#39;New uid: &#39; + process.getuid());
  }
  catch (err) {
    console.log(&#39;Failed to set uid: &#39; + err);
  }
}</code></pre>
<!--next-->
<h2>process.getgroups()</h2>
<p>Note: this function is only available on POSIX platforms (i.e. not Windows,
Android)

</p>
<p>Returns an array with the supplementary group IDs. POSIX leaves it unspecified
if the effective group ID is included but node.js ensures it always is.


</p>
<!--next-->
<h2>process.setgroups(groups)</h2>
<p>Note: this function is only available on POSIX platforms (i.e. not Windows,
Android)

</p>
<p>Sets the supplementary group IDs. This is a privileged operation, meaning you
need to be root or have the CAP_SETGID capability.

</p>
<p>The list can contain group IDs, group names or both.


</p>
<!--next-->
<h2>process.initgroups(user, extra_group)</h2>
<p>Note: this function is only available on POSIX platforms (i.e. not Windows,
Android)

</p>
<p>Reads /etc/group and initializes the group access list, using all groups of
which the user is a member. This is a privileged operation, meaning you need
to be root or have the CAP_SETGID capability.

</p>
<p><code class="language-javascript">user</code> is a user name or user ID. <code class="language-javascript">extra_group</code> is a group name or group ID.

</p>
<p>Some care needs to be taken when dropping privileges. Example:

</p>
<pre><code class="language-javascript">console.log(process.getgroups());         // [ 0 ]
process.initgroups(&#39;bnoordhuis&#39;, 1000);   // switch user
console.log(process.getgroups());         // [ 27, 30, 46, 1000, 0 ]
process.setgid(1000);                     // drop root gid
console.log(process.getgroups());         // [ 27, 30, 46, 1000 ]</code></pre>
<!--next-->
<h2>process.version</h2>
<p>A compiled-in property that exposes <code class="language-javascript">NODE_VERSION</code>.

</p>
<pre><code class="language-javascript">console.log(&#39;Version: &#39; + process.version);</code></pre>
<!--next-->
<h2>process.versions</h2>
<p>A property exposing version strings of node and its dependencies.

</p>
<pre><code class="language-javascript">console.log(process.versions);</code></pre>
<p>Will print something like:

</p>
<pre><code class="language-javascript">{ http_parser: &#39;1.0&#39;,
  node: &#39;0.10.4&#39;,
  v8: &#39;3.14.5.8&#39;,
  ares: &#39;1.9.0-DEV&#39;,
  uv: &#39;0.10.3&#39;,
  zlib: &#39;1.2.3&#39;,
  modules: &#39;11&#39;,
  openssl: &#39;1.0.1e&#39; }</code></pre>
<!--next-->
<h2>process.config</h2>
<p>An Object containing the JavaScript representation of the configure options
that were used to compile the current node executable. This is the same as
the &quot;config.gypi&quot; file that was produced when running the <code class="language-javascript">./configure</code> script.

</p>
<p>An example of the possible output looks like:

</p>
<pre><code class="language-javascript">{ target_defaults:
   { cflags: [],
     default_configuration: &#39;Release&#39;,
     defines: [],
     include_dirs: [],
     libraries: [] },
  variables:
   { host_arch: &#39;x64&#39;,
     node_install_npm: &#39;true&#39;,
     node_prefix: &#39;&#39;,
     node_shared_cares: &#39;false&#39;,
     node_shared_http_parser: &#39;false&#39;,
     node_shared_libuv: &#39;false&#39;,
     node_shared_v8: &#39;false&#39;,
     node_shared_zlib: &#39;false&#39;,
     node_use_dtrace: &#39;false&#39;,
     node_use_openssl: &#39;true&#39;,
     node_shared_openssl: &#39;false&#39;,
     strict_aliasing: &#39;true&#39;,
     target_arch: &#39;x64&#39;,
     v8_use_snapshot: &#39;true&#39; } }</code></pre>
<!--next-->
<h2>process.kill(pid[, signal])</h2>
<p>Send a signal to a process. <code class="language-javascript">pid</code> is the process id and <code class="language-javascript">signal</code> is the
string describing the signal to send.  Signal names are strings like
&#39;SIGINT&#39; or &#39;SIGHUP&#39;.  If omitted, the signal will be &#39;SIGTERM&#39;.
See <a>Signal Events</a> and kill(2) for more information.

</p>
<p>Will throw an error if target does not exist, and as a special case, a signal of
<code class="language-javascript">0</code> can be used to test for the existence of a process.

</p>
<p>Note that just because the name of this function is <code class="language-javascript">process.kill</code>, it is
really just a signal sender, like the <code class="language-javascript">kill</code> system call.  The signal sent
may do something other than kill the target process.

</p>
<p>Example of sending a signal to yourself:

</p>
<pre><code class="language-javascript">process.on(&#39;SIGHUP&#39;, function() {
  console.log(&#39;Got SIGHUP signal.&#39;);
});

setTimeout(function() {
  console.log(&#39;Exiting.&#39;);
  process.exit(0);
}, 100);

process.kill(process.pid, &#39;SIGHUP&#39;);</code></pre>
<p>Note: When SIGUSR1 is received by Node.js it starts the debugger, see
<a>Signal Events</a>.

</p>
<!--next-->
<h2>process.pid</h2>
<p>The PID of the process.

</p>
<pre><code class="language-javascript">console.log(&#39;This process is pid &#39; + process.pid);</code></pre>
<!--next-->
<h2>process.title</h2>
<p>Getter/setter to set what is displayed in &#39;ps&#39;.

</p>
<p>When used as a setter, the maximum length is platform-specific and probably
short.

</p>
<p>On Linux and OS X, it&#39;s limited to the size of the binary name plus the
length of the command line arguments because it overwrites the argv memory.

</p>
<p>v0.8 allowed for longer process title strings by also overwriting the environ
memory but that was potentially insecure/confusing in some (rather obscure)
cases.


</p>
<!--next-->
<h2>process.arch</h2>
<p>What processor architecture you&#39;re running on: <code class="language-javascript">&#39;arm&#39;</code>, <code class="language-javascript">&#39;ia32&#39;</code>, or <code class="language-javascript">&#39;x64&#39;</code>.

</p>
<pre><code class="language-javascript">console.log(&#39;This processor architecture is &#39; + process.arch);</code></pre>
<!--next-->
<h2>process.platform</h2>
<p>What platform you&#39;re running on:
<code class="language-javascript">&#39;darwin&#39;</code>, <code class="language-javascript">&#39;freebsd&#39;</code>, <code class="language-javascript">&#39;linux&#39;</code>, <code class="language-javascript">&#39;sunos&#39;</code> or <code class="language-javascript">&#39;win32&#39;</code>

</p>
<pre><code class="language-javascript">console.log(&#39;This platform is &#39; + process.platform);</code></pre>
<!--next-->
<h2>process.memoryUsage()</h2>
<p>Returns an object describing the memory usage of the Node process
measured in bytes.

</p>
<pre><code class="language-javascript">var util = require(&#39;util&#39;);

console.log(util.inspect(process.memoryUsage()));</code></pre>
<p>This will generate:

</p>
<pre><code class="language-javascript">{ rss: 4935680,
  heapTotal: 1826816,
  heapUsed: 650472 }</code></pre>
<p><code class="language-javascript">heapTotal</code> and <code class="language-javascript">heapUsed</code> refer to V8&#39;s memory usage.


</p>
<!--next-->
<h2>process.nextTick(callback)</h2>
<div class="signature"><ul>
<li><code class="language-javascript">callback</code> <span class="type">Function</span></li>
</div></ul>
<p>Once the current event loop turn runs to completion, call the callback
function.

</p>
<p>This is <em>not</em> a simple alias to <code class="language-javascript">setTimeout(fn, 0)</code>, it&#39;s much more
efficient.  It runs before any additional I/O events (including
timers) fire in subsequent ticks of the event loop.

</p>
<pre><code class="language-javascript">console.log(&#39;start&#39;);
process.nextTick(function() {
  console.log(&#39;nextTick callback&#39;);
});
console.log(&#39;scheduled&#39;);
// Output:
// start
// scheduled
// nextTick callback</code></pre>
<p>This is important in developing APIs where you want to give the user the
chance to assign event handlers after an object has been constructed,
but before any I/O has occurred.

</p>
<pre><code class="language-javascript">function MyThing(options) {
  this.setupOptions(options);

  process.nextTick(function() {
    this.startDoingStuff();
  }.bind(this));
}

var thing = new MyThing();
thing.getReadyForStuff();

// thing.startDoingStuff() gets called now, not before.</code></pre>
<p>It is very important for APIs to be either 100% synchronous or 100%
asynchronous.  Consider this example:

</p>
<pre><code class="language-javascript">// WARNING!  DO NOT USE!  BAD UNSAFE HAZARD!
function maybeSync(arg, cb) {
  if (arg) {
    cb();
    return;
  }

  fs.stat(&#39;file&#39;, cb);
}</code></pre>
<p>This API is hazardous.  If you do this:

</p>
<pre><code class="language-javascript">maybeSync(true, function() {
  foo();
});
bar();</code></pre>
<p>then it&#39;s not clear whether <code class="language-javascript">foo()</code> or <code class="language-javascript">bar()</code> will be called first.

</p>
<p>This approach is much better:

</p>
<pre><code class="language-javascript">function definitelyAsync(arg, cb) {
  if (arg) {
    process.nextTick(cb);
    return;
  }

  fs.stat(&#39;file&#39;, cb);
}</code></pre>
<p>Note: the nextTick queue is completely drained on each pass of the
event loop <strong>before</strong> additional I/O is processed.  As a result,
recursively setting nextTick callbacks will block any I/O from
happening, just like a <code class="language-javascript">while(true);</code> loop.

</p>
<!--next-->
<h2>process.umask([mask])</h2>
<p>Sets or reads the process&#39;s file mode creation mask. Child processes inherit
the mask from the parent process. Returns the old mask if <code class="language-javascript">mask</code> argument is
given, otherwise returns the current mask.

</p>
<pre><code class="language-javascript">var oldmask, newmask = 0022;

oldmask = process.umask(newmask);
console.log(&#39;Changed umask from: &#39; + oldmask.toString(8) +
            &#39; to &#39; + newmask.toString(8));</code></pre>
<!--next-->
<h2>process.uptime()</h2>
<p>Number of seconds Node has been running.


</p>
<!--next-->
<h2>process.hrtime()</h2>
<p>Returns the current high-resolution real time in a <code class="language-javascript">[seconds, nanoseconds]</code>
tuple Array. It is relative to an arbitrary time in the past. It is not
related to the time of day and therefore not subject to clock drift. The
primary use is for measuring performance between intervals.

</p>
<p>You may pass in the result of a previous call to <code class="language-javascript">process.hrtime()</code> to get
a diff reading, useful for benchmarks and measuring intervals:

</p>
<pre><code class="language-javascript">var time = process.hrtime();
// [ 1800216, 25 ]

setTimeout(function() {
  var diff = process.hrtime(time);
  // [ 1, 552 ]

  console.log(&#39;benchmark took %d nanoseconds&#39;, diff[0] * 1e9 + diff[1]);
  // benchmark took 1000000527 nanoseconds
}, 1000);</code></pre>
<!--next-->
<h2>process.mainModule</h2>
<p>Alternate way to retrieve
<a><code class="language-javascript">require.main</code></a>.
The difference is that if the main module changes at runtime, <code class="language-javascript">require.main</code>
might still refer to the original main module in modules that were required
before the change occurred. Generally it&#39;s safe to assume that the two refer
to the same module.

</p>
<p>As with <code class="language-javascript">require.main</code>, it will be <code class="language-javascript">undefined</code> if there was no entry script.

</p>
<!--next-->
<h2>util</h2>
<pre class="stability">Stability: 4 - API Frozen</pre><p>These functions are in the module <code class="language-javascript">&#39;util&#39;</code>. Use <code class="language-javascript">require(&#39;util&#39;)</code> to
access them.

</p>
<p>The <code class="language-javascript">util</code> module is primarily designed to support the needs of Node&#39;s
internal APIs.  Many of these utilities are useful for your own
programs.  If you find that these functions are lacking for your
purposes, however, you are encouraged to write your own utilities.  We
are not interested in any future additions to the <code class="language-javascript">util</code> module that
are unnecessary for Node&#39;s internal functionality.

</p>
<!--next-->
<h2>util.debuglog(section)</h2>
<div class="signature"><ul>
<li><code class="language-javascript">section</code> <span class="type">String</span> The section of the program to be debugged</li>
<li>Returns: <span class="type">Function</span> The logging function</li>
</div></ul>
<p>This is used to create a function which conditionally writes to stderr
based on the existence of a <code class="language-javascript">NODE_DEBUG</code> environment variable.  If the
<code class="language-javascript">section</code> name appears in that environment variable, then the returned
function will be similar to <code class="language-javascript">console.error()</code>.  If not, then the
returned function is a no-op.

</p>
<p>For example:

</p>
<pre><code class="javascript">var debuglog = util.debuglog(&#39;foo&#39;);

var bar = 123;
debuglog(&#39;hello from foo [%d]&#39;, bar);</code></pre>
<p>If this program is run with <code class="language-javascript">NODE_DEBUG=foo</code> in the environment, then
it will output something like:

</p>
<pre><code class="language-javascript">FOO 3245: hello from foo [123]</code></pre>
<p>where <code class="language-javascript">3245</code> is the process id.  If it is not run with that
environment variable set, then it will not print anything.

</p>
<p>You may separate multiple <code class="language-javascript">NODE_DEBUG</code> environment variables with a
comma.  For example, <code class="language-javascript">NODE_DEBUG=fs,net,tls</code>.

</p>
<!--next-->
<h2>util.format(format[, ...])</h2>
<p>Returns a formatted string using the first argument as a <code class="language-javascript">printf</code>-like format.

</p>
<p>The first argument is a string that contains zero or more <em>placeholders</em>.
Each placeholder is replaced with the converted value from its corresponding
argument. Supported placeholders are:

</p>
<ul>
<li><code class="language-javascript">%s</code> - String.</li>
<li><code class="language-javascript">%d</code> - Number (both integer and float).</li>
<li><code class="language-javascript">%j</code> - JSON.  Replaced with the string <code class="language-javascript">&#39;[Circular]&#39;</code> if the argument<pre><code class="language-javascript">   contains circular references.</code></pre>
</li>
<li><code class="language-javascript">%</code> - single percent sign (<code class="language-javascript">&#39;%&#39;</code>). This does not consume an argument.</li>
</ul>
<p>If the placeholder does not have a corresponding argument, the placeholder is
not replaced.

</p>
<pre><code class="language-javascript">util.format(&#39;%s:%s&#39;, &#39;foo&#39;); // &#39;foo:%s&#39;</code></pre>
<p>If there are more arguments than placeholders, the extra arguments are
converted to strings with <code class="language-javascript">util.inspect()</code> and these strings are concatenated,
delimited by a space.

</p>
<pre><code class="language-javascript">util.format(&#39;%s:%s&#39;, &#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;); // &#39;foo:bar baz&#39;</code></pre>
<p>If the first argument is not a format string then <code class="language-javascript">util.format()</code> returns
a string that is the concatenation of all its arguments separated by spaces.
Each argument is converted to a string with <code class="language-javascript">util.inspect()</code>.

</p>
<pre><code class="language-javascript">util.format(1, 2, 3); // &#39;1 2 3&#39;</code></pre>
<!--next-->
<h2>util.log(string)</h2>
<p>Output with timestamp on <code class="language-javascript">stdout</code>.

</p>
<pre><code class="language-javascript">require(&#39;util&#39;).log(&#39;Timestamped message.&#39;);</code></pre>
<!--next-->
<h2>util.inspect(object[, options])</h2>
<p>Return a string representation of <code class="language-javascript">object</code>, which is useful for debugging.

</p>
<p>An optional <em>options</em> object may be passed that alters certain aspects of the
formatted string:

</p>
<ul>
<li><p><code class="language-javascript">showHidden</code> - if <code class="language-javascript">true</code> then the object&#39;s non-enumerable properties will be
shown too. Defaults to <code class="language-javascript">false</code>.</p>
</li>
<li><p><code class="language-javascript">depth</code> - tells <code class="language-javascript">inspect</code> how many times to recurse while formatting the
object. This is useful for inspecting large complicated objects. Defaults to
<code class="language-javascript">2</code>. To make it recurse indefinitely pass <code class="language-javascript">null</code>.</p>
</li>
<li><p><code class="language-javascript">colors</code> - if <code class="language-javascript">true</code>, then the output will be styled with ANSI color codes.
Defaults to <code class="language-javascript">false</code>. Colors are customizable, see below.</p>
</li>
<li><p><code class="language-javascript">customInspect</code> - if <code class="language-javascript">false</code>, then custom <code class="language-javascript">inspect(depth, opts)</code> functions
defined on the objects being inspected won&#39;t be called. Defaults to <code class="language-javascript">true</code>.</p>
</li>
</ul>
<p>Example of inspecting all properties of the <code class="language-javascript">util</code> object:

</p>
<pre><code class="language-javascript">var util = require(&#39;util&#39;);

console.log(util.inspect(util, { showHidden: true, depth: null }));</code></pre>
<p>Values may supply their own custom <code class="language-javascript">inspect(depth, opts)</code> functions, when
called they receive the current depth in the recursive inspection, as well as
the options object passed to <code class="language-javascript">util.inspect()</code>.

</p>
<!--next-->
<h2>Customizing <code class="language-javascript">util.inspect</code> colors</h2>
<!-- type=misc -->

<p>Color output (if enabled) of <code class="language-javascript">util.inspect</code> is customizable globally
via <code class="language-javascript">util.inspect.styles</code> and <code class="language-javascript">util.inspect.colors</code> objects.

</p>
<p><code class="language-javascript">util.inspect.styles</code> is a map assigning each style a color
from <code class="language-javascript">util.inspect.colors</code>.
Highlighted styles and their default values are:
 <em> <code class="language-javascript">number</code> (yellow)
 </em> <code class="language-javascript">boolean</code> (yellow)
 <em> <code class="language-javascript">string</code> (green)
 </em> <code class="language-javascript">date</code> (magenta)
 <em> <code class="language-javascript">regexp</code> (red)
 </em> <code class="language-javascript">null</code> (bold)
 <em> <code class="language-javascript">undefined</code> (grey)
 </em> <code class="language-javascript">special</code> - only function at this time (cyan)
 * <code class="language-javascript">name</code> (intentionally no styling)

</p>
<p>Predefined color codes are: <code class="language-javascript">white</code>, <code class="language-javascript">grey</code>, <code class="language-javascript">black</code>, <code class="language-javascript">blue</code>, <code class="language-javascript">cyan</code>,
<code class="language-javascript">green</code>, <code class="language-javascript">magenta</code>, <code class="language-javascript">red</code> and <code class="language-javascript">yellow</code>.
There are also <code class="language-javascript">bold</code>, <code class="language-javascript">italic</code>, <code class="language-javascript">underline</code> and <code class="language-javascript">inverse</code> codes.

</p>
<!--next-->
<h2>Custom <code class="language-javascript">inspect()</code> function on Objects</h2>
<!-- type=misc -->

<p>Objects also may define their own <code class="language-javascript">inspect(depth)</code> function which <code class="language-javascript">util.inspect()</code>
will invoke and use the result of when inspecting the object:

</p>
<pre><code class="language-javascript">var util = require(&#39;util&#39;);

var obj = { name: &#39;nate&#39; };
obj.inspect = function(depth) {
  return &#39;{&#39; + this.name + &#39;}&#39;;
};

util.inspect(obj);
  // &quot;{nate}&quot;</code></pre>
<p>You may also return another Object entirely, and the returned String will be
formatted according to the returned Object. This is similar to how
<code class="language-javascript">JSON.stringify()</code> works:

</p>
<pre><code class="language-javascript">var obj = { foo: &#39;this will not show up in the inspect() output&#39; };
obj.inspect = function(depth) {
  return { bar: &#39;baz&#39; };
};

util.inspect(obj);
  // &quot;{ bar: &#39;baz&#39; }&quot;</code></pre>
<!--next-->
<h2>util.isArray(object)</h2>
<p>Internal alias for Array.isArray.

</p>
<p>Returns <code class="language-javascript">true</code> if the given &quot;object&quot; is an <code class="language-javascript">Array</code>. <code class="language-javascript">false</code> otherwise.

</p>
<pre><code class="language-javascript">var util = require(&#39;util&#39;);

util.isArray([])
  // true
util.isArray(new Array)
  // true
util.isArray({})
  // false</code></pre>
<!--next-->
<h2>util.isRegExp(object)</h2>
<p>Returns <code class="language-javascript">true</code> if the given &quot;object&quot; is a <code class="language-javascript">RegExp</code>. <code class="language-javascript">false</code> otherwise.

</p>
<pre><code class="language-javascript">var util = require(&#39;util&#39;);

util.isRegExp(/some regexp/)
  // true
util.isRegExp(new RegExp(&#39;another regexp&#39;))
  // true
util.isRegExp({})
  // false</code></pre>
<!--next-->
<h2>util.isDate(object)</h2>
<p>Returns <code class="language-javascript">true</code> if the given &quot;object&quot; is a <code class="language-javascript">Date</code>. <code class="language-javascript">false</code> otherwise.

</p>
<pre><code class="language-javascript">var util = require(&#39;util&#39;);

util.isDate(new Date())
  // true
util.isDate(Date())
  // false (without &#39;new&#39; returns a String)
util.isDate({})
  // false</code></pre>
<!--next-->
<h2>util.isError(object)</h2>
<p>Returns <code class="language-javascript">true</code> if the given &quot;object&quot; is an <code class="language-javascript">Error</code>. <code class="language-javascript">false</code> otherwise.

</p>
<pre><code class="language-javascript">var util = require(&#39;util&#39;);

util.isError(new Error())
  // true
util.isError(new TypeError())
  // true
util.isError({ name: &#39;Error&#39;, message: &#39;an error occurred&#39; })
  // false</code></pre>
<!--next-->
<h2>util.inherits(constructor, superConstructor)</h2>
<p>Inherit the prototype methods from one
<a>constructor</a>
into another.  The prototype of <code class="language-javascript">constructor</code> will be set to a new
object created from <code class="language-javascript">superConstructor</code>.

</p>
<p>As an additional convenience, <code class="language-javascript">superConstructor</code> will be accessible
through the <code class="language-javascript">constructor.super_</code> property.

</p>
<pre><code class="language-javascript">var util = require(&quot;util&quot;);
var events = require(&quot;events&quot;);

function MyStream() {
    events.EventEmitter.call(this);
}

util.inherits(MyStream, events.EventEmitter);

MyStream.prototype.write = function(data) {
    this.emit(&quot;data&quot;, data);
}

var stream = new MyStream();

console.log(stream instanceof events.EventEmitter); // true
console.log(MyStream.super_ === events.EventEmitter); // true

stream.on(&quot;data&quot;, function(data) {
    console.log(&#39;Received data: &quot;&#39; + data + &#39;&quot;&#39;);
})
stream.write(&quot;It works!&quot;); // Received data: &quot;It works!&quot;</code></pre>
<!--next-->
<h2>util.deprecate(function, string)</h2>
<p>Marks that a method should not be used any more.

</p>
<pre><code class="language-javascript">exports.puts = exports.deprecate(function() {
  for (var i = 0, len = arguments.length; i &lt; len; ++i) {
    process.stdout.write(arguments[i] + &#39;\n&#39;);
  }
}, &#39;util.puts: Use console.log instead&#39;)</code></pre>
<p>It returns a modified function which warns once by default. If
<code class="language-javascript">--no-deprecation</code> is set then this function is a NO-OP. If
<code class="language-javascript">--throw-deprecation</code> is set then the application will throw an exception
if the deprecated API is used.

</p>
<!--next-->
<h2>util.debug(string)</h2>
<pre class="stability">Stability: 0 - Deprecated: use console.error() instead.</pre><p>Deprecated predecessor of <code class="language-javascript">console.error</code>.

</p>
<!--next-->
<h2>util.error([...])</h2>
<pre class="stability">Stability: 0 - Deprecated: Use console.error() instead.</pre><p>Deprecated predecessor of <code class="language-javascript">console.error</code>.

</p>
<!--next-->
<h2>util.puts([...])</h2>
<pre class="stability">Stability: 0 - Deprecated: Use console.log() instead.</pre><p>Deprecated predecessor of <code class="language-javascript">console.log</code>.

</p>
<!--next-->
<h2>util.print([...])</h2>
<pre class="stability">Stability: 0 - Deprecated: Use <code class="language-javascript">console.log</code> instead.</pre><p>Deprecated predecessor of <code class="language-javascript">console.log</code>.


</p>
<!--next-->
<h2>util.pump(readableStream, writableStream[, callback])</h2>
<pre class="stability">Stability: 0 - Deprecated: Use readableStream.pipe(writableStream)</pre><p>Deprecated predecessor of <code class="language-javascript">stream.pipe()</code>.

</p>
<!--next-->
<h2>Events</h2>
<pre class="stability">Stability: 4 - API Frozen</pre><!--type=module-->

<p>Many objects in Node emit events: a <code class="language-javascript">net.Server</code> emits an event each time
a peer connects to it, a <code class="language-javascript">fs.readStream</code> emits an event when the file is
opened. All objects which emit events are instances of <code class="language-javascript">events.EventEmitter</code>.
You can access this module by doing: <code class="language-javascript">require(&quot;events&quot;);</code>

</p>
<p>Typically, event names are represented by a camel-cased string, however,
there aren&#39;t any strict restrictions on that, as any string will be accepted.

</p>
<p>Functions can then be attached to objects, to be executed when an event
is emitted. These functions are called <em>listeners</em>. Inside a listener
function, <code class="language-javascript">this</code> refers to the <code class="language-javascript">EventEmitter</code> that the listener was
attached to.


</p>
<!--next-->
<h2>Class: events.EventEmitter</h2>
<p>To access the EventEmitter class, <code class="language-javascript">require(&#39;events&#39;).EventEmitter</code>.

</p>
<p>When an <code class="language-javascript">EventEmitter</code> instance experiences an error, the typical action is
to emit an <code class="language-javascript">&#39;error&#39;</code> event.  Error events are treated as a special case in node.
If there is no listener for it, then the default action is to print a stack
trace and exit the program.

</p>
<p>All EventEmitters emit the event <code class="language-javascript">&#39;newListener&#39;</code> when new listeners are
added and <code class="language-javascript">&#39;removeListener&#39;</code> when a listener is removed.

</p>
<!--next-->
<h2>emitter.addListener(event, listener)</h2>
<!--next-->
<h2>emitter.on(event, listener)</h2>
<p>Adds a listener to the end of the listeners array for the specified <code class="language-javascript">event</code>.
No checks are made to see if the <code class="language-javascript">listener</code> has already been added. Multiple
calls passing the same combination of <code class="language-javascript">event</code> and <code class="language-javascript">listener</code> will result in the
<code class="language-javascript">listener</code> being added multiple times.

</p>
<pre><code class="language-javascript">server.on(&#39;connection&#39;, function (stream) {
  console.log(&#39;someone connected!&#39;);
});</code></pre>
<p>Returns emitter, so calls can be chained.

</p>
<!--next-->
<h2>emitter.once(event, listener)</h2>
<p>Adds a <strong>one time</strong> listener for the event. This listener is
invoked only the next time the event is fired, after which
it is removed.

</p>
<pre><code class="language-javascript">server.once(&#39;connection&#39;, function (stream) {
  console.log(&#39;Ah, we have our first user!&#39;);
});</code></pre>
<p>Returns emitter, so calls can be chained.

</p>
<!--next-->
<h2>emitter.removeListener(event, listener)</h2>
<p>Remove a listener from the listener array for the specified event.
<strong>Caution</strong>: changes array indices in the listener array behind the listener.

</p>
<pre><code class="language-javascript">var callback = function(stream) {
  console.log(&#39;someone connected!&#39;);
};
server.on(&#39;connection&#39;, callback);
// ...
server.removeListener(&#39;connection&#39;, callback);</code></pre>
<p><code class="language-javascript">removeListener</code> will remove, at most, one instance of a listener from the
listener array. If any single listener has been added multiple times to the
listener array for the specified <code class="language-javascript">event</code>, then <code class="language-javascript">removeListener</code> must be called
multiple times to remove each instance.

</p>
<p>Returns emitter, so calls can be chained.

</p>
<!--next-->
<h2>emitter.removeAllListeners([event])</h2>
<p>Removes all listeners, or those of the specified event. It&#39;s not a good idea to
remove listeners that were added elsewhere in the code, especially when it&#39;s on
an emitter that you didn&#39;t create (e.g. sockets or file streams).

</p>
<p>Returns emitter, so calls can be chained.

</p>
<!--next-->
<h2>emitter.setMaxListeners(n)</h2>
<p>By default EventEmitters will print a warning if more than 10 listeners are
added for a particular event. This is a useful default which helps finding
memory leaks. Obviously not all Emitters should be limited to 10. This function
allows that to be increased. Set to zero for unlimited.

</p>
<p>Returns emitter, so calls can be chained.

</p>
<!--next-->
<h2>EventEmitter.defaultMaxListeners</h2>
<p><code class="language-javascript">emitter.setMaxListeners(n)</code> sets the maximum on a per-instance basis.
This class property lets you set it for <em>all</em> <code class="language-javascript">EventEmitter</code> instances,
current and future, effective immediately. Use with care.

</p>
<p>Note that <code class="language-javascript">emitter.setMaxListeners(n)</code> still has precedence over
<code class="language-javascript">EventEmitter.defaultMaxListeners</code>.


</p>
<!--next-->
<h2>emitter.listeners(event)</h2>
<p>Returns an array of listeners for the specified event.

</p>
<pre><code class="language-javascript">server.on(&#39;connection&#39;, function (stream) {
  console.log(&#39;someone connected!&#39;);
});
console.log(util.inspect(server.listeners(&#39;connection&#39;))); // [ [Function] ]</code></pre>
<!--next-->
<h2>emitter.emit(event[, arg1][, arg2][, ...])</h2>
<p>Execute each of the listeners in order with the supplied arguments.

</p>
<p>Returns <code class="language-javascript">true</code> if event had listeners, <code class="language-javascript">false</code> otherwise.


</p>
<!--next-->
<h2>Class Method: EventEmitter.listenerCount(emitter, event)</h2>
<p>Return the number of listeners for a given event.


</p>
<!--next-->
<h2>Event: &#39;newListener&#39;</h2>
<div class="signature"><ul>
<li><code class="language-javascript">event</code> <span class="type">String</span> The event name</li>
<li><code class="language-javascript">listener</code> <span class="type">Function</span> The event handler function</li>
</div></ul>
<p>This event is emitted any time a listener is added. When this event is triggered,
the listener may not yet have been added to the array of listeners for the <code class="language-javascript">event</code>.


</p>
<!--next-->
<h2>Event: &#39;removeListener&#39;</h2>
<div class="signature"><ul>
<li><code class="language-javascript">event</code> <span class="type">String</span> The event name</li>
<li><code class="language-javascript">listener</code> <span class="type">Function</span> The event handler function</li>
</div></ul>
<p>This event is emitted any time someone removes a listener.  When this event is triggered,
the listener may not yet have been removed from the array of listeners for the <code class="language-javascript">event</code>.

</p>
<!--next-->
<h2>Domain</h2>
<pre class="stability">Stability: 2 - Unstable</pre><p>Domains provide a way to handle multiple different IO operations as a
single group.  If any of the event emitters or callbacks registered to a
domain emit an <code class="language-javascript">error</code> event, or throw an error, then the domain object
will be notified, rather than losing the context of the error in the
<code class="language-javascript">process.on(&#39;uncaughtException&#39;)</code> handler, or causing the program to
exit immediately with an error code.

</p>
<!--next-->
<h2>Warning: Don&#39;t Ignore Errors!</h2>
<!-- type=misc -->

<p>Domain error handlers are not a substitute for closing down your
process when an error occurs.

</p>
<p>By the very nature of how <code class="language-javascript">throw</code> works in JavaScript, there is almost
never any way to safely &quot;pick up where you left off&quot;, without leaking
references, or creating some other sort of undefined brittle state.

</p>
<p>The safest way to respond to a thrown error is to shut down the
process.  Of course, in a normal web server, you might have many
connections open, and it is not reasonable to abruptly shut those down
because an error was triggered by someone else.

</p>
<p>The better approach is send an error response to the request that
triggered the error, while letting the others finish in their normal
time, and stop listening for new requests in that worker.

</p>
<p>In this way, <code class="language-javascript">domain</code> usage goes hand-in-hand with the cluster module,
since the master process can fork a new worker when a worker
encounters an error.  For node programs that scale to multiple
machines, the terminating proxy or service registry can take note of
the failure, and react accordingly.

</p>
<p>For example, this is not a good idea:

</p>
<pre><code class="javascript">// XXX WARNING!  BAD IDEA!

var d = require(&#39;domain&#39;).create();
d.on(&#39;error&#39;, function(er) {
  // The error won&#39;t crash the process, but what it does is worse!
  // Though we&#39;ve prevented abrupt process restarting, we are leaking
  // resources like crazy if this ever happens.
  // This is no better than process.on(&#39;uncaughtException&#39;)!
  console.log(&#39;error, but oh well&#39;, er.message);
});
d.run(function() {
  require(&#39;http&#39;).createServer(function(req, res) {
    handleRequest(req, res);
  }).listen(PORT);
});</code></pre>
<p>By using the context of a domain, and the resilience of separating our
program into multiple worker processes, we can react more
appropriately, and handle errors with much greater safety.

</p>
<pre><code class="javascript">// Much better!

var cluster = require(&#39;cluster&#39;);
var PORT = +process.env.PORT || 1337;

if (cluster.isMaster) {
  // In real life, you&#39;d probably use more than just 2 workers,
  // and perhaps not put the master and worker in the same file.
  //
  // You can also of course get a bit fancier about logging, and
  // implement whatever custom logic you need to prevent DoS
  // attacks and other bad behavior.
  //
  // See the options in the cluster documentation.
  //
  // The important thing is that the master does very little,
  // increasing our resilience to unexpected errors.

  cluster.fork();
  cluster.fork();

  cluster.on(&#39;disconnect&#39;, function(worker) {
    console.error(&#39;disconnect!&#39;);
    cluster.fork();
  });

} else {
  // the worker
  //
  // This is where we put our bugs!

  var domain = require(&#39;domain&#39;);

  // See the cluster documentation for more details about using
  // worker processes to serve requests.  How it works, caveats, etc.

  var server = require(&#39;http&#39;).createServer(function(req, res) {
    var d = domain.create();
    d.on(&#39;error&#39;, function(er) {
      console.error(&#39;error&#39;, er.stack);

      // Note: we&#39;re in dangerous territory!
      // By definition, something unexpected occurred,
      // which we probably didn&#39;t want.
      // Anything can happen now!  Be very careful!

      try {
        // make sure we close down within 30 seconds
        var killtimer = setTimeout(function() {
          process.exit(1);
        }, 30000);
        // But don&#39;t keep the process open just for that!
        killtimer.unref();

        // stop taking new requests.
        server.close();

        // Let the master know we&#39;re dead.  This will trigger a
        // &#39;disconnect&#39; in the cluster master, and then it will fork
        // a new worker.
        cluster.worker.disconnect();

        // try to send an error to the request that triggered the problem
        res.statusCode = 500;
        res.setHeader(&#39;content-type&#39;, &#39;text/plain&#39;);
        res.end(&#39;Oops, there was a problem!\n&#39;);
      } catch (er2) {
        // oh well, not much we can do at this point.
        console.error(&#39;Error sending 500!&#39;, er2.stack);
      }
    });

    // Because req and res were created before this domain existed,
    // we need to explicitly add them.
    // See the explanation of implicit vs explicit binding below.
    d.add(req);
    d.add(res);

    // Now run the handler function in the domain.
    d.run(function() {
      handleRequest(req, res);
    });
  });
  server.listen(PORT);
}

// This part isn&#39;t important.  Just an example routing thing.
// You&#39;d put your fancy application logic here.
function handleRequest(req, res) {
  switch(req.url) {
    case &#39;/error&#39;:
      // We do some async stuff, and then...
      setTimeout(function() {
        // Whoops!
        flerb.bark();
      });
      break;
    default:
      res.end(&#39;ok&#39;);
  }
}</code></pre>
<!--next-->
<h2>Additions to Error objects</h2>
<!-- type=misc -->

<p>Any time an Error object is routed through a domain, a few extra fields
are added to it.

</p>
<ul>
<li><code class="language-javascript">error.domain</code> The domain that first handled the error.</li>
<li><code class="language-javascript">error.domainEmitter</code> The event emitter that emitted an &#39;error&#39; event
with the error object.</li>
<li><code class="language-javascript">error.domainBound</code> The callback function which was bound to the
domain, and passed an error as its first argument.</li>
<li><code class="language-javascript">error.domainThrown</code> A boolean indicating whether the error was
thrown, emitted, or passed to a bound callback function.</li>
</ul>
<!--next-->
<h2>Implicit Binding</h2>
<p>If domains are in use, then all <strong>new</strong> EventEmitter objects (including
Stream objects, requests, responses, etc.) will be implicitly bound to
the active domain at the time of their creation.

</p>
<p>Additionally, callbacks passed to lowlevel event loop requests (such as
to fs.open, or other callback-taking methods) will automatically be
bound to the active domain.  If they throw, then the domain will catch
the error.

</p>
<p>In order to prevent excessive memory usage, Domain objects themselves
are not implicitly added as children of the active domain.  If they
were, then it would be too easy to prevent request and response objects
from being properly garbage collected.

</p>
<p>If you <em>want</em> to nest Domain objects as children of a parent Domain,
then you must explicitly add them.

</p>
<p>Implicit binding routes thrown errors and <code class="language-javascript">&#39;error&#39;</code> events to the
Domain&#39;s <code class="language-javascript">error</code> event, but does not register the EventEmitter on the
Domain, so <code class="language-javascript">domain.dispose()</code> will not shut down the EventEmitter.
Implicit binding only takes care of thrown errors and <code class="language-javascript">&#39;error&#39;</code> events.

</p>
<!--next-->
<h2>Explicit Binding</h2>
<p>Sometimes, the domain in use is not the one that ought to be used for a
specific event emitter.  Or, the event emitter could have been created
in the context of one domain, but ought to instead be bound to some
other domain.

</p>
<p>For example, there could be one domain in use for an HTTP server, but
perhaps we would like to have a separate domain to use for each request.

</p>
<p>That is possible via explicit binding.

</p>
<p>For example:

</p>
<pre><code class="language-javascript">// create a top-level domain for the server
var serverDomain = domain.create();

serverDomain.run(function() {
  // server is created in the scope of serverDomain
  http.createServer(function(req, res) {
    // req and res are also created in the scope of serverDomain
    // however, we&#39;d prefer to have a separate domain for each request.
    // create it first thing, and add req and res to it.
    var reqd = domain.create();
    reqd.add(req);
    reqd.add(res);
    reqd.on(&#39;error&#39;, function(er) {
      console.error(&#39;Error&#39;, er, req.url);
      try {
        res.writeHead(500);
        res.end(&#39;Error occurred, sorry.&#39;);
      } catch (er) {
        console.error(&#39;Error sending 500&#39;, er, req.url);
      }
    });
  }).listen(1337);
});</code></pre>
<!--next-->
<h2>domain.create()</h2>
<div class="signature"><ul>
<li>return: <span class="type">Domain</span></li>
</div></ul>
<p>Returns a new Domain object.

</p>
<!--next-->
<h2>Class: Domain</h2>
<p>The Domain class encapsulates the functionality of routing errors and
uncaught exceptions to the active Domain object.

</p>
<p>Domain is a child class of <a>EventEmitter</a>.  To handle the errors that it
catches, listen to its <code class="language-javascript">error</code> event.

</p>
<!--next-->
<h2>domain.run(fn)</h2>
<div class="signature"><ul>
<li><code class="language-javascript">fn</code> <span class="type">Function</span></li>
</div></ul>
<p>Run the supplied function in the context of the domain, implicitly
binding all event emitters, timers, and lowlevel requests that are
created in that context.

</p>
<p>This is the most basic way to use a domain.

</p>
<p>Example:

</p>
<pre><code class="language-javascript">var d = domain.create();
d.on(&#39;error&#39;, function(er) {
  console.error(&#39;Caught error!&#39;, er);
});
d.run(function() {
  process.nextTick(function() {
    setTimeout(function() { // simulating some various async stuff
      fs.open(&#39;non-existent file&#39;, &#39;r&#39;, function(er, fd) {
        if (er) throw er;
        // proceed...
      });
    }, 100);
  });
});</code></pre>
<p>In this example, the <code class="language-javascript">d.on(&#39;error&#39;)</code> handler will be triggered, rather
than crashing the program.

</p>
<!--next-->
<h2>domain.members</h2>
<div class="signature"><ul>
<li><span class="type">Array</span></li>
</div></ul>
<p>An array of timers and event emitters that have been explicitly added
to the domain.

</p>
<!--next-->
<h2>domain.add(emitter)</h2>
<div class="signature"><ul>
<li><code class="language-javascript">emitter</code> <span class="type">EventEmitter | Timer</span> emitter or timer to be added to the domain</li>
</div></ul>
<p>Explicitly adds an emitter to the domain.  If any event handlers called by
the emitter throw an error, or if the emitter emits an <code class="language-javascript">error</code> event, it
will be routed to the domain&#39;s <code class="language-javascript">error</code> event, just like with implicit
binding.

</p>
<p>This also works with timers that are returned from <code class="language-javascript">setInterval</code> and
<code class="language-javascript">setTimeout</code>.  If their callback function throws, it will be caught by
the domain &#39;error&#39; handler.

</p>
<p>If the Timer or EventEmitter was already bound to a domain, it is removed
from that one, and bound to this one instead.

</p>
<!--next-->
<h2>domain.remove(emitter)</h2>
<div class="signature"><ul>
<li><code class="language-javascript">emitter</code> <span class="type">EventEmitter | Timer</span> emitter or timer to be removed from the domain</li>
</div></ul>
<p>The opposite of <code class="language-javascript">domain.add(emitter)</code>.  Removes domain handling from the
specified emitter.

</p>
<!--next-->
<h2>domain.bind(callback)</h2>
<div class="signature"><ul>
<li><code class="language-javascript">callback</code> <span class="type">Function</span> The callback function</li>
<li>return: <span class="type">Function</span> The bound function</li>
</div></ul>
<p>The returned function will be a wrapper around the supplied callback
function.  When the returned function is called, any errors that are
thrown will be routed to the domain&#39;s <code class="language-javascript">error</code> event.

</p>
<h4>Example</h4>
<pre><code class="language-javascript">var d = domain.create();

function readSomeFile(filename, cb) {
  fs.readFile(filename, &#39;utf8&#39;, d.bind(function(er, data) {
    // if this throws, it will also be passed to the domain
    return cb(er, data ? JSON.parse(data) : null);
  }));
}

d.on(&#39;error&#39;, function(er) {
  // an error occurred somewhere.
  // if we throw it now, it will crash the program
  // with the normal line number and stack message.
});</code></pre>
<!--next-->
<h2>domain.intercept(callback)</h2>
<div class="signature"><ul>
<li><code class="language-javascript">callback</code> <span class="type">Function</span> The callback function</li>
<li>return: <span class="type">Function</span> The intercepted function</li>
</div></ul>
<p>This method is almost identical to <code class="language-javascript">domain.bind(callback)</code>.  However, in
addition to catching thrown errors, it will also intercept <code class="language-javascript">Error</code>
objects sent as the first argument to the function.

</p>
<p>In this way, the common <code class="language-javascript">if (er) return callback(er);</code> pattern can be replaced
with a single error handler in a single place.

</p>
<h4>Example</h4>
<pre><code class="language-javascript">var d = domain.create();

function readSomeFile(filename, cb) {
  fs.readFile(filename, &#39;utf8&#39;, d.intercept(function(data) {
    // note, the first argument is never passed to the
    // callback since it is assumed to be the &#39;Error&#39; argument
    // and thus intercepted by the domain.

    // if this throws, it will also be passed to the domain
    // so the error-handling logic can be moved to the &#39;error&#39;
    // event on the domain instead of being repeated throughout
    // the program.
    return cb(null, JSON.parse(data));
  }));
}

d.on(&#39;error&#39;, function(er) {
  // an error occurred somewhere.
  // if we throw it now, it will crash the program
  // with the normal line number and stack message.
});</code></pre>
<!--next-->
<h2>domain.enter()</h2>
<p>The <code class="language-javascript">enter</code> method is plumbing used by the <code class="language-javascript">run</code>, <code class="language-javascript">bind</code>, and <code class="language-javascript">intercept</code>
methods to set the active domain. It sets <code class="language-javascript">domain.active</code> and <code class="language-javascript">process.domain</code>
to the domain, and implicitly pushes the domain onto the domain stack managed
by the domain module (see <code class="language-javascript">domain.exit()</code> for details on the domain stack). The
call to <code class="language-javascript">enter</code> delimits the beginning of a chain of asynchronous calls and I/O
operations bound to a domain.

</p>
<p>Calling <code class="language-javascript">enter</code> changes only the active domain, and does not alter the domain
itself. <code class="language-javascript">Enter</code> and <code class="language-javascript">exit</code> can be called an arbitrary number of times on a
single domain.

</p>
<p>If the domain on which <code class="language-javascript">enter</code> is called has been disposed, <code class="language-javascript">enter</code> will return
without setting the domain.

</p>
<!--next-->
<h2>domain.exit()</h2>
<p>The <code class="language-javascript">exit</code> method exits the current domain, popping it off the domain stack.
Any time execution is going to switch to the context of a different chain of
asynchronous calls, it&#39;s important to ensure that the current domain is exited.
The call to <code class="language-javascript">exit</code> delimits either the end of or an interruption to the chain
of asynchronous calls and I/O operations bound to a domain.

</p>
<p>If there are multiple, nested domains bound to the current execution context,
<code class="language-javascript">exit</code> will exit any domains nested within this domain.

</p>
<p>Calling <code class="language-javascript">exit</code> changes only the active domain, and does not alter the domain
itself. <code class="language-javascript">Enter</code> and <code class="language-javascript">exit</code> can be called an arbitrary number of times on a
single domain.

</p>
<p>If the domain on which <code class="language-javascript">exit</code> is called has been disposed, <code class="language-javascript">exit</code> will return
without exiting the domain.

</p>
<!--next-->
<h2>domain.dispose()</h2>
<pre class="stability">Stability: 0 - Deprecated.  Please recover from failed IO actions
explicitly via error event handlers set on the domain.</pre><p>Once <code class="language-javascript">dispose</code> has been called, the domain will no longer be used by callbacks
bound into the domain via <code class="language-javascript">run</code>, <code class="language-javascript">bind</code>, or <code class="language-javascript">intercept</code>, and a <code class="language-javascript">dispose</code> event
is emitted.

</p>
<!--next-->
<h2>Buffer</h2>
<pre class="stability">Stability: 3 - Stable</pre><p>Pure JavaScript is Unicode friendly but not nice to binary data.  When
dealing with TCP streams or the file system, it&#39;s necessary to handle octet
streams. Node has several strategies for manipulating, creating, and
consuming octet streams.

</p>
<p>Raw data is stored in instances of the <code class="language-javascript">Buffer</code> class. A <code class="language-javascript">Buffer</code> is similar
to an array of integers but corresponds to a raw memory allocation outside
the V8 heap. A <code class="language-javascript">Buffer</code> cannot be resized.

</p>
<p>The <code class="language-javascript">Buffer</code> class is a global, making it very rare that one would need
to ever <code class="language-javascript">require(&#39;buffer&#39;)</code>.

</p>
<p>Converting between Buffers and JavaScript string objects requires an explicit
encoding method.  Here are the different string encodings.

</p>
<ul>
<li><p><code class="language-javascript">&#39;ascii&#39;</code> - for 7 bit ASCII data only.  This encoding method is very fast, and
will strip the high bit if set.</p>
</li>
<li><p><code class="language-javascript">&#39;utf8&#39;</code> - Multibyte encoded Unicode characters. Many web pages and other
document formats use UTF-8.</p>
</li>
<li><p><code class="language-javascript">&#39;utf16le&#39;</code> - 2 or 4 bytes, little endian encoded Unicode characters.
Surrogate pairs (U+10000 to U+10FFFF) are supported.</p>
</li>
<li><p><code class="language-javascript">&#39;ucs2&#39;</code> - Alias of <code class="language-javascript">&#39;utf16le&#39;</code>.</p>
</li>
<li><p><code class="language-javascript">&#39;base64&#39;</code> - Base64 string encoding.</p>
</li>
<li><p><code class="language-javascript">&#39;binary&#39;</code> - A way of encoding raw binary data into strings by using only
the first 8 bits of each character. This encoding method is deprecated and
should be avoided in favor of <code class="language-javascript">Buffer</code> objects where possible. This encoding
will be removed in future versions of Node.</p>
</li>
<li><p><code class="language-javascript">&#39;hex&#39;</code> - Encode each byte as two hexadecimal characters.</p>
</li>
</ul>
<p>Creating a typed array from a <code class="language-javascript">Buffer</code> works with the following caveats:

</p>
<ol>
<li><p>The buffer&#39;s memory is copied, not shared.</p>
</li>
<li><p>The buffer&#39;s memory is interpreted as an array, not a byte array.  That is,
<code class="language-javascript">new Uint32Array(new Buffer([1,2,3,4]))</code> creates a 4-element <code class="language-javascript">Uint32Array</code>
with elements <code class="language-javascript">[1,2,3,4]</code>, not an <code class="language-javascript">Uint32Array</code> with a single element
<code class="language-javascript">[0x1020304]</code> or <code class="language-javascript">[0x4030201]</code>.</p>
</li>
</ol>
<p>NOTE: Node.js v0.8 simply retained a reference to the buffer in <code class="language-javascript">array.buffer</code>
instead of cloning it.

</p>
<p>While more efficient, it introduces subtle incompatibilities with the typed
arrays specification.  <code class="language-javascript">ArrayBuffer#slice()</code> makes a copy of the slice while
<code class="language-javascript">Buffer#slice()</code> creates a view.

</p>
<!--next-->
<h2>Class: Buffer</h2>
<p>The Buffer class is a global type for dealing with binary data directly.
It can be constructed in a variety of ways.

</p>
<!--next-->
<h2>new Buffer(size)</h2>
<div class="signature"><ul>
<li><code class="language-javascript">size</code> Number</li>
</div></ul>
<p>Allocates a new buffer of <code class="language-javascript">size</code> octets. Note, <code class="language-javascript">size</code> must be no more than
<a>kMaxLength</a>. Otherwise, a <code class="language-javascript">RangeError</code>
will be thrown here.

</p>
<!--next-->
<h2>new Buffer(array)</h2>
<div class="signature"><ul>
<li><code class="language-javascript">array</code> Array</li>
</div></ul>
<p>Allocates a new buffer using an <code class="language-javascript">array</code> of octets.

</p>
<!--next-->
<h2>new Buffer(buffer)</h2>
<div class="signature"><ul>
<li><code class="language-javascript">buffer</code> <span class="type">Buffer</span></li>
</div></ul>
<p>Copies the passed <code class="language-javascript">buffer</code> data onto a new <code class="language-javascript">Buffer</code> instance.

</p>
<!--next-->
<h2>new Buffer(str[, encoding])</h2>
<div class="signature"><ul>
<li><code class="language-javascript">str</code> String - string to encode.</li>
<li><code class="language-javascript">encoding</code> String - encoding to use, Optional.</li>
</div></ul>
<p>Allocates a new buffer containing the given <code class="language-javascript">str</code>.
<code class="language-javascript">encoding</code> defaults to <code class="language-javascript">&#39;utf8&#39;</code>.

</p>
<!--next-->
<h2>Class Method: Buffer.isEncoding(encoding)</h2>
<div class="signature"><ul>
<li><code class="language-javascript">encoding</code> <span class="type">String</span> The encoding string to test</li>
</div></ul>
<p>Returns true if the <code class="language-javascript">encoding</code> is a valid encoding argument, or false
otherwise.

</p>
<!--next-->
<h2>Class Method: Buffer.isBuffer(obj)</h2>
<div class="signature"><ul>
<li><code class="language-javascript">obj</code> Object</li>
<li>Return: Boolean</li>
</div></ul>
<p>Tests if <code class="language-javascript">obj</code> is a <code class="language-javascript">Buffer</code>.

</p>
<!--next-->
<h2>Class Method: Buffer.byteLength(string[, encoding])</h2>
<div class="signature"><ul>
<li><code class="language-javascript">string</code> String</li>
<li><code class="language-javascript">encoding</code> String, Optional, Default: &#39;utf8&#39;</li>
<li>Return: Number</li>
</div></ul>
<p>Gives the actual byte length of a string. <code class="language-javascript">encoding</code> defaults to <code class="language-javascript">&#39;utf8&#39;</code>.
This is not the same as <code class="language-javascript">String.prototype.length</code> since that returns the
number of <em>characters</em> in a string.

</p>
<p>Example:

</p>
<pre><code class="language-javascript">str = &#39;\u00bd + \u00bc = \u00be&#39;;

console.log(str + &quot;: &quot; + str.length + &quot; characters, &quot; +
  Buffer.byteLength(str, &#39;utf8&#39;) + &quot; bytes&quot;);

//  +  = : 9 characters, 12 bytes</code></pre>
<!--next-->
<h2>Class Method: Buffer.concat(list[, totalLength])</h2>
<div class="signature"><ul>
<li><code class="language-javascript">list</code> <span class="type">Array</span> List of Buffer objects to concat</li>
<li><code class="language-javascript">totalLength</code> <span class="type">Number</span> Total length of the buffers when concatenated</li>
</div></ul>
<p>Returns a buffer which is the result of concatenating all the buffers in
the list together.

</p>
<p>If the list has no items, or if the totalLength is 0, then it returns a
zero-length buffer.

</p>
<p>If the list has exactly one item, then the first item of the list is
returned.

</p>
<p>If the list has more than one item, then a new Buffer is created.

</p>
<p>If totalLength is not provided, it is read from the buffers in the list.
However, this adds an additional loop to the function, so it is faster
to provide the length explicitly.

</p>
<!--next-->
<h2>Class Method: Buffer.compare(buf1, buf2)</h2>
<div class="signature"><ul>
<li><code class="language-javascript">buf1</code> <span class="type">Buffer</span></li>
<li><code class="language-javascript">buf2</code> <span class="type">Buffer</span></li>
</div></ul>
<p>The same as <a><code class="language-javascript">buf1.compare(buf2)</code></a>. Useful
for sorting an Array of Buffers:

</p>
<pre><code class="language-javascript">var arr = [Buffer(&#39;1234&#39;), Buffer(&#39;0123&#39;)];
arr.sort(Buffer.compare);</code></pre>
<!--next-->
<h2>buf.length</h2>
<div class="signature"><ul>
<li>Number</li>
</div></ul>
<p>The size of the buffer in bytes.  Note that this is not necessarily the size
of the contents. <code class="language-javascript">length</code> refers to the amount of memory allocated for the
buffer object.  It does not change when the contents of the buffer are changed.

</p>
<pre><code class="language-javascript">buf = new Buffer(1234);

console.log(buf.length);
buf.write(&quot;some string&quot;, 0, &quot;ascii&quot;);
console.log(buf.length);

// 1234
// 1234</code></pre>
<p>While the <code class="language-javascript">length</code> property is not immutable, changing the value of <code class="language-javascript">length</code>
can result in undefined and inconsistent behavior. Applications that wish to
modify the length of a buffer should therefore treat <code class="language-javascript">length</code> as read-only and
use <code class="language-javascript">buf.slice</code> to create a new buffer.

</p>
<pre><code class="language-javascript">buf = new Buffer(10);
buf.write(&quot;abcdefghj&quot;, 0, &quot;ascii&quot;);
console.log(buf.length); // 10
buf = buf.slice(0,5);
console.log(buf.length); // 5</code></pre>
<!--next-->
<h2>buf.write(string[, offset][, length][, encoding])</h2>
<div class="signature"><ul>
<li><code class="language-javascript">string</code> String - data to be written to buffer</li>
<li><code class="language-javascript">offset</code> Number, Optional, Default: 0</li>
<li><code class="language-javascript">length</code> Number, Optional, Default: <code class="language-javascript">buffer.length - offset</code></li>
<li><code class="language-javascript">encoding</code> String, Optional, Default: &#39;utf8&#39;</li>
</div></ul>
<p>Writes <code class="language-javascript">string</code> to the buffer at <code class="language-javascript">offset</code> using the given encoding.
<code class="language-javascript">offset</code> defaults to <code class="language-javascript">0</code>, <code class="language-javascript">encoding</code> defaults to <code class="language-javascript">&#39;utf8&#39;</code>. <code class="language-javascript">length</code> is
the number of bytes to write. Returns number of octets written. If <code class="language-javascript">buffer</code> did
not contain enough space to fit the entire string, it will write a partial
amount of the string. <code class="language-javascript">length</code> defaults to <code class="language-javascript">buffer.length - offset</code>.
The method will not write partial characters.

</p>
<pre><code class="language-javascript">buf = new Buffer(256);
len = buf.write(&#39;\u00bd + \u00bc = \u00be&#39;, 0);
console.log(len + &quot; bytes: &quot; + buf.toString(&#39;utf8&#39;, 0, len));</code></pre>
<!--next-->
<h2>buf.writeUIntLE(value, offset, byteLength[, noAssert])</h2>
<!--next-->
<h2>buf.writeUIntBE(value, offset, byteLength[, noAssert])</h2>
<!--next-->
<h2>buf.writeIntLE(value, offset, byteLength[, noAssert])</h2>
<!--next-->
<h2>buf.writeIntBE(value, offset, byteLength[, noAssert])</h2>
<ul>
<li><code class="language-javascript">value</code> {Number} Bytes to be written to buffer</li>
<li><code class="language-javascript">offset</code> {Number} <code class="language-javascript">0 &lt;= offset &lt;= buf.length</code></li>
<li><code class="language-javascript">byteLength</code> {Number} <code class="language-javascript">0 &lt; byteLength &lt;= 6</code></li>
<li><code class="language-javascript">noAssert</code> {Boolean} Default: false</li>
<li>Return: {Number}</li>
</ul>
<p>Writes <code class="language-javascript">value</code> to the buffer at the specified <code class="language-javascript">offset</code> and <code class="language-javascript">byteLength</code>.
Supports up to 48 bits of accuracy. For example:

</p>
<pre><code class="language-javascript">var b = new Buffer(6);
b.writeUIntBE(0x1234567890ab, 0, 6);
// &lt;Buffer 12 34 56 78 90 ab&gt;</code></pre>
<p>Set <code class="language-javascript">noAssert</code> to <code class="language-javascript">true</code> to skip validation of <code class="language-javascript">value</code> and <code class="language-javascript">offset</code>. Defaults
to <code class="language-javascript">false</code>.

</p>
<!--next-->
<h2>buf.readUIntLE(offset, byteLength[, noAssert])</h2>
<!--next-->
<h2>buf.readUIntBE(offset, byteLength[, noAssert])</h2>
<!--next-->
<h2>buf.readIntLE(offset, byteLength[, noAssert])</h2>
<!--next-->
<h2>buf.readIntBE(offset, byteLength[, noAssert])</h2>
<ul>
<li><code class="language-javascript">offset</code> {Number} <code class="language-javascript">0 &lt;= offset &lt;= buf.length</code></li>
<li><code class="language-javascript">byteLength</code> {Number} <code class="language-javascript">0 &lt; byteLength &lt;= 6</code></li>
<li><code class="language-javascript">noAssert</code> {Boolean} Default: false</li>
<li>Return: {Number}</li>
</ul>
<p>A generalized version of all numeric read methods. Supports up to 48 bits of
accuracy. For example:

</p>
<pre><code class="language-javascript">var b = new Buffer(6);
b.writeUint16LE(0x90ab, 0);
b.writeUInt32LE(0x12345678, 2);
b.readUIntLE(0, 6).toString(16);  // Specify 6 bytes (48 bits)
// output: &#39;1234567890ab&#39;</code></pre>
<p>Set <code class="language-javascript">noAssert</code> to true to skip validation of <code class="language-javascript">offset</code>. This means that <code class="language-javascript">offset</code>
may be beyond the end of the buffer. Defaults to <code class="language-javascript">false</code>.

</p>
<!--next-->
<h2>buf.toString([encoding][, start][, end])</h2>
<div class="signature"><ul>
<li><code class="language-javascript">encoding</code> String, Optional, Default: &#39;utf8&#39;</li>
<li><code class="language-javascript">start</code> Number, Optional, Default: 0</li>
<li><code class="language-javascript">end</code> Number, Optional, Default: <code class="language-javascript">buffer.length</code></li>
</div></ul>
<p>Decodes and returns a string from buffer data encoded using the specified
character set encoding. If <code class="language-javascript">encoding</code> is <code class="language-javascript">undefined</code> or <code class="language-javascript">null</code>, then <code class="language-javascript">encoding</code>
defaults to <code class="language-javascript">&#39;utf8&#39;. The </code>start<code class="language-javascript"> and </code>end<code class="language-javascript"> parameters default to </code>0<code class="language-javascript"> and
</code>buffer.length<code class="language-javascript"> when </code>undefined`.

</p>
<pre><code class="language-javascript">buf = new Buffer(26);
for (var i = 0 ; i &lt; 26 ; i++) {
  buf[i] = i + 97; // 97 is ASCII a
}
buf.toString(&#39;ascii&#39;); // outputs: abcdefghijklmnopqrstuvwxyz
buf.toString(&#39;ascii&#39;,0,5); // outputs: abcde
buf.toString(&#39;utf8&#39;,0,5); // outputs: abcde
buf.toString(undefined,0,5); // encoding defaults to &#39;utf8&#39;, outputs abcde</code></pre>
<p>See <code class="language-javascript">buffer.write()</code> example, above.


</p>
<!--next-->
<h2>buf.toJSON()</h2>
<p>Returns a JSON-representation of the Buffer instance.  <code class="language-javascript">JSON.stringify</code>
implicitly calls this function when stringifying a Buffer instance.

</p>
<p>Example:

</p>
<pre><code class="language-javascript">var buf = new Buffer(&#39;test&#39;);
var json = JSON.stringify(buf);

console.log(json);
// &#39;{&quot;type&quot;:&quot;Buffer&quot;,&quot;data&quot;:[116,101,115,116]}&#39;

var copy = JSON.parse(json, function(key, value) {
    return value &amp;&amp; value.type === &#39;Buffer&#39;
      ? new Buffer(value.data)
      : value;
  });

console.log(copy);
// &lt;Buffer 74 65 73 74&gt;</code></pre>
<!--next-->
<h2>buf[index]</h2>
<!--type=property-->


<p>Get and set the octet at <code class="language-javascript">index</code>. The values refer to individual bytes,
so the legal range is between <code class="language-javascript">0x00</code> and <code class="language-javascript">0xFF</code> hex or <code class="language-javascript">0</code> and <code class="language-javascript">255</code>.

</p>
<p>Example: copy an ASCII string into a buffer, one byte at a time:

</p>
<pre><code class="language-javascript">str = &quot;node.js&quot;;
buf = new Buffer(str.length);

for (var i = 0; i &lt; str.length ; i++) {
  buf[i] = str.charCodeAt(i);
}

console.log(buf);

// node.js</code></pre>
<!--next-->
<h2>buf.equals(otherBuffer)</h2>
<div class="signature"><ul>
<li><code class="language-javascript">otherBuffer</code> <span class="type">Buffer</span></li>
</div></ul>
<p>Returns a boolean of whether <code class="language-javascript">this</code> and <code class="language-javascript">otherBuffer</code> have the same
bytes.

</p>
<!--next-->
<h2>buf.compare(otherBuffer)</h2>
<div class="signature"><ul>
<li><code class="language-javascript">otherBuffer</code> <span class="type">Buffer</span></li>
</div></ul>
<p>Returns a number indicating whether <code class="language-javascript">this</code> comes before or after or is
the same as the <code class="language-javascript">otherBuffer</code> in sort order.

</p>
<!--next-->
<h2>buf.copy(targetBuffer[, targetStart][, sourceStart][, sourceEnd])</h2>
<div class="signature"><ul>
<li><code class="language-javascript">targetBuffer</code> Buffer object - Buffer to copy into</li>
<li><code class="language-javascript">targetStart</code> Number, Optional, Default: 0</li>
<li><code class="language-javascript">sourceStart</code> Number, Optional, Default: 0</li>
<li><code class="language-javascript">sourceEnd</code> Number, Optional, Default: <code class="language-javascript">buffer.length</code></li>
</div></ul>
<p>Copies data from a region of this buffer to a region in the target buffer even
if the target memory region overlaps with the source. If <code class="language-javascript">undefined</code> the
<code class="language-javascript">targetStart</code> and <code class="language-javascript">sourceStart</code> parameters default to <code class="language-javascript">0</code> while <code class="language-javascript">sourceEnd</code>
defaults to <code class="language-javascript">buffer.length</code>.

</p>
<p>Example: build two Buffers, then copy <code class="language-javascript">buf1</code> from byte 16 through byte 19
into <code class="language-javascript">buf2</code>, starting at the 8th byte in <code class="language-javascript">buf2</code>.

</p>
<pre><code class="language-javascript">buf1 = new Buffer(26);
buf2 = new Buffer(26);

for (var i = 0 ; i &lt; 26 ; i++) {
  buf1[i] = i + 97; // 97 is ASCII a
  buf2[i] = 33; // ASCII !
}

buf1.copy(buf2, 8, 16, 20);
console.log(buf2.toString(&#39;ascii&#39;, 0, 25));

// !!!!!!!!qrst!!!!!!!!!!!!!</code></pre>
<p>Example: Build a single buffer, then copy data from one region to an overlapping
region in the same buffer

</p>
<pre><code class="language-javascript">buf = new Buffer(26);

for (var i = 0 ; i &lt; 26 ; i++) {
  buf[i] = i + 97; // 97 is ASCII a
}

buf.copy(buf, 0, 4, 10);
console.log(buf.toString());

// efghijghijklmnopqrstuvwxyz</code></pre>
<!--next-->
<h2>buf.slice([start][, end])</h2>
<div class="signature"><ul>
<li><code class="language-javascript">start</code> Number, Optional, Default: 0</li>
<li><code class="language-javascript">end</code> Number, Optional, Default: <code class="language-javascript">buffer.length</code></li>
</div></ul>
<p>Returns a new buffer which references the same memory as the old, but offset
and cropped by the <code class="language-javascript">start</code> (defaults to <code class="language-javascript">0</code>) and <code class="language-javascript">end</code> (defaults to
<code class="language-javascript">buffer.length</code>) indexes.  Negative indexes start from the end of the buffer.

</p>
<p><strong>Modifying the new buffer slice will modify memory in the original buffer!</strong>

</p>
<p>Example: build a Buffer with the ASCII alphabet, take a slice, then modify one
byte from the original Buffer.

</p>
<pre><code class="language-javascript">var buf1 = new Buffer(26);

for (var i = 0 ; i &lt; 26 ; i++) {
  buf1[i] = i + 97; // 97 is ASCII a
}

var buf2 = buf1.slice(0, 3);
console.log(buf2.toString(&#39;ascii&#39;, 0, buf2.length));
buf1[0] = 33;
console.log(buf2.toString(&#39;ascii&#39;, 0, buf2.length));

// abc
// !bc</code></pre>
<!--next-->
<h2>buf.readUInt8(offset[, noAssert])</h2>
<div class="signature"><ul>
<li><code class="language-javascript">offset</code> Number</li>
<li><code class="language-javascript">noAssert</code> Boolean, Optional, Default: false</li>
<li>Return: Number</li>
</div></ul>
<p>Reads an unsigned 8 bit integer from the buffer at the specified offset.

</p>
<p>Set <code class="language-javascript">noAssert</code> to true to skip validation of <code class="language-javascript">offset</code>. This means that <code class="language-javascript">offset</code>
may be beyond the end of the buffer. Defaults to <code class="language-javascript">false</code>.

</p>
<p>Example:

</p>
<pre><code class="language-javascript">var buf = new Buffer(4);

buf[0] = 0x3;
buf[1] = 0x4;
buf[2] = 0x23;
buf[3] = 0x42;

for (ii = 0; ii &lt; buf.length; ii++) {
  console.log(buf.readUInt8(ii));
}

// 0x3
// 0x4
// 0x23
// 0x42</code></pre>
<!--next-->
<h2>buf.readUInt16LE(offset[, noAssert])</h2>
<!--next-->
<h2>buf.readUInt16BE(offset[, noAssert])</h2>
<ul>
<li><code class="language-javascript">offset</code> Number</li>
<li><code class="language-javascript">noAssert</code> Boolean, Optional, Default: false</li>
<li>Return: Number</li>
</ul>
<p>Reads an unsigned 16 bit integer from the buffer at the specified offset with
specified endian format.

</p>
<p>Set <code class="language-javascript">noAssert</code> to true to skip validation of <code class="language-javascript">offset</code>. This means that <code class="language-javascript">offset</code>
may be beyond the end of the buffer. Defaults to <code class="language-javascript">false</code>.

</p>
<p>Example:

</p>
<pre><code class="language-javascript">var buf = new Buffer(4);

buf[0] = 0x3;
buf[1] = 0x4;
buf[2] = 0x23;
buf[3] = 0x42;

console.log(buf.readUInt16BE(0));
console.log(buf.readUInt16LE(0));
console.log(buf.readUInt16BE(1));
console.log(buf.readUInt16LE(1));
console.log(buf.readUInt16BE(2));
console.log(buf.readUInt16LE(2));

// 0x0304
// 0x0403
// 0x0423
// 0x2304
// 0x2342
// 0x4223</code></pre>
<!--next-->
<h2>buf.readUInt32LE(offset[, noAssert])</h2>
<!--next-->
<h2>buf.readUInt32BE(offset[, noAssert])</h2>
<ul>
<li><code class="language-javascript">offset</code> Number</li>
<li><code class="language-javascript">noAssert</code> Boolean, Optional, Default: false</li>
<li>Return: Number</li>
</ul>
<p>Reads an unsigned 32 bit integer from the buffer at the specified offset with
specified endian format.

</p>
<p>Set <code class="language-javascript">noAssert</code> to true to skip validation of <code class="language-javascript">offset</code>. This means that <code class="language-javascript">offset</code>
may be beyond the end of the buffer. Defaults to <code class="language-javascript">false</code>.

</p>
<p>Example:

</p>
<pre><code class="language-javascript">var buf = new Buffer(4);

buf[0] = 0x3;
buf[1] = 0x4;
buf[2] = 0x23;
buf[3] = 0x42;

console.log(buf.readUInt32BE(0));
console.log(buf.readUInt32LE(0));

// 0x03042342
// 0x42230403</code></pre>
<!--next-->
<h2>buf.readInt8(offset[, noAssert])</h2>
<div class="signature"><ul>
<li><code class="language-javascript">offset</code> Number</li>
<li><code class="language-javascript">noAssert</code> Boolean, Optional, Default: false</li>
<li>Return: Number</li>
</div></ul>
<p>Reads a signed 8 bit integer from the buffer at the specified offset.

</p>
<p>Set <code class="language-javascript">noAssert</code> to true to skip validation of <code class="language-javascript">offset</code>. This means that <code class="language-javascript">offset</code>
may be beyond the end of the buffer. Defaults to <code class="language-javascript">false</code>.

</p>
<p>Works as <code class="language-javascript">buffer.readUInt8</code>, except buffer contents are treated as two&#39;s
complement signed values.

</p>
<!--next-->
<h2>buf.readInt16LE(offset[, noAssert])</h2>
<!--next-->
<h2>buf.readInt16BE(offset[, noAssert])</h2>
<ul>
<li><code class="language-javascript">offset</code> Number</li>
<li><code class="language-javascript">noAssert</code> Boolean, Optional, Default: false</li>
<li>Return: Number</li>
</ul>
<p>Reads a signed 16 bit integer from the buffer at the specified offset with
specified endian format.

</p>
<p>Set <code class="language-javascript">noAssert</code> to true to skip validation of <code class="language-javascript">offset</code>. This means that <code class="language-javascript">offset</code>
may be beyond the end of the buffer. Defaults to <code class="language-javascript">false</code>.

</p>
<p>Works as <code class="language-javascript">buffer.readUInt16*</code>, except buffer contents are treated as two&#39;s
complement signed values.

</p>
<!--next-->
<h2>buf.readInt32LE(offset[, noAssert])</h2>
<!--next-->
<h2>buf.readInt32BE(offset[, noAssert])</h2>
<ul>
<li><code class="language-javascript">offset</code> Number</li>
<li><code class="language-javascript">noAssert</code> Boolean, Optional, Default: false</li>
<li>Return: Number</li>
</ul>
<p>Reads a signed 32 bit integer from the buffer at the specified offset with
specified endian format.

</p>
<p>Set <code class="language-javascript">noAssert</code> to true to skip validation of <code class="language-javascript">offset</code>. This means that <code class="language-javascript">offset</code>
may be beyond the end of the buffer. Defaults to <code class="language-javascript">false</code>.

</p>
<p>Works as <code class="language-javascript">buffer.readUInt32*</code>, except buffer contents are treated as two&#39;s
complement signed values.

</p>
<!--next-->
<h2>buf.readFloatLE(offset[, noAssert])</h2>
<!--next-->
<h2>buf.readFloatBE(offset[, noAssert])</h2>
<ul>
<li><code class="language-javascript">offset</code> Number</li>
<li><code class="language-javascript">noAssert</code> Boolean, Optional, Default: false</li>
<li>Return: Number</li>
</ul>
<p>Reads a 32 bit float from the buffer at the specified offset with specified
endian format.

</p>
<p>Set <code class="language-javascript">noAssert</code> to true to skip validation of <code class="language-javascript">offset</code>. This means that <code class="language-javascript">offset</code>
may be beyond the end of the buffer. Defaults to <code class="language-javascript">false</code>.

</p>
<p>Example:

</p>
<pre><code class="language-javascript">var buf = new Buffer(4);

buf[0] = 0x00;
buf[1] = 0x00;
buf[2] = 0x80;
buf[3] = 0x3f;

console.log(buf.readFloatLE(0));

// 0x01</code></pre>
<!--next-->
<h2>buf.readDoubleLE(offset[, noAssert])</h2>
<!--next-->
<h2>buf.readDoubleBE(offset[, noAssert])</h2>
<ul>
<li><code class="language-javascript">offset</code> Number</li>
<li><code class="language-javascript">noAssert</code> Boolean, Optional, Default: false</li>
<li>Return: Number</li>
</ul>
<p>Reads a 64 bit double from the buffer at the specified offset with specified
endian format.

</p>
<p>Set <code class="language-javascript">noAssert</code> to true to skip validation of <code class="language-javascript">offset</code>. This means that <code class="language-javascript">offset</code>
may be beyond the end of the buffer. Defaults to <code class="language-javascript">false</code>.

</p>
<p>Example:

</p>
<pre><code class="language-javascript">var buf = new Buffer(8);

buf[0] = 0x55;
buf[1] = 0x55;
buf[2] = 0x55;
buf[3] = 0x55;
buf[4] = 0x55;
buf[5] = 0x55;
buf[6] = 0xd5;
buf[7] = 0x3f;

console.log(buf.readDoubleLE(0));

// 0.3333333333333333</code></pre>
<!--next-->
<h2>buf.writeUInt8(value, offset[, noAssert])</h2>
<div class="signature"><ul>
<li><code class="language-javascript">value</code> Number</li>
<li><code class="language-javascript">offset</code> Number</li>
<li><code class="language-javascript">noAssert</code> Boolean, Optional, Default: false</li>
</div></ul>
<p>Writes <code class="language-javascript">value</code> to the buffer at the specified offset. Note, <code class="language-javascript">value</code> must be a
valid unsigned 8 bit integer.

</p>
<p>Set <code class="language-javascript">noAssert</code> to true to skip validation of <code class="language-javascript">value</code> and <code class="language-javascript">offset</code>. This means
that <code class="language-javascript">value</code> may be too large for the specific function and <code class="language-javascript">offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code class="language-javascript">false</code>.

</p>
<p>Example:

</p>
<pre><code class="language-javascript">var buf = new Buffer(4);
buf.writeUInt8(0x3, 0);
buf.writeUInt8(0x4, 1);
buf.writeUInt8(0x23, 2);
buf.writeUInt8(0x42, 3);

console.log(buf);

// &lt;Buffer 03 04 23 42&gt;</code></pre>
<!--next-->
<h2>buf.writeUInt16LE(value, offset[, noAssert])</h2>
<!--next-->
<h2>buf.writeUInt16BE(value, offset[, noAssert])</h2>
<ul>
<li><code class="language-javascript">value</code> Number</li>
<li><code class="language-javascript">offset</code> Number</li>
<li><code class="language-javascript">noAssert</code> Boolean, Optional, Default: false</li>
</ul>
<p>Writes <code class="language-javascript">value</code> to the buffer at the specified offset with specified endian
format. Note, <code class="language-javascript">value</code> must be a valid unsigned 16 bit integer.

</p>
<p>Set <code class="language-javascript">noAssert</code> to true to skip validation of <code class="language-javascript">value</code> and <code class="language-javascript">offset</code>. This means
that <code class="language-javascript">value</code> may be too large for the specific function and <code class="language-javascript">offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code class="language-javascript">false</code>.

</p>
<p>Example:

</p>
<pre><code class="language-javascript">var buf = new Buffer(4);
buf.writeUInt16BE(0xdead, 0);
buf.writeUInt16BE(0xbeef, 2);

console.log(buf);

buf.writeUInt16LE(0xdead, 0);
buf.writeUInt16LE(0xbeef, 2);

console.log(buf);

// &lt;Buffer de ad be ef&gt;
// &lt;Buffer ad de ef be&gt;</code></pre>
<!--next-->
<h2>buf.writeUInt32LE(value, offset[, noAssert])</h2>
<!--next-->
<h2>buf.writeUInt32BE(value, offset[, noAssert])</h2>
<ul>
<li><code class="language-javascript">value</code> Number</li>
<li><code class="language-javascript">offset</code> Number</li>
<li><code class="language-javascript">noAssert</code> Boolean, Optional, Default: false</li>
</ul>
<p>Writes <code class="language-javascript">value</code> to the buffer at the specified offset with specified endian
format. Note, <code class="language-javascript">value</code> must be a valid unsigned 32 bit integer.

</p>
<p>Set <code class="language-javascript">noAssert</code> to true to skip validation of <code class="language-javascript">value</code> and <code class="language-javascript">offset</code>. This means
that <code class="language-javascript">value</code> may be too large for the specific function and <code class="language-javascript">offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code class="language-javascript">false</code>.

</p>
<p>Example:

</p>
<pre><code class="language-javascript">var buf = new Buffer(4);
buf.writeUInt32BE(0xfeedface, 0);

console.log(buf);

buf.writeUInt32LE(0xfeedface, 0);

console.log(buf);

// &lt;Buffer fe ed fa ce&gt;
// &lt;Buffer ce fa ed fe&gt;</code></pre>
<!--next-->
<h2>buf.writeInt8(value, offset[, noAssert])</h2>
<div class="signature"><ul>
<li><code class="language-javascript">value</code> Number</li>
<li><code class="language-javascript">offset</code> Number</li>
<li><code class="language-javascript">noAssert</code> Boolean, Optional, Default: false</li>
</div></ul>
<p>Writes <code class="language-javascript">value</code> to the buffer at the specified offset. Note, <code class="language-javascript">value</code> must be a
valid signed 8 bit integer.

</p>
<p>Set <code class="language-javascript">noAssert</code> to true to skip validation of <code class="language-javascript">value</code> and <code class="language-javascript">offset</code>. This means
that <code class="language-javascript">value</code> may be too large for the specific function and <code class="language-javascript">offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code class="language-javascript">false</code>.

</p>
<p>Works as <code class="language-javascript">buffer.writeUInt8</code>, except value is written out as a two&#39;s complement
signed integer into <code class="language-javascript">buffer</code>.

</p>
<!--next-->
<h2>buf.writeInt16LE(value, offset[, noAssert])</h2>
<!--next-->
<h2>buf.writeInt16BE(value, offset[, noAssert])</h2>
<ul>
<li><code class="language-javascript">value</code> Number</li>
<li><code class="language-javascript">offset</code> Number</li>
<li><code class="language-javascript">noAssert</code> Boolean, Optional, Default: false</li>
</ul>
<p>Writes <code class="language-javascript">value</code> to the buffer at the specified offset with specified endian
format. Note, <code class="language-javascript">value</code> must be a valid signed 16 bit integer.

</p>
<p>Set <code class="language-javascript">noAssert</code> to true to skip validation of <code class="language-javascript">value</code> and <code class="language-javascript">offset</code>. This means
that <code class="language-javascript">value</code> may be too large for the specific function and <code class="language-javascript">offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code class="language-javascript">false</code>.

</p>
<p>Works as <code class="language-javascript">buffer.writeUInt16*</code>, except value is written out as a two&#39;s
complement signed integer into <code class="language-javascript">buffer</code>.

</p>
<!--next-->
<h2>buf.writeInt32LE(value, offset[, noAssert])</h2>
<!--next-->
<h2>buf.writeInt32BE(value, offset[, noAssert])</h2>
<ul>
<li><code class="language-javascript">value</code> Number</li>
<li><code class="language-javascript">offset</code> Number</li>
<li><code class="language-javascript">noAssert</code> Boolean, Optional, Default: false</li>
</ul>
<p>Writes <code class="language-javascript">value</code> to the buffer at the specified offset with specified endian
format. Note, <code class="language-javascript">value</code> must be a valid signed 32 bit integer.

</p>
<p>Set <code class="language-javascript">noAssert</code> to true to skip validation of <code class="language-javascript">value</code> and <code class="language-javascript">offset</code>. This means
that <code class="language-javascript">value</code> may be too large for the specific function and <code class="language-javascript">offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code class="language-javascript">false</code>.

</p>
<p>Works as <code class="language-javascript">buffer.writeUInt32*</code>, except value is written out as a two&#39;s
complement signed integer into <code class="language-javascript">buffer</code>.

</p>
<!--next-->
<h2>buf.writeFloatLE(value, offset[, noAssert])</h2>
<!--next-->
<h2>buf.writeFloatBE(value, offset[, noAssert])</h2>
<ul>
<li><code class="language-javascript">value</code> Number</li>
<li><code class="language-javascript">offset</code> Number</li>
<li><code class="language-javascript">noAssert</code> Boolean, Optional, Default: false</li>
</ul>
<p>Writes <code class="language-javascript">value</code> to the buffer at the specified offset with specified endian
format. Note, behavior is unspecified if <code class="language-javascript">value</code> is not a 32 bit float.

</p>
<p>Set <code class="language-javascript">noAssert</code> to true to skip validation of <code class="language-javascript">value</code> and <code class="language-javascript">offset</code>. This means
that <code class="language-javascript">value</code> may be too large for the specific function and <code class="language-javascript">offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code class="language-javascript">false</code>.

</p>
<p>Example:

</p>
<pre><code class="language-javascript">var buf = new Buffer(4);
buf.writeFloatBE(0xcafebabe, 0);

console.log(buf);

buf.writeFloatLE(0xcafebabe, 0);

console.log(buf);

// &lt;Buffer 4f 4a fe bb&gt;
// &lt;Buffer bb fe 4a 4f&gt;</code></pre>
<!--next-->
<h2>buf.writeDoubleLE(value, offset[, noAssert])</h2>
<!--next-->
<h2>buf.writeDoubleBE(value, offset[, noAssert])</h2>
<ul>
<li><code class="language-javascript">value</code> Number</li>
<li><code class="language-javascript">offset</code> Number</li>
<li><code class="language-javascript">noAssert</code> Boolean, Optional, Default: false</li>
</ul>
<p>Writes <code class="language-javascript">value</code> to the buffer at the specified offset with specified endian
format. Note, <code class="language-javascript">value</code> must be a valid 64 bit double.

</p>
<p>Set <code class="language-javascript">noAssert</code> to true to skip validation of <code class="language-javascript">value</code> and <code class="language-javascript">offset</code>. This means
that <code class="language-javascript">value</code> may be too large for the specific function and <code class="language-javascript">offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code class="language-javascript">false</code>.

</p>
<p>Example:

</p>
<pre><code class="language-javascript">var buf = new Buffer(8);
buf.writeDoubleBE(0xdeadbeefcafebabe, 0);

console.log(buf);

buf.writeDoubleLE(0xdeadbeefcafebabe, 0);

console.log(buf);

// &lt;Buffer 43 eb d5 b7 dd f9 5f d7&gt;
// &lt;Buffer d7 5f f9 dd b7 d5 eb 43&gt;</code></pre>
<!--next-->
<h2>buf.fill(value[, offset][, end])</h2>
<div class="signature"><ul>
<li><code class="language-javascript">value</code></li>
<li><code class="language-javascript">offset</code> Number, Optional</li>
<li><code class="language-javascript">end</code> Number, Optional</li>
</div></ul>
<p>Fills the buffer with the specified value. If the <code class="language-javascript">offset</code> (defaults to <code class="language-javascript">0</code>)
and <code class="language-javascript">end</code> (defaults to <code class="language-javascript">buffer.length</code>) are not given it will fill the entire
buffer.

</p>
<pre><code class="language-javascript">var b = new Buffer(50);
b.fill(&quot;h&quot;);</code></pre>
<!--next-->
<h2>buffer.INSPECT_MAX_BYTES</h2>
<div class="signature"><ul>
<li>Number, Default: 50</li>
</div></ul>
<p>How many bytes will be returned when <code class="language-javascript">buffer.inspect()</code> is called. This can
be overridden by user modules.

</p>
<p>Note that this is a property on the buffer module returned by
<code class="language-javascript">require(&#39;buffer&#39;)</code>, not on the Buffer global, or a buffer instance.

</p>
<!--next-->
<h2>Class: SlowBuffer</h2>
<p>Returns an un-pooled <code class="language-javascript">Buffer</code>.

</p>
<p>In order to avoid the garbage collection overhead of creating many individually
allocated Buffers, by default allocations under 4KB are sliced from a single
larger allocated object. This approach improves both performance and memory
usage since v8 does not need to track and cleanup as many <code class="language-javascript">Persistent</code> objects.

</p>
<p>In the case where a developer may need to retain a small chunk of memory from a
pool for an indeterminate amount of time it may be appropriate to create an
un-pooled Buffer instance using SlowBuffer and copy out the relevant bits.

</p>
<pre><code class="language-javascript">// need to keep around a few small chunks of memory
var store = [];

socket.on(&#39;readable&#39;, function() {
  var data = socket.read();
  // allocate for retained data
  var sb = new SlowBuffer(10);
  // copy the data into the new allocation
  data.copy(sb, 0, 0, 10);
  store.push(sb);
});</code></pre>
<p>Though this should used sparingly and only be a last resort <em>after</em> a developer
has actively observed undue memory retention in their applications.

</p>
<!--next-->
<h2>Stream</h2>
<pre class="stability">Stability: 2 - Unstable</pre><p>A stream is an abstract interface implemented by various objects in
Node.  For example a <a>request to an HTTP
server</a> is a stream, as is
<a>stdout</a>. Streams are readable, writable, or both. All streams are
instances of <a>EventEmitter</a>

</p>
<p>You can load the Stream base classes by doing <code class="language-javascript">require(&#39;stream&#39;)</code>.
There are base classes provided for <a>Readable</a> streams, <a>Writable</a>
streams, <a>Duplex</a> streams, and <a>Transform</a> streams.

</p>
<p>This document is split up into 3 sections.  The first explains the
parts of the API that you need to be aware of to use streams in your
programs.  If you never implement a streaming API yourself, you can
stop there.

</p>
<p>The second section explains the parts of the API that you need to use
if you implement your own custom streams yourself.  The API is
designed to make this easy for you to do.

</p>
<p>The third section goes into more depth about how streams work,
including some of the internal mechanisms and functions that you
should probably not modify unless you definitely know what you are
doing.


</p>
<!--next-->
<h2>API for Stream Consumers</h2>
<p>Streams can be either <a>Readable</a>, <a>Writable</a>, or both (<a>Duplex</a>).

</p>
<p>All streams are EventEmitters, but they also have other custom methods
and properties depending on whether they are Readable, Writable, or
Duplex.

</p>
<p>If a stream is both Readable and Writable, then it implements all of
the methods and events below.  So, a <a>Duplex</a> or <a>Transform</a> stream is
fully described by this API, though their implementation may be
somewhat different.

</p>
<p>It is not necessary to implement Stream interfaces in order to consume
streams in your programs.  If you <strong>are</strong> implementing streaming
interfaces in your own program, please also refer to
<a>API for Stream Implementors</a> below.

</p>
<p>Almost all Node programs, no matter how simple, use Streams in some
way.  Here is an example of using Streams in a Node program:

</p>
<pre><code class="javascript">var http = require(&#39;http&#39;);

var server = http.createServer(function (req, res) {
  // req is an http.IncomingMessage, which is a Readable Stream
  // res is an http.ServerResponse, which is a Writable Stream

  var body = &#39;&#39;;
  // we want to get the data as utf8 strings
  // If you don&#39;t set an encoding, then you&#39;ll get Buffer objects
  req.setEncoding(&#39;utf8&#39;);

  // Readable streams emit &#39;data&#39; events once a listener is added
  req.on(&#39;data&#39;, function (chunk) {
    body += chunk;
  });

  // the end event tells you that you have entire body
  req.on(&#39;end&#39;, function () {
    try {
      var data = JSON.parse(body);
    } catch (er) {
      // uh oh!  bad json!
      res.statusCode = 400;
      return res.end(&#39;error: &#39; + er.message);
    }

    // write back something interesting to the user:
    res.write(typeof data);
    res.end();
  });
});

server.listen(1337);

// $ curl localhost:1337 -d &#39;{}&#39;
// object
// $ curl localhost:1337 -d &#39;&quot;foo&quot;&#39;
// string
// $ curl localhost:1337 -d &#39;not json&#39;
// error: Unexpected token o</code></pre>
<!--next-->
<h2>Class: stream.Readable</h2>
<!--type=class-->

<p>The Readable stream interface is the abstraction for a <em>source</em> of
data that you are reading from.  In other words, data comes <em>out</em> of a
Readable stream.

</p>
<p>A Readable stream will not start emitting data until you indicate that
you are ready to receive it.

</p>
<p>Readable streams have two &quot;modes&quot;: a <strong>flowing mode</strong> and a <strong>paused
mode</strong>.  When in flowing mode, data is read from the underlying system
and provided to your program as fast as possible.  In paused mode, you
must explicitly call <code class="language-javascript">stream.read()</code> to get chunks of data out.
Streams start out in paused mode.

</p>
<p><strong>Note</strong>: If no data event handlers are attached, and there are no
<a><code class="language-javascript">pipe()</code></a> destinations, and the stream is switched into flowing
mode, then data will be lost.

</p>
<p>You can switch to flowing mode by doing any of the following:

</p>
<ul>
<li>Adding a <a><code class="language-javascript">&#39;data&#39;</code> event</a> handler to listen for data.</li>
<li>Calling the <a><code class="language-javascript">resume()</code></a> method to explicitly open the flow.</li>
<li>Calling the <a><code class="language-javascript">pipe()</code></a> method to send the data to a <a>Writable</a>.</li>
</ul>
<p>You can switch back to paused mode by doing either of the following:

</p>
<ul>
<li>If there are no pipe destinations, by calling the <a><code class="language-javascript">pause()</code></a>
method.</li>
<li>If there are pipe destinations, by removing any <a><code class="language-javascript">&#39;data&#39;</code> event</a>
handlers, and removing all pipe destinations by calling the
<a><code class="language-javascript">unpipe()</code></a> method.</li>
</ul>
<p>Note that, for backwards compatibility reasons, removing <code class="language-javascript">&#39;data&#39;</code>
event handlers will <strong>not</strong> automatically pause the stream.  Also, if
there are piped destinations, then calling <code class="language-javascript">pause()</code> will not
guarantee that the stream will <em>remain</em> paused once those
destinations drain and ask for more data.

</p>
<p>Examples of readable streams include:

</p>
<ul>
<li><a>http responses, on the client</a></li>
<li><a>http requests, on the server</a></li>
<li><a>fs read streams</a></li>
<li><a>zlib streams</a></li>
<li><a>crypto streams</a></li>
<li><a>tcp sockets</a></li>
<li><a>child process stdout and stderr</a></li>
<li><a>process.stdin</a></li>
</ul>
<h4>Event: &#39;readable&#39;</h4>
<p>When a chunk of data can be read from the stream, it will emit a
<code class="language-javascript">&#39;readable&#39;</code> event.

</p>
<p>In some cases, listening for a <code class="language-javascript">&#39;readable&#39;</code> event will cause some data
to be read into the internal buffer from the underlying system, if it
hadn&#39;t already.

</p>
<pre><code class="javascript">var readable = getReadableStreamSomehow();
readable.on(&#39;readable&#39;, function() {
  // there is some data to read now
});</code></pre>
<p>Once the internal buffer is drained, a <code class="language-javascript">readable</code> event will fire
again when more data is available.

</p>
<h4>Event: &#39;data&#39;</h4>
<div class="signature"><ul>
<li><code class="language-javascript">chunk</code> <span class="type">Buffer | String</span> The chunk of data.</li>
</div></ul>
<p>Attaching a <code class="language-javascript">data</code> event listener to a stream that has not been
explicitly paused will switch the stream into flowing mode. Data will
then be passed as soon as it is available.

</p>
<p>If you just want to get all the data out of the stream as fast as
possible, this is the best way to do so.

</p>
<pre><code class="javascript">var readable = getReadableStreamSomehow();
readable.on(&#39;data&#39;, function(chunk) {
  console.log(&#39;got %d bytes of data&#39;, chunk.length);
});</code></pre>
<h4>Event: &#39;end&#39;</h4>
<p>This event fires when there will be no more data to read.

</p>
<p>Note that the <code class="language-javascript">end</code> event <strong>will not fire</strong> unless the data is
completely consumed.  This can be done by switching into flowing mode,
or by calling <code class="language-javascript">read()</code> repeatedly until you get to the end.

</p>
<pre><code class="javascript">var readable = getReadableStreamSomehow();
readable.on(&#39;data&#39;, function(chunk) {
  console.log(&#39;got %d bytes of data&#39;, chunk.length);
});
readable.on(&#39;end&#39;, function() {
  console.log(&#39;there will be no more data.&#39;);
});</code></pre>
<h4>Event: &#39;close&#39;</h4>
<p>Emitted when the underlying resource (for example, the backing file
descriptor) has been closed. Not all streams will emit this.

</p>
<h4>Event: &#39;error&#39;</h4>
<div class="signature"><ul>
<li><span class="type">Error Object</span></li>
</div></ul>
<p>Emitted if there was an error receiving data.

</p>
<h4>readable.read([size])</h4>
<div class="signature"><ul>
<li><code class="language-javascript">size</code> <span class="type">Number</span> Optional argument to specify how much data to read.</li>
<li>Return <span class="type">String | Buffer | null</span></li>
</div></ul>
<p>The <code class="language-javascript">read()</code> method pulls some data out of the internal buffer and
returns it.  If there is no data available, then it will return
<code class="language-javascript">null</code>.

</p>
<p>If you pass in a <code class="language-javascript">size</code> argument, then it will return that many
bytes.  If <code class="language-javascript">size</code> bytes are not available, then it will return <code class="language-javascript">null</code>.

</p>
<p>If you do not specify a <code class="language-javascript">size</code> argument, then it will return all the
data in the internal buffer.

</p>
<p>This method should only be called in paused mode.  In flowing mode,
this method is called automatically until the internal buffer is
drained.

</p>
<pre><code class="javascript">var readable = getReadableStreamSomehow();
readable.on(&#39;readable&#39;, function() {
  var chunk;
  while (null !== (chunk = readable.read())) {
    console.log(&#39;got %d bytes of data&#39;, chunk.length);
  }
});</code></pre>
<p>If this method returns a data chunk, then it will also trigger the
emission of a <a><code class="language-javascript">&#39;data&#39;</code> event</a>.

</p>
<h4>readable.setEncoding(encoding)</h4>
<div class="signature"><ul>
<li><code class="language-javascript">encoding</code> <span class="type">String</span> The encoding to use.</li>
<li>Return: <code class="language-javascript">this</code></li>
</div></ul>
<p>Call this function to cause the stream to return strings of the
specified encoding instead of Buffer objects.  For example, if you do
<code class="language-javascript">readable.setEncoding(&#39;utf8&#39;)</code>, then the output data will be
interpreted as UTF-8 data, and returned as strings.  If you do
<code class="language-javascript">readable.setEncoding(&#39;hex&#39;)</code>, then the data will be encoded in
hexadecimal string format.

</p>
<p>This properly handles multi-byte characters that would otherwise be
potentially mangled if you simply pulled the Buffers directly and
called <code class="language-javascript">buf.toString(encoding)</code> on them.  If you want to read the data
as strings, always use this method.

</p>
<pre><code class="javascript">var readable = getReadableStreamSomehow();
readable.setEncoding(&#39;utf8&#39;);
readable.on(&#39;data&#39;, function(chunk) {
  assert.equal(typeof chunk, &#39;string&#39;);
  console.log(&#39;got %d characters of string data&#39;, chunk.length);
});</code></pre>
<h4>readable.resume()</h4>
<div class="signature"><ul>
<li>Return: <code class="language-javascript">this</code></li>
</div></ul>
<p>This method will cause the readable stream to resume emitting <code class="language-javascript">data</code>
events.

</p>
<p>This method will switch the stream into flowing mode.  If you do <em>not</em>
want to consume the data from a stream, but you <em>do</em> want to get to
its <code class="language-javascript">end</code> event, you can call <a><code class="language-javascript">readable.resume()</code></a> to open the flow of
data.

</p>
<pre><code class="javascript">var readable = getReadableStreamSomehow();
readable.resume();
readable.on(&#39;end&#39;, function(chunk) {
  console.log(&#39;got to the end, but did not read anything&#39;);
});</code></pre>
<h4>readable.pause()</h4>
<div class="signature"><ul>
<li>Return: <code class="language-javascript">this</code></li>
</div></ul>
<p>This method will cause a stream in flowing mode to stop emitting
<code class="language-javascript">data</code> events, switching out of flowing mode.  Any data that becomes
available will remain in the internal buffer.

</p>
<pre><code class="javascript">var readable = getReadableStreamSomehow();
readable.on(&#39;data&#39;, function(chunk) {
  console.log(&#39;got %d bytes of data&#39;, chunk.length);
  readable.pause();
  console.log(&#39;there will be no more data for 1 second&#39;);
  setTimeout(function() {
    console.log(&#39;now data will start flowing again&#39;);
    readable.resume();
  }, 1000);
});</code></pre>
<h4>readable.isPaused()</h4>
<div class="signature"><ul>
<li>Return: <code class="language-javascript">Boolean</code></li>
</div></ul>
<p>This method returns whether or not the <code class="language-javascript">readable</code> has been <strong>explicitly</strong>
paused by client code (using <code class="language-javascript">readable.pause()</code> without a corresponding
<code class="language-javascript">readable.resume()</code>).

</p>
<pre><code class="javascript">var readable = new stream.Readable

readable.isPaused() // === false
readable.pause()
readable.isPaused() // === true
readable.resume()
readable.isPaused() // === false</code></pre>
<h4>readable.pipe(destination[, options])</h4>
<div class="signature"><ul>
<li><code class="language-javascript">destination</code> <span class="type"><a>Writable</a> Stream</span> The destination for writing data</li>
<li><code class="language-javascript">options</code> <span class="type">Object</span> Pipe options<ul>
<li><code class="language-javascript">end</code> <span class="type">Boolean</span> End the writer when the reader ends. Default = <code class="language-javascript">true</code></li>
</ul>
</li>
</div></ul>
<p>This method pulls all the data out of a readable stream, and writes it
to the supplied destination, automatically managing the flow so that
the destination is not overwhelmed by a fast readable stream.

</p>
<p>Multiple destinations can be piped to safely.

</p>
<pre><code class="javascript">var readable = getReadableStreamSomehow();
var writable = fs.createWriteStream(&#39;file.txt&#39;);
// All the data from readable goes into &#39;file.txt&#39;
readable.pipe(writable);</code></pre>
<p>This function returns the destination stream, so you can set up pipe
chains like so:

</p>
<pre><code class="javascript">var r = fs.createReadStream(&#39;file.txt&#39;);
var z = zlib.createGzip();
var w = fs.createWriteStream(&#39;file.txt.gz&#39;);
r.pipe(z).pipe(w);</code></pre>
<p>For example, emulating the Unix <code class="language-javascript">cat</code> command:

</p>
<pre><code class="javascript">process.stdin.pipe(process.stdout);</code></pre>
<p>By default <a><code class="language-javascript">end()</code></a> is called on the destination when the source stream
emits <code class="language-javascript">end</code>, so that <code class="language-javascript">destination</code> is no longer writable. Pass <code class="language-javascript">{ end:
false }</code> as <code class="language-javascript">options</code> to keep the destination stream open.

</p>
<p>This keeps <code class="language-javascript">writer</code> open so that &quot;Goodbye&quot; can be written at the
end.

</p>
<pre><code class="javascript">reader.pipe(writer, { end: false });
reader.on(&#39;end&#39;, function() {
  writer.end(&#39;Goodbye\n&#39;);
});</code></pre>
<p>Note that <code class="language-javascript">process.stderr</code> and <code class="language-javascript">process.stdout</code> are never closed until
the process exits, regardless of the specified options.

</p>
<h4>readable.unpipe([destination])</h4>
<div class="signature"><ul>
<li><code class="language-javascript">destination</code> <span class="type"><a>Writable</a> Stream</span> Optional specific stream to unpipe</li>
</div></ul>
<p>This method will remove the hooks set up for a previous <code class="language-javascript">pipe()</code> call.

</p>
<p>If the destination is not specified, then all pipes are removed.

</p>
<p>If the destination is specified, but no pipe is set up for it, then
this is a no-op.

</p>
<pre><code class="javascript">var readable = getReadableStreamSomehow();
var writable = fs.createWriteStream(&#39;file.txt&#39;);
// All the data from readable goes into &#39;file.txt&#39;,
// but only for the first second
readable.pipe(writable);
setTimeout(function() {
  console.log(&#39;stop writing to file.txt&#39;);
  readable.unpipe(writable);
  console.log(&#39;manually close the file stream&#39;);
  writable.end();
}, 1000);</code></pre>
<h4>readable.unshift(chunk)</h4>
<div class="signature"><ul>
<li><code class="language-javascript">chunk</code> <span class="type">Buffer | String</span> Chunk of data to unshift onto the read queue</li>
</div></ul>
<p>This is useful in certain cases where a stream is being consumed by a
parser, which needs to &quot;un-consume&quot; some data that it has
optimistically pulled out of the source, so that the stream can be
passed on to some other party.

</p>
<p>If you find that you must often call <code class="language-javascript">stream.unshift(chunk)</code> in your
programs, consider implementing a <a>Transform</a> stream instead.  (See API
for Stream Implementors, below.)

</p>
<pre><code class="javascript">// Pull off a header delimited by \n\n
// use unshift() if we get too much
// Call the callback with (error, header, stream)
var StringDecoder = require(&#39;string_decoder&#39;).StringDecoder;
function parseHeader(stream, callback) {
  stream.on(&#39;error&#39;, callback);
  stream.on(&#39;readable&#39;, onReadable);
  var decoder = new StringDecoder(&#39;utf8&#39;);
  var header = &#39;&#39;;
  function onReadable() {
    var chunk;
    while (null !== (chunk = stream.read())) {
      var str = decoder.write(chunk);
      if (str.match(/\n\n/)) {
        // found the header boundary
        var split = str.split(/\n\n/);
        header += split.shift();
        var remaining = split.join(&#39;\n\n&#39;);
        var buf = new Buffer(remaining, &#39;utf8&#39;);
        if (buf.length)
          stream.unshift(buf);
        stream.removeListener(&#39;error&#39;, callback);
        stream.removeListener(&#39;readable&#39;, onReadable);
        // now the body of the message can be read from the stream.
        callback(null, header, stream);
      } else {
        // still reading the header.
        header += str;
      }
    }
  }
}</code></pre>
<h4>readable.wrap(stream)</h4>
<div class="signature"><ul>
<li><code class="language-javascript">stream</code> <span class="type">Stream</span> An &quot;old style&quot; readable stream</li>
</div></ul>
<p>Versions of Node prior to v0.10 had streams that did not implement the
entire Streams API as it is today.  (See &quot;Compatibility&quot; below for
more information.)

</p>
<p>If you are using an older Node library that emits <code class="language-javascript">&#39;data&#39;</code> events and
has a <a><code class="language-javascript">pause()</code></a> method that is advisory only, then you can use the
<code class="language-javascript">wrap()</code> method to create a <a>Readable</a> stream that uses the old stream
as its data source.

</p>
<p>You will very rarely ever need to call this function, but it exists
as a convenience for interacting with old Node programs and libraries.

</p>
<p>For example:

</p>
<pre><code class="javascript">var OldReader = require(&#39;./old-api-module.js&#39;).OldReader;
var oreader = new OldReader;
var Readable = require(&#39;stream&#39;).Readable;
var myReader = new Readable().wrap(oreader);

myReader.on(&#39;readable&#39;, function() {
  myReader.read(); // etc.
});</code></pre>
<!--next-->
<h2>Class: stream.Writable</h2>
<!--type=class-->

<p>The Writable stream interface is an abstraction for a <em>destination</em>
that you are writing data <em>to</em>.

</p>
<p>Examples of writable streams include:

</p>
<ul>
<li><a>http requests, on the client</a></li>
<li><a>http responses, on the server</a></li>
<li><a>fs write streams</a></li>
<li><a>zlib streams</a></li>
<li><a>crypto streams</a></li>
<li><a>tcp sockets</a></li>
<li><a>child process stdin</a></li>
<li><a>process.stdout</a>, <a>process.stderr</a></li>
</ul>
<h4>writable.write(chunk[, encoding][, callback])</h4>
<div class="signature"><ul>
<li><code class="language-javascript">chunk</code> <span class="type">String | Buffer</span> The data to write</li>
<li><code class="language-javascript">encoding</code> <span class="type">String</span> The encoding, if <code class="language-javascript">chunk</code> is a String</li>
<li><code class="language-javascript">callback</code> <span class="type">Function</span> Callback for when this chunk of data is flushed</li>
<li>Returns: <span class="type">Boolean</span> True if the data was handled completely.</li>
</div></ul>
<p>This method writes some data to the underlying system, and calls the
supplied callback once the data has been fully handled.

</p>
<p>The return value indicates if you should continue writing right now.
If the data had to be buffered internally, then it will return
<code class="language-javascript">false</code>.  Otherwise, it will return <code class="language-javascript">true</code>.

</p>
<p>This return value is strictly advisory.  You MAY continue to write,
even if it returns <code class="language-javascript">false</code>.  However, writes will be buffered in
memory, so it is best not to do this excessively.  Instead, wait for
the <code class="language-javascript">drain</code> event before writing more data.

</p>
<h4>Event: &#39;drain&#39;</h4>
<p>If a <a><code class="language-javascript">writable.write(chunk)</code></a> call returns false, then the <code class="language-javascript">drain</code>
event will indicate when it is appropriate to begin writing more data
to the stream.

</p>
<pre><code class="javascript">// Write the data to the supplied writable stream 1MM times.
// Be attentive to back-pressure.
function writeOneMillionTimes(writer, data, encoding, callback) {
  var i = 1000000;
  write();
  function write() {
    var ok = true;
    do {
      i -= 1;
      if (i === 0) {
        // last time!
        writer.write(data, encoding, callback);
      } else {
        // see if we should continue, or wait
        // don&#39;t pass the callback, because we&#39;re not done yet.
        ok = writer.write(data, encoding);
      }
    } while (i &gt; 0 &amp;&amp; ok);
    if (i &gt; 0) {
      // had to stop early!
      // write some more once it drains
      writer.once(&#39;drain&#39;, write);
    }
  }
}</code></pre>
<h4>writable.cork()</h4>
<p>Forces buffering of all writes.

</p>
<p>Buffered data will be flushed either at <code class="language-javascript">.uncork()</code> or at <code class="language-javascript">.end()</code> call.

</p>
<h4>writable.uncork()</h4>
<p>Flush all data, buffered since <code class="language-javascript">.cork()</code> call.

</p>
<h4>writable.setDefaultEncoding(encoding)</h4>
<div class="signature"><ul>
<li><code class="language-javascript">encoding</code> <span class="type">String</span> The new default encoding</li>
<li>Return: <code class="language-javascript">Boolean</code></li>
</div></ul>
<p>Sets the default encoding for a writable stream. Returns <code class="language-javascript">true</code> if the encoding
is valid and is set. Otherwise returns <code class="language-javascript">false</code>.

</p>
<h4>writable.end([chunk][, encoding][, callback])</h4>
<div class="signature"><ul>
<li><code class="language-javascript">chunk</code> <span class="type">String | Buffer</span> Optional data to write</li>
<li><code class="language-javascript">encoding</code> <span class="type">String</span> The encoding, if <code class="language-javascript">chunk</code> is a String</li>
<li><code class="language-javascript">callback</code> <span class="type">Function</span> Optional callback for when the stream is finished</li>
</div></ul>
<p>Call this method when no more data will be written to the stream.  If
supplied, the callback is attached as a listener on the <code class="language-javascript">finish</code> event.

</p>
<p>Calling <a><code class="language-javascript">write()</code></a> after calling <a><code class="language-javascript">end()</code></a> will raise an error.

</p>
<pre><code class="javascript">// write &#39;hello, &#39; and then end with &#39;world!&#39;
var file = fs.createWriteStream(&#39;example.txt&#39;);
file.write(&#39;hello, &#39;);
file.end(&#39;world!&#39;);
// writing more now is not allowed!</code></pre>
<h4>Event: &#39;finish&#39;</h4>
<p>When the <a><code class="language-javascript">end()</code></a> method has been called, and all data has been flushed
to the underlying system, this event is emitted.

</p>
<pre><code class="javascript">var writer = getWritableStreamSomehow();
for (var i = 0; i &lt; 100; i ++) {
  writer.write(&#39;hello, #&#39; + i + &#39;!\n&#39;);
}
writer.end(&#39;this is the end\n&#39;);
writer.on(&#39;finish&#39;, function() {
  console.error(&#39;all writes are now complete.&#39;);
});</code></pre>
<h4>Event: &#39;pipe&#39;</h4>
<div class="signature"><ul>
<li><code class="language-javascript">src</code> <span class="type"><a>Readable</a> Stream</span> source stream that is piping to this writable</li>
</div></ul>
<p>This is emitted whenever the <code class="language-javascript">pipe()</code> method is called on a readable
stream, adding this writable to its set of destinations.

</p>
<pre><code class="javascript">var writer = getWritableStreamSomehow();
var reader = getReadableStreamSomehow();
writer.on(&#39;pipe&#39;, function(src) {
  console.error(&#39;something is piping into the writer&#39;);
  assert.equal(src, reader);
});
reader.pipe(writer);</code></pre>
<h4>Event: &#39;unpipe&#39;</h4>
<div class="signature"><ul>
<li><code class="language-javascript">src</code> <span class="type"><a>Readable</a> Stream</span> The source stream that <a>unpiped</a> this writable</li>
</div></ul>
<p>This is emitted whenever the <a><code class="language-javascript">unpipe()</code></a> method is called on a
readable stream, removing this writable from its set of destinations.

</p>
<pre><code class="javascript">var writer = getWritableStreamSomehow();
var reader = getReadableStreamSomehow();
writer.on(&#39;unpipe&#39;, function(src) {
  console.error(&#39;something has stopped piping into the writer&#39;);
  assert.equal(src, reader);
});
reader.pipe(writer);
reader.unpipe(writer);</code></pre>
<h4>Event: &#39;error&#39;</h4>
<div class="signature"><ul>
<li><span class="type">Error object</span></li>
</div></ul>
<p>Emitted if there was an error when writing or piping data.

</p>
<!--next-->
<h2>Class: stream.Duplex</h2>
<p>Duplex streams are streams that implement both the <a>Readable</a> and
<a>Writable</a> interfaces.  See above for usage.

</p>
<p>Examples of Duplex streams include:

</p>
<ul>
<li><a>tcp sockets</a></li>
<li><a>zlib streams</a></li>
<li><a>crypto streams</a></li>
</ul>
<!--next-->
<h2>Class: stream.Transform</h2>
<p>Transform streams are <a>Duplex</a> streams where the output is in some way
computed from the input.  They implement both the <a>Readable</a> and
<a>Writable</a> interfaces.  See above for usage.

</p>
<p>Examples of Transform streams include:

</p>
<ul>
<li><a>zlib streams</a></li>
<li><a>crypto streams</a></li>
</ul>
<!--next-->
<h2>API for Stream Implementors</h2>
<p>To implement any sort of stream, the pattern is the same:

</p>
<ol>
<li>Extend the appropriate parent class in your own subclass.  (The
<a><code class="language-javascript">util.inherits</code></a> method is particularly helpful for this.)</li>
<li>Call the appropriate parent class constructor in your constructor,
to be sure that the internal mechanisms are set up properly.</li>
<li>Implement one or more specific methods, as detailed below.</li>
</ol>
<p>The class to extend and the method(s) to implement depend on the sort
of stream class you are writing:

</p>
<table>
  <thead>
    <tr>
      <th>
        <p>Use-case</p>
      </th>
      <th>
        <p>Class</p>
      </th>
      <th>
        <p>Method(s) to implement</p>
      </th>
    </tr>
  </thead>
  <tr>
    <td>
      <p>Reading only</p>
    </td>
    <td>
      <p><a>Readable</a></p>
    </td>
    <td>
      <p><code class="language-javascript"><a>_read</a></code></p>
    </td>
  </tr>
  <tr>
    <td>
      <p>Writing only</p>
    </td>
    <td>
      <p><a>Writable</a></p>
    </td>
    <td>
      <p><code class="language-javascript"><a>_write</a></code></p>
    </td>
  </tr>
  <tr>
    <td>
      <p>Reading and writing</p>
    </td>
    <td>
      <p><a>Duplex</a></p>
    </td>
    <td>
      <p><code class="language-javascript"><a>_read</a></code>, <code class="language-javascript"><a>_write</a></code></p>
    </td>
  </tr>
  <tr>
    <td>
      <p>Operate on written data, then read the result</p>
    </td>
    <td>
      <p><a>Transform</a></p>
    </td>
    <td>
      <p><code class="language-javascript">_transform</code>, <code class="language-javascript">_flush</code></p>
    </td>
  </tr>
</table>

<p>In your implementation code, it is very important to never call the
methods described in <a>API for Stream Consumers</a> above.  Otherwise, you
can potentially cause adverse side effects in programs that consume
your streaming interfaces.

</p>
<!--next-->
<h2>Class: stream.Readable</h2>
<!--type=class-->

<p><code class="language-javascript">stream.Readable</code> is an abstract class designed to be extended with an
underlying implementation of the <a><code class="language-javascript">_read(size)</code></a> method.

</p>
<p>Please see above under <a>API for Stream Consumers</a> for how to consume
streams in your programs.  What follows is an explanation of how to
implement Readable streams in your programs.

</p>
<h4>Example: A Counting Stream</h4>
<!--type=example-->

<p>This is a basic example of a Readable stream.  It emits the numerals
from 1 to 1,000,000 in ascending order, and then ends.

</p>
<pre><code class="javascript">var Readable = require(&#39;stream&#39;).Readable;
var util = require(&#39;util&#39;);
util.inherits(Counter, Readable);

function Counter(opt) {
  Readable.call(this, opt);
  this._max = 1000000;
  this._index = 1;
}

Counter.prototype._read = function() {
  var i = this._index++;
  if (i &gt; this._max)
    this.push(null);
  else {
    var str = &#39;&#39; + i;
    var buf = new Buffer(str, &#39;ascii&#39;);
    this.push(buf);
  }
};</code></pre>
<h4>Example: SimpleProtocol v1 (Sub-optimal)</h4>
<p>This is similar to the <code class="language-javascript">parseHeader</code> function described above, but
implemented as a custom stream.  Also, note that this implementation
does not convert the incoming data to a string.

</p>
<p>However, this would be better implemented as a <a>Transform</a> stream.  See
below for a better implementation.

</p>
<pre><code class="javascript">// A parser for a simple data protocol.
// The &quot;header&quot; is a JSON object, followed by 2 \n characters, and
// then a message body.
//
// NOTE: This can be done more simply as a Transform stream!
// Using Readable directly for this is sub-optimal.  See the
// alternative example below under the Transform section.

var Readable = require(&#39;stream&#39;).Readable;
var util = require(&#39;util&#39;);

util.inherits(SimpleProtocol, Readable);

function SimpleProtocol(source, options) {
  if (!(this instanceof SimpleProtocol))
    return new SimpleProtocol(source, options);

  Readable.call(this, options);
  this._inBody = false;
  this._sawFirstCr = false;

  // source is a readable stream, such as a socket or file
  this._source = source;

  var self = this;
  source.on(&#39;end&#39;, function() {
    self.push(null);
  });

  // give it a kick whenever the source is readable
  // read(0) will not consume any bytes
  source.on(&#39;readable&#39;, function() {
    self.read(0);
  });

  this._rawHeader = [];
  this.header = null;
}

SimpleProtocol.prototype._read = function(n) {
  if (!this._inBody) {
    var chunk = this._source.read();

    // if the source doesn&#39;t have data, we don&#39;t have data yet.
    if (chunk === null)
      return this.push(&#39;&#39;);

    // check if the chunk has a \n\n
    var split = -1;
    for (var i = 0; i &lt; chunk.length; i++) {
      if (chunk[i] === 10) { // &#39;\n&#39;
        if (this._sawFirstCr) {
          split = i;
          break;
        } else {
          this._sawFirstCr = true;
        }
      } else {
        this._sawFirstCr = false;
      }
    }

    if (split === -1) {
      // still waiting for the \n\n
      // stash the chunk, and try again.
      this._rawHeader.push(chunk);
      this.push(&#39;&#39;);
    } else {
      this._inBody = true;
      var h = chunk.slice(0, split);
      this._rawHeader.push(h);
      var header = Buffer.concat(this._rawHeader).toString();
      try {
        this.header = JSON.parse(header);
      } catch (er) {
        this.emit(&#39;error&#39;, new Error(&#39;invalid simple protocol data&#39;));
        return;
      }
      // now, because we got some extra data, unshift the rest
      // back into the read queue so that our consumer will see it.
      var b = chunk.slice(split);
      this.unshift(b);

      // and let them know that we are done parsing the header.
      this.emit(&#39;header&#39;, this.header);
    }
  } else {
    // from there on, just provide the data to our consumer.
    // careful not to push(null), since that would indicate EOF.
    var chunk = this._source.read();
    if (chunk) this.push(chunk);
  }
};

// Usage:
// var parser = new SimpleProtocol(source);
// Now parser is a readable stream that will emit &#39;header&#39;
// with the parsed header data.</code></pre>
<h4>new stream.Readable([options])</h4>
<div class="signature"><ul>
<li><code class="language-javascript">options</code> <span class="type">Object</span><ul>
<li><code class="language-javascript">highWaterMark</code> <span class="type">Number</span> The maximum number of bytes to store in
the internal buffer before ceasing to read from the underlying
resource.  Default=16kb, or 16 for <code class="language-javascript">objectMode</code> streams</li>
<li><code class="language-javascript">encoding</code> <span class="type">String</span> If specified, then buffers will be decoded to
strings using the specified encoding.  Default=null</li>
<li><code class="language-javascript">objectMode</code> <span class="type">Boolean</span> Whether this stream should behave
as a stream of objects. Meaning that stream.read(n) returns
a single value instead of a Buffer of size n.  Default=false</li>
</ul>
</li>
</div></ul>
<p>In classes that extend the Readable class, make sure to call the
Readable constructor so that the buffering settings can be properly
initialized.

</p>
<h4>readable._read(size)</h4>
<div class="signature"><ul>
<li><code class="language-javascript">size</code> <span class="type">Number</span> Number of bytes to read asynchronously</li>
</div></ul>
<p>Note: <strong>Implement this function, but do NOT call it directly.</strong>

</p>
<p>This function should NOT be called directly.  It should be implemented
by child classes, and only called by the internal Readable class
methods.

</p>
<p>All Readable stream implementations must provide a <code class="language-javascript">_read</code> method to
fetch data from the underlying resource.

</p>
<p>This method is prefixed with an underscore because it is internal to
the class that defines it, and should not be called directly by user
programs.  However, you <strong>are</strong> expected to override this method in
your own extension classes.

</p>
<p>When data is available, put it into the read queue by calling
<code class="language-javascript">readable.push(chunk)</code>.  If <code class="language-javascript">push</code> returns false, then you should stop
reading.  When <code class="language-javascript">_read</code> is called again, you should start pushing more
data.

</p>
<p>The <code class="language-javascript">size</code> argument is advisory.  Implementations where a &quot;read&quot; is a
single call that returns data can use this to know how much data to
fetch.  Implementations where that is not relevant, such as TCP or
TLS, may ignore this argument, and simply provide data whenever it
becomes available.  There is no need, for example to &quot;wait&quot; until
<code class="language-javascript">size</code> bytes are available before calling <a><code class="language-javascript">stream.push(chunk)</code></a>.

</p>
<h4>readable.push(chunk[, encoding])</h4>
<div class="signature"><ul>
<li><code class="language-javascript">chunk</code> <span class="type">Buffer | null | String</span> Chunk of data to push into the read queue</li>
<li><code class="language-javascript">encoding</code> <span class="type">String</span> Encoding of String chunks.  Must be a valid
Buffer encoding, such as <code class="language-javascript">&#39;utf8&#39;</code> or <code class="language-javascript">&#39;ascii&#39;</code></li>
<li>return <span class="type">Boolean</span> Whether or not more pushes should be performed</li>
</div></ul>
<p>Note: <strong>This function should be called by Readable implementors, NOT
by consumers of Readable streams.</strong>

</p>
<p>The <code class="language-javascript">_read()</code> function will not be called again until at least one
<code class="language-javascript">push(chunk)</code> call is made.

</p>
<p>The <code class="language-javascript">Readable</code> class works by putting data into a read queue to be
pulled out later by calling the <code class="language-javascript">read()</code> method when the <code class="language-javascript">&#39;readable&#39;</code>
event fires.

</p>
<p>The <code class="language-javascript">push()</code> method will explicitly insert some data into the read
queue.  If it is called with <code class="language-javascript">null</code> then it will signal the end of the
data (EOF).

</p>
<p>This API is designed to be as flexible as possible.  For example,
you may be wrapping a lower-level source which has some sort of
pause/resume mechanism, and a data callback.  In those cases, you
could wrap the low-level source object by doing something like this:

</p>
<pre><code class="javascript">// source is an object with readStop() and readStart() methods,
// and an `ondata` member that gets called when it has data, and
// an `onend` member that gets called when the data is over.

util.inherits(SourceWrapper, Readable);

function SourceWrapper(options) {
  Readable.call(this, options);

  this._source = getLowlevelSourceObject();
  var self = this;

  // Every time there&#39;s data, we push it into the internal buffer.
  this._source.ondata = function(chunk) {
    // if push() returns false, then we need to stop reading from source
    if (!self.push(chunk))
      self._source.readStop();
  };

  // When the source ends, we push the EOF-signaling `null` chunk
  this._source.onend = function() {
    self.push(null);
  };
}

// _read will be called when the stream wants to pull more data in
// the advisory size argument is ignored in this case.
SourceWrapper.prototype._read = function(size) {
  this._source.readStart();
};</code></pre>
<!--next-->
<h2>Class: stream.Writable</h2>
<!--type=class-->

<p><code class="language-javascript">stream.Writable</code> is an abstract class designed to be extended with an
underlying implementation of the <a><code class="language-javascript">_write(chunk, encoding, callback)</code></a> method.

</p>
<p>Please see above under <a>API for Stream Consumers</a> for how to consume
writable streams in your programs.  What follows is an explanation of
how to implement Writable streams in your programs.

</p>
<h4>new stream.Writable([options])</h4>
<div class="signature"><ul>
<li><code class="language-javascript">options</code> <span class="type">Object</span><ul>
<li><code class="language-javascript">highWaterMark</code> <span class="type">Number</span> Buffer level when <a><code class="language-javascript">write()</code></a> starts
returning false. Default=16kb, or 16 for <code class="language-javascript">objectMode</code> streams</li>
<li><code class="language-javascript">decodeStrings</code> <span class="type">Boolean</span> Whether or not to decode strings into
Buffers before passing them to <a><code class="language-javascript">_write()</code></a>.  Default=true</li>
<li><code class="language-javascript">objectMode</code> <span class="type">Boolean</span> Whether or not the <code class="language-javascript">write(anyObj)</code> is
a valid operation. If set you can write arbitrary data instead
of only <code class="language-javascript">Buffer</code> / <code class="language-javascript">String</code> data.  Default=false</li>
</ul>
</li>
</div></ul>
<p>In classes that extend the Writable class, make sure to call the
constructor so that the buffering settings can be properly
initialized.

</p>
<h4>writable._write(chunk, encoding, callback)</h4>
<div class="signature"><ul>
<li><code class="language-javascript">chunk</code> <span class="type">Buffer | String</span> The chunk to be written.  Will always
be a buffer unless the <code class="language-javascript">decodeStrings</code> option was set to <code class="language-javascript">false</code>.</li>
<li><code class="language-javascript">encoding</code> <span class="type">String</span> If the chunk is a string, then this is the
encoding type.  Ignore if chunk is a buffer.  Note that chunk will
<strong>always</strong> be a buffer unless the <code class="language-javascript">decodeStrings</code> option is
explicitly set to <code class="language-javascript">false</code>.</li>
<li><code class="language-javascript">callback</code> <span class="type">Function</span> Call this function (optionally with an error
argument) when you are done processing the supplied chunk.</li>
</div></ul>
<p>All Writable stream implementations must provide a <a><code class="language-javascript">_write()</code></a>
method to send data to the underlying resource.

</p>
<p>Note: <strong>This function MUST NOT be called directly.</strong>  It should be
implemented by child classes, and called by the internal Writable
class methods only.

</p>
<p>Call the callback using the standard <code class="language-javascript">callback(error)</code> pattern to
signal that the write completed successfully or with an error.

</p>
<p>If the <code class="language-javascript">decodeStrings</code> flag is set in the constructor options, then
<code class="language-javascript">chunk</code> may be a string rather than a Buffer, and <code class="language-javascript">encoding</code> will
indicate the sort of string that it is.  This is to support
implementations that have an optimized handling for certain string
data encodings.  If you do not explicitly set the <code class="language-javascript">decodeStrings</code>
option to <code class="language-javascript">false</code>, then you can safely ignore the <code class="language-javascript">encoding</code> argument,
and assume that <code class="language-javascript">chunk</code> will always be a Buffer.

</p>
<p>This method is prefixed with an underscore because it is internal to
the class that defines it, and should not be called directly by user
programs.  However, you <strong>are</strong> expected to override this method in
your own extension classes.

</p>
<!--next-->
<h2>writable._writev(chunks, callback)</h2>
<div class="signature"><ul>
<li><code class="language-javascript">chunks</code> <span class="type">Array</span> The chunks to be written.  Each chunk has following
format: <code class="language-javascript">{ chunk: ..., encoding: ... }</code>.</li>
<li><code class="language-javascript">callback</code> <span class="type">Function</span> Call this function (optionally with an error
argument) when you are done processing the supplied chunks.</li>
</div></ul>
<p>Note: <strong>This function MUST NOT be called directly.</strong>  It may be
implemented by child classes, and called by the internal Writable
class methods only.

</p>
<p>This function is completely optional to implement. In most cases it is
unnecessary.  If implemented, it will be called with all the chunks
that are buffered in the write queue.


</p>
<!--next-->
<h2>Class: stream.Duplex</h2>
<!--type=class-->

<p>A &quot;duplex&quot; stream is one that is both Readable and Writable, such as a
TCP socket connection.

</p>
<p>Note that <code class="language-javascript">stream.Duplex</code> is an abstract class designed to be extended
with an underlying implementation of the <code class="language-javascript">_read(size)</code> and
<a><code class="language-javascript">_write(chunk, encoding, callback)</code></a> methods as you would with a
Readable or Writable stream class.

</p>
<p>Since JavaScript doesn&#39;t have multiple prototypal inheritance, this
class prototypally inherits from Readable, and then parasitically from
Writable.  It is thus up to the user to implement both the lowlevel
<code class="language-javascript">_read(n)</code> method as well as the lowlevel
<a><code class="language-javascript">_write(chunk, encoding, callback)</code></a> method on extension duplex classes.

</p>
<h4>new stream.Duplex(options)</h4>
<div class="signature"><ul>
<li><code class="language-javascript">options</code> <span class="type">Object</span> Passed to both Writable and Readable
constructors. Also has the following fields:<ul>
<li><code class="language-javascript">allowHalfOpen</code> <span class="type">Boolean</span> Default=true.  If set to <code class="language-javascript">false</code>, then
the stream will automatically end the readable side when the
writable side ends and vice versa.</li>
<li><code class="language-javascript">readableObjectMode</code> <span class="type">Boolean</span> Default=false. Sets <code class="language-javascript">objectMode</code>
for readable side of the stream. Has no effect if <code class="language-javascript">objectMode</code>
is <code class="language-javascript">true</code>.</li>
<li><code class="language-javascript">writableObjectMode</code> <span class="type">Boolean</span> Default=false. Sets <code class="language-javascript">objectMode</code>
for writable side of the stream. Has no effect if <code class="language-javascript">objectMode</code>
is <code class="language-javascript">true</code>.</li>
</ul>
</li>
</div></ul>
<p>In classes that extend the Duplex class, make sure to call the
constructor so that the buffering settings can be properly
initialized.


</p>
<!--next-->
<h2>Class: stream.Transform</h2>
<p>A &quot;transform&quot; stream is a duplex stream where the output is causally
connected in some way to the input, such as a <a>zlib</a> stream or a
<a>crypto</a> stream.

</p>
<p>There is no requirement that the output be the same size as the input,
the same number of chunks, or arrive at the same time.  For example, a
Hash stream will only ever have a single chunk of output which is
provided when the input is ended.  A zlib stream will produce output
that is either much smaller or much larger than its input.

</p>
<p>Rather than implement the <a><code class="language-javascript">_read()</code></a> and <a><code class="language-javascript">_write()</code></a> methods, Transform
classes must implement the <code class="language-javascript">_transform()</code> method, and may optionally
also implement the <code class="language-javascript">_flush()</code> method.  (See below.)

</p>
<h4>new stream.Transform([options])</h4>
<div class="signature"><ul>
<li><code class="language-javascript">options</code> <span class="type">Object</span> Passed to both Writable and Readable
constructors.</li>
</div></ul>
<p>In classes that extend the Transform class, make sure to call the
constructor so that the buffering settings can be properly
initialized.

</p>
<h4>transform._transform(chunk, encoding, callback)</h4>
<div class="signature"><ul>
<li><code class="language-javascript">chunk</code> <span class="type">Buffer | String</span> The chunk to be transformed.  Will always
be a buffer unless the <code class="language-javascript">decodeStrings</code> option was set to <code class="language-javascript">false</code>.</li>
<li><code class="language-javascript">encoding</code> <span class="type">String</span> If the chunk is a string, then this is the
encoding type.  (Ignore if <code class="language-javascript">decodeStrings</code> chunk is a buffer.)</li>
<li><code class="language-javascript">callback</code> <span class="type">Function</span> Call this function (optionally with an error
argument and data) when you are done processing the supplied chunk.</li>
</div></ul>
<p>Note: <strong>This function MUST NOT be called directly.</strong>  It should be
implemented by child classes, and called by the internal Transform
class methods only.

</p>
<p>All Transform stream implementations must provide a <code class="language-javascript">_transform</code>
method to accept input and produce output.

</p>
<p><code class="language-javascript">_transform</code> should do whatever has to be done in this specific
Transform class, to handle the bytes being written, and pass them off
to the readable portion of the interface.  Do asynchronous I/O,
process things, and so on.

</p>
<p>Call <code class="language-javascript">transform.push(outputChunk)</code> 0 or more times to generate output
from this input chunk, depending on how much data you want to output
as a result of this chunk.

</p>
<p>Call the callback function only when the current chunk is completely
consumed.  Note that there may or may not be output as a result of any
particular input chunk. If you supply as the second argument to the
it will be passed to push method, in other words the following are
equivalent:

</p>
<pre><code class="javascript">transform.prototype._transform = function (data, encoding, callback) {
  this.push(data);
  callback();
}

transform.prototype._transform = function (data, encoding, callback) {
  callback(null, data);
}</code></pre>
<p>This method is prefixed with an underscore because it is internal to
the class that defines it, and should not be called directly by user
programs.  However, you <strong>are</strong> expected to override this method in
your own extension classes.

</p>
<h4>transform._flush(callback)</h4>
<div class="signature"><ul>
<li><code class="language-javascript">callback</code> <span class="type">Function</span> Call this function (optionally with an error
argument) when you are done flushing any remaining data.</li>
</div></ul>
<p>Note: <strong>This function MUST NOT be called directly.</strong>  It MAY be implemented
by child classes, and if so, will be called by the internal Transform
class methods only.

</p>
<p>In some cases, your transform operation may need to emit a bit more
data at the end of the stream.  For example, a <code class="language-javascript">Zlib</code> compression
stream will store up some internal state so that it can optimally
compress the output.  At the end, however, it needs to do the best it
can with what is left, so that the data will be complete.

</p>
<p>In those cases, you can implement a <code class="language-javascript">_flush</code> method, which will be
called at the very end, after all the written data is consumed, but
before emitting <code class="language-javascript">end</code> to signal the end of the readable side.  Just
like with <code class="language-javascript">_transform</code>, call <code class="language-javascript">transform.push(chunk)</code> zero or more
times, as appropriate, and call <code class="language-javascript">callback</code> when the flush operation is
complete.

</p>
<p>This method is prefixed with an underscore because it is internal to
the class that defines it, and should not be called directly by user
programs.  However, you <strong>are</strong> expected to override this method in
your own extension classes.

</p>
<h4>Events: &#39;finish&#39; and &#39;end&#39;</h4>
<p>The <a><code class="language-javascript">finish</code></a> and <a><code class="language-javascript">end</code></a> events are from the parent Writable
and Readable classes respectively. The <code class="language-javascript">finish</code> event is fired after
<code class="language-javascript">.end()</code> is called and all chunks have been processed by <code class="language-javascript">_transform</code>,
<code class="language-javascript">end</code> is fired after all data has been output which is after the callback
in <code class="language-javascript">_flush</code> has been called.

</p>
<h4>Example: <code class="language-javascript">SimpleProtocol</code> parser v2</h4>
<p>The example above of a simple protocol parser can be implemented
simply by using the higher level <a>Transform</a> stream class, similar to
the <code class="language-javascript">parseHeader</code> and <code class="language-javascript">SimpleProtocol v1</code> examples above.

</p>
<p>In this example, rather than providing the input as an argument, it
would be piped into the parser, which is a more idiomatic Node stream
approach.

</p>
<pre><code class="javascript">var util = require(&#39;util&#39;);
var Transform = require(&#39;stream&#39;).Transform;
util.inherits(SimpleProtocol, Transform);

function SimpleProtocol(options) {
  if (!(this instanceof SimpleProtocol))
    return new SimpleProtocol(options);

  Transform.call(this, options);
  this._inBody = false;
  this._sawFirstCr = false;
  this._rawHeader = [];
  this.header = null;
}

SimpleProtocol.prototype._transform = function(chunk, encoding, done) {
  if (!this._inBody) {
    // check if the chunk has a \n\n
    var split = -1;
    for (var i = 0; i &lt; chunk.length; i++) {
      if (chunk[i] === 10) { // &#39;\n&#39;
        if (this._sawFirstCr) {
          split = i;
          break;
        } else {
          this._sawFirstCr = true;
        }
      } else {
        this._sawFirstCr = false;
      }
    }

    if (split === -1) {
      // still waiting for the \n\n
      // stash the chunk, and try again.
      this._rawHeader.push(chunk);
    } else {
      this._inBody = true;
      var h = chunk.slice(0, split);
      this._rawHeader.push(h);
      var header = Buffer.concat(this._rawHeader).toString();
      try {
        this.header = JSON.parse(header);
      } catch (er) {
        this.emit(&#39;error&#39;, new Error(&#39;invalid simple protocol data&#39;));
        return;
      }
      // and let them know that we are done parsing the header.
      this.emit(&#39;header&#39;, this.header);

      // now, because we got some extra data, emit this first.
      this.push(chunk.slice(split));
    }
  } else {
    // from there on, just provide the data to our consumer as-is.
    this.push(chunk);
  }
  done();
};

// Usage:
// var parser = new SimpleProtocol();
// source.pipe(parser)
// Now parser is a readable stream that will emit &#39;header&#39;
// with the parsed header data.</code></pre>
<!--next-->
<h2>Class: stream.PassThrough</h2>
<p>This is a trivial implementation of a <a>Transform</a> stream that simply
passes the input bytes across to the output.  Its purpose is mainly
for examples and testing, but there are occasionally use cases where
it can come in handy as a building block for novel sorts of streams.


</p>
<!--next-->
<h2>Streams: Under the Hood</h2>
<!--next-->
<h2>Buffering</h2>
<p>Both Writable and Readable streams will buffer data on an internal
object called <code class="language-javascript">_writableState.buffer</code> or <code class="language-javascript">_readableState.buffer</code>,
respectively.

</p>
<p>The amount of data that will potentially be buffered depends on the
<code class="language-javascript">highWaterMark</code> option which is passed into the constructor.

</p>
<p>Buffering in Readable streams happens when the implementation calls
<a><code class="language-javascript">stream.push(chunk)</code></a>.  If the consumer of the Stream does not call
<code class="language-javascript">stream.read()</code>, then the data will sit in the internal queue until it
is consumed.

</p>
<p>Buffering in Writable streams happens when the user calls
<a><code class="language-javascript">stream.write(chunk)</code></a> repeatedly, even when <code class="language-javascript">write()</code> returns <code class="language-javascript">false</code>.

</p>
<p>The purpose of streams, especially with the <code class="language-javascript">pipe()</code> method, is to
limit the buffering of data to acceptable levels, so that sources and
destinations of varying speed will not overwhelm the available memory.

</p>
<!--next-->
<h2><code class="language-javascript">stream.read(0)</code></h2>
<p>There are some cases where you want to trigger a refresh of the
underlying readable stream mechanisms, without actually consuming any
data.  In that case, you can call <code class="language-javascript">stream.read(0)</code>, which will always
return null.

</p>
<p>If the internal read buffer is below the <code class="language-javascript">highWaterMark</code>, and the
stream is not currently reading, then calling <code class="language-javascript">read(0)</code> will trigger
a low-level <code class="language-javascript">_read</code> call.

</p>
<p>There is almost never a need to do this.  However, you will see some
cases in Node&#39;s internals where this is done, particularly in the
Readable stream class internals.

</p>
<!--next-->
<h2><code class="language-javascript">stream.push(&#39;&#39;)</code></h2>
<p>Pushing a zero-byte string or Buffer (when not in <a>Object mode</a>) has an
interesting side effect.  Because it <em>is</em> a call to
<a><code class="language-javascript">stream.push()</code></a>, it will end the <code class="language-javascript">reading</code> process.  However, it
does <em>not</em> add any data to the readable buffer, so there&#39;s nothing for
a user to consume.

</p>
<p>Very rarely, there are cases where you have no data to provide now,
but the consumer of your stream (or, perhaps, another bit of your own
code) will know when to check again, by calling <code class="language-javascript">stream.read(0)</code>.  In
those cases, you <em>may</em> call <code class="language-javascript">stream.push(&#39;&#39;)</code>.

</p>
<p>So far, the only use case for this functionality is in the
<a>tls.CryptoStream</a> class, which is deprecated in Node v0.12.  If you
find that you have to use <code class="language-javascript">stream.push(&#39;&#39;)</code>, please consider another
approach, because it almost certainly indicates that something is
horribly wrong.

</p>
<!--next-->
<h2>Compatibility with Older Node Versions</h2>
<p>In versions of Node prior to v0.10, the Readable stream interface was
simpler, but also less powerful and less useful.

</p>
<ul>
<li>Rather than waiting for you to call the <code class="language-javascript">read()</code> method, <code class="language-javascript">&#39;data&#39;</code>
events would start emitting immediately.  If you needed to do some
I/O to decide how to handle data, then you had to store the chunks
in some kind of buffer so that they would not be lost.</li>
<li>The <a><code class="language-javascript">pause()</code></a> method was advisory, rather than guaranteed.  This
meant that you still had to be prepared to receive <code class="language-javascript">&#39;data&#39;</code> events
even when the stream was in a paused state.</li>
</ul>
<p>In Node v0.10, the Readable class described below was added.  For
backwards compatibility with older Node programs, Readable streams
switch into &quot;flowing mode&quot; when a <code class="language-javascript">&#39;data&#39;</code> event handler is added, or
when the <a><code class="language-javascript">resume()</code></a> method is called.  The effect is that, even if
you are not using the new <code class="language-javascript">read()</code> method and <code class="language-javascript">&#39;readable&#39;</code> event, you
no longer have to worry about losing <code class="language-javascript">&#39;data&#39;</code> chunks.

</p>
<p>Most programs will continue to function normally.  However, this
introduces an edge case in the following conditions:

</p>
<ul>
<li>No <a><code class="language-javascript">&#39;data&#39;</code> event</a> handler is added.</li>
<li>The <a><code class="language-javascript">resume()</code></a> method is never called.</li>
<li>The stream is not piped to any writable destination.</li>
</ul>
<p>For example, consider the following code:

</p>
<pre><code class="javascript">// WARNING!  BROKEN!
net.createServer(function(socket) {

  // we add an &#39;end&#39; method, but never consume the data
  socket.on(&#39;end&#39;, function() {
    // It will never get here.
    socket.end(&#39;I got your message (but didnt read it)\n&#39;);
  });

}).listen(1337);</code></pre>
<p>In versions of node prior to v0.10, the incoming message data would be
simply discarded.  However, in Node v0.10 and beyond, the socket will
remain paused forever.

</p>
<p>The workaround in this situation is to call the <code class="language-javascript">resume()</code> method to
start the flow of data:

</p>
<pre><code class="javascript">// Workaround
net.createServer(function(socket) {

  socket.on(&#39;end&#39;, function() {
    socket.end(&#39;I got your message (but didnt read it)\n&#39;);
  });

  // start the flow of data, discarding it.
  socket.resume();

}).listen(1337);</code></pre>
<p>In addition to new Readable streams switching into flowing mode,
pre-v0.10 style streams can be wrapped in a Readable class using the
<code class="language-javascript">wrap()</code> method.


</p>
<!--next-->
<h2>Object Mode</h2>
<p>Normally, Streams operate on Strings and Buffers exclusively.

</p>
<p>Streams that are in <strong>object mode</strong> can emit generic JavaScript values
other than Buffers and Strings.

</p>
<p>A Readable stream in object mode will always return a single item from
a call to <code class="language-javascript">stream.read(size)</code>, regardless of what the size argument
is.

</p>
<p>A Writable stream in object mode will always ignore the <code class="language-javascript">encoding</code>
argument to <code class="language-javascript">stream.write(data, encoding)</code>.

</p>
<p>The special value <code class="language-javascript">null</code> still retains its special value for object
mode streams.  That is, for object mode readable streams, <code class="language-javascript">null</code> as a
return value from <code class="language-javascript">stream.read()</code> indicates that there is no more
data, and <a><code class="language-javascript">stream.push(null)</code></a> will signal the end of stream data
(<code class="language-javascript">EOF</code>).

</p>
<p>No streams in Node core are object mode streams.  This pattern is only
used by userland streaming libraries.

</p>
<p>You should set <code class="language-javascript">objectMode</code> in your stream child class constructor on
the options object.  Setting <code class="language-javascript">objectMode</code> mid-stream is not safe.

</p>
<p>For Duplex streams <code class="language-javascript">objectMode</code> can be set exclusively for readable or
writable side with <code class="language-javascript">readableObjectMode</code> and <code class="language-javascript">writableObjectMode</code>
respectively. These options can be used to implement parsers and
serializers with Transform streams.

</p>
<pre><code class="javascript">var util = require(&#39;util&#39;);
var StringDecoder = require(&#39;string_decoder&#39;).StringDecoder;
var Transform = require(&#39;stream&#39;).Transform;
util.inherits(JSONParseStream, Transform);

// Gets \n-delimited JSON string data, and emits the parsed objects
function JSONParseStream() {
  if (!(this instanceof JSONParseStream))
    return new JSONParseStream();

  Transform.call(this, { readableObjectMode : true });

  this._buffer = &#39;&#39;;
  this._decoder = new StringDecoder(&#39;utf8&#39;);
}

JSONParseStream.prototype._transform = function(chunk, encoding, cb) {
  this._buffer += this._decoder.write(chunk);
  // split on newlines
  var lines = this._buffer.split(/\r?\n/);
  // keep the last partial line buffered
  this._buffer = lines.pop();
  for (var l = 0; l &lt; lines.length; l++) {
    var line = lines[l];
    try {
      var obj = JSON.parse(line);
    } catch (er) {
      this.emit(&#39;error&#39;, er);
      return;
    }
    // push the parsed object out to the readable consumer
    this.push(obj);
  }
  cb();
};

JSONParseStream.prototype._flush = function(cb) {
  // Just handle any leftover
  var rem = this._buffer.trim();
  if (rem) {
    try {
      var obj = JSON.parse(rem);
    } catch (er) {
      this.emit(&#39;error&#39;, er);
      return;
    }
    // push the parsed object out to the readable consumer
    this.push(obj);
  }
  cb();
};</code></pre>
<!--next-->
<h2>Crypto</h2>
<pre class="stability">Stability: 2 - Unstable; API changes are being discussed for
future versions.  Breaking changes will be minimized.  See below.</pre><p>Use <code class="language-javascript">require(&#39;crypto&#39;)</code> to access this module.

</p>
<p>The crypto module offers a way of encapsulating secure credentials to be
used as part of a secure HTTPS net or http connection.

</p>
<p>It also offers a set of wrappers for OpenSSL&#39;s hash, hmac, cipher,
decipher, sign and verify methods.


</p>
<!--next-->
<h2>crypto.setEngine(engine[, flags])</h2>
<p>Load and set engine for some/all OpenSSL functions (selected by flags).

</p>
<p><code class="language-javascript">engine</code> could be either an id or a path to the to the engine&#39;s shared library.

</p>
<p><code class="language-javascript">flags</code> is optional and has <code class="language-javascript">ENGINE_METHOD_ALL</code> value by default. It could take
one of or mix of following flags (defined in <code class="language-javascript">constants</code> module):

</p>
<ul>
<li><code class="language-javascript">ENGINE_METHOD_RSA</code></li>
<li><code class="language-javascript">ENGINE_METHOD_DSA</code></li>
<li><code class="language-javascript">ENGINE_METHOD_DH</code></li>
<li><code class="language-javascript">ENGINE_METHOD_RAND</code></li>
<li><code class="language-javascript">ENGINE_METHOD_ECDH</code></li>
<li><code class="language-javascript">ENGINE_METHOD_ECDSA</code></li>
<li><code class="language-javascript">ENGINE_METHOD_CIPHERS</code></li>
<li><code class="language-javascript">ENGINE_METHOD_DIGESTS</code></li>
<li><code class="language-javascript">ENGINE_METHOD_STORE</code></li>
<li><code class="language-javascript">ENGINE_METHOD_PKEY_METH</code></li>
<li><code class="language-javascript">ENGINE_METHOD_PKEY_ASN1_METH</code></li>
<li><code class="language-javascript">ENGINE_METHOD_ALL</code></li>
<li><code class="language-javascript">ENGINE_METHOD_NONE</code></li>
</ul>
<!--next-->
<h2>crypto.getCiphers()</h2>
<p>Returns an array with the names of the supported ciphers.

</p>
<p>Example:

</p>
<pre><code class="language-javascript">var ciphers = crypto.getCiphers();
console.log(ciphers); // [&#39;AES-128-CBC&#39;, &#39;AES-128-CBC-HMAC-SHA1&#39;, ...]</code></pre>
<!--next-->
<h2>crypto.getHashes()</h2>
<p>Returns an array with the names of the supported hash algorithms.

</p>
<p>Example:

</p>
<pre><code class="language-javascript">var hashes = crypto.getHashes();
console.log(hashes); // [&#39;sha&#39;, &#39;sha1&#39;, &#39;sha1WithRSAEncryption&#39;, ...]</code></pre>
<!--next-->
<h2>crypto.createCredentials(details)</h2>
<pre class="stability">Stability: 0 - Deprecated. Use <a>tls.createSecureContext</a> instead.</pre><p>Creates a credentials object, with the optional details being a
dictionary with keys:

</p>
<ul>
<li><code class="language-javascript">pfx</code> : A string or buffer holding the PFX or PKCS12 encoded private
key, certificate and CA certificates</li>
<li><code class="language-javascript">key</code> : A string holding the PEM encoded private key</li>
<li><code class="language-javascript">passphrase</code> : A string of passphrase for the private key or pfx</li>
<li><code class="language-javascript">cert</code> : A string holding the PEM encoded certificate</li>
<li><code class="language-javascript">ca</code> : Either a string or list of strings of PEM encoded CA
certificates to trust.</li>
<li><code class="language-javascript">crl</code> : Either a string or list of strings of PEM encoded CRLs
(Certificate Revocation List)</li>
<li><code class="language-javascript">ciphers</code>: A string describing the ciphers to use or exclude.
Consult
<a>http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT</a>
for details on the format.</li>
</ul>
<p>If no &#39;ca&#39; details are given, then node.js will use the default
publicly trusted list of CAs as given in
</p>
<p><a>http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt</a>.


</p>
<!--next-->
<h2>crypto.createHash(algorithm)</h2>
<p>Creates and returns a hash object, a cryptographic hash with the given
algorithm which can be used to generate hash digests.

</p>
<p><code class="language-javascript">algorithm</code> is dependent on the available algorithms supported by the
version of OpenSSL on the platform. Examples are <code class="language-javascript">&#39;sha1&#39;</code>, <code class="language-javascript">&#39;md5&#39;</code>,
<code class="language-javascript">&#39;sha256&#39;</code>, <code class="language-javascript">&#39;sha512&#39;</code>, etc.  On recent releases, <code class="language-javascript">openssl
list-message-digest-algorithms</code> will display the available digest
algorithms.

</p>
<p>Example: this program that takes the sha1 sum of a file

</p>
<pre><code class="language-javascript">var filename = process.argv[2];
var crypto = require(&#39;crypto&#39;);
var fs = require(&#39;fs&#39;);

var shasum = crypto.createHash(&#39;sha1&#39;);

var s = fs.ReadStream(filename);
s.on(&#39;data&#39;, function(d) {
  shasum.update(d);
});

s.on(&#39;end&#39;, function() {
  var d = shasum.digest(&#39;hex&#39;);
  console.log(d + &#39;  &#39; + filename);
});</code></pre>
<!--next-->
<h2>Class: Hash</h2>
<p>The class for creating hash digests of data.

</p>
<p>It is a <a>stream</a> that is both readable and writable.  The
written data is used to compute the hash.  Once the writable side of
the stream is ended, use the <code class="language-javascript">read()</code> method to get the computed hash
digest.  The legacy <code class="language-javascript">update</code> and <code class="language-javascript">digest</code> methods are also supported.

</p>
<p>Returned by <code class="language-javascript">crypto.createHash</code>.

</p>
<!--next-->
<h2>hash.update(data[, input_encoding])</h2>
<p>Updates the hash content with the given <code class="language-javascript">data</code>, the encoding of which
is given in <code class="language-javascript">input_encoding</code> and can be <code class="language-javascript">&#39;utf8&#39;</code>, <code class="language-javascript">&#39;ascii&#39;</code> or
<code class="language-javascript">&#39;binary&#39;</code>.  If no encoding is provided and the input is a string an
encoding of <code class="language-javascript">&#39;binary&#39;</code> is enforced. If <code class="language-javascript">data</code> is a <code class="language-javascript">Buffer</code> then
<code class="language-javascript">input_encoding</code> is ignored.

</p>
<p>This can be called many times with new data as it is streamed.

</p>
<!--next-->
<h2>hash.digest([encoding])</h2>
<p>Calculates the digest of all of the passed data to be hashed.  The
<code class="language-javascript">encoding</code> can be <code class="language-javascript">&#39;hex&#39;</code>, <code class="language-javascript">&#39;binary&#39;</code> or <code class="language-javascript">&#39;base64&#39;</code>.  If no encoding
is provided, then a buffer is returned.

</p>
<p>Note: <code class="language-javascript">hash</code> object can not be used after <code class="language-javascript">digest()</code> method has been
called.


</p>
<!--next-->
<h2>crypto.createHmac(algorithm, key)</h2>
<p>Creates and returns a hmac object, a cryptographic hmac with the given
algorithm and key.

</p>
<p>It is a <a>stream</a> that is both readable and writable.  The
written data is used to compute the hmac.  Once the writable side of
the stream is ended, use the <code class="language-javascript">read()</code> method to get the computed
digest.  The legacy <code class="language-javascript">update</code> and <code class="language-javascript">digest</code> methods are also supported.

</p>
<p><code class="language-javascript">algorithm</code> is dependent on the available algorithms supported by
OpenSSL - see createHash above.  <code class="language-javascript">key</code> is the hmac key to be used.

</p>
<!--next-->
<h2>Class: Hmac</h2>
<p>Class for creating cryptographic hmac content.

</p>
<p>Returned by <code class="language-javascript">crypto.createHmac</code>.

</p>
<!--next-->
<h2>hmac.update(data)</h2>
<p>Update the hmac content with the given <code class="language-javascript">data</code>.  This can be called
many times with new data as it is streamed.

</p>
<!--next-->
<h2>hmac.digest([encoding])</h2>
<p>Calculates the digest of all of the passed data to the hmac.  The
<code class="language-javascript">encoding</code> can be <code class="language-javascript">&#39;hex&#39;</code>, <code class="language-javascript">&#39;binary&#39;</code> or <code class="language-javascript">&#39;base64&#39;</code>.  If no encoding
is provided, then a buffer is returned.

</p>
<p>Note: <code class="language-javascript">hmac</code> object can not be used after <code class="language-javascript">digest()</code> method has been
called.


</p>
<!--next-->
<h2>crypto.createCipher(algorithm, password)</h2>
<p>Creates and returns a cipher object, with the given algorithm and
password.

</p>
<p><code class="language-javascript">algorithm</code> is dependent on OpenSSL, examples are <code class="language-javascript">&#39;aes192&#39;</code>, etc.  On
recent releases, <code class="language-javascript">openssl list-cipher-algorithms</code> will display the
available cipher algorithms.  <code class="language-javascript">password</code> is used to derive key and IV,
which must be a <code class="language-javascript">&#39;binary&#39;</code> encoded string or a <a>buffer</a>.

</p>
<p>It is a <a>stream</a> that is both readable and writable.  The
written data is used to compute the hash.  Once the writable side of
the stream is ended, use the <code class="language-javascript">read()</code> method to get the enciphered
contents.  The legacy <code class="language-javascript">update</code> and <code class="language-javascript">final</code> methods are also supported.

</p>
<p>Note: <code class="language-javascript">createCipher</code> derives keys with the OpenSSL function <a>EVP_BytesToKey</a>
with the digest algorithm set to MD5, one iteration, and no salt. The lack of
salt allows dictionary attacks as the same password always creates the same key.
The low iteration count and non-cryptographically secure hash algorithm allow
passwords to be tested very rapidly.

</p>
<p>In line with OpenSSL&#39;s recommendation to use pbkdf2 instead of EVP_BytesToKey it
is recommended you derive a key and iv yourself with <a>crypto.pbkdf2</a> and to
then use <a>createCipheriv()</a> to create the cipher stream.

</p>
<!--next-->
<h2>crypto.createCipheriv(algorithm, key, iv)</h2>
<p>Creates and returns a cipher object, with the given algorithm, key and
iv.

</p>
<p><code class="language-javascript">algorithm</code> is the same as the argument to <code class="language-javascript">createCipher()</code>.  <code class="language-javascript">key</code> is
the raw key used by the algorithm.  <code class="language-javascript">iv</code> is an <a>initialization
vector</a>.

</p>
<p><code class="language-javascript">key</code> and <code class="language-javascript">iv</code> must be <code class="language-javascript">&#39;binary&#39;</code> encoded strings or
<a>buffers</a>.

</p>
<!--next-->
<h2>Class: Cipher</h2>
<p>Class for encrypting data.

</p>
<p>Returned by <code class="language-javascript">crypto.createCipher</code> and <code class="language-javascript">crypto.createCipheriv</code>.

</p>
<p>Cipher objects are <a>streams</a> that are both readable and
writable.  The written plain text data is used to produce the
encrypted data on the readable side.  The legacy <code class="language-javascript">update</code> and <code class="language-javascript">final</code>
methods are also supported.

</p>
<!--next-->
<h2>cipher.update(data[, input_encoding][, output_encoding])</h2>
<p>Updates the cipher with <code class="language-javascript">data</code>, the encoding of which is given in
<code class="language-javascript">input_encoding</code> and can be <code class="language-javascript">&#39;utf8&#39;</code>, <code class="language-javascript">&#39;ascii&#39;</code> or <code class="language-javascript">&#39;binary&#39;</code>.  If no
encoding is provided, then a buffer is expected.
If <code class="language-javascript">data</code> is a <code class="language-javascript">Buffer</code> then <code class="language-javascript">input_encoding</code> is ignored.

</p>
<p>The <code class="language-javascript">output_encoding</code> specifies the output format of the enciphered
data, and can be <code class="language-javascript">&#39;binary&#39;</code>, <code class="language-javascript">&#39;base64&#39;</code> or <code class="language-javascript">&#39;hex&#39;</code>.  If no encoding is
provided, then a buffer is returned.

</p>
<p>Returns the enciphered contents, and can be called many times with new
data as it is streamed.

</p>
<!--next-->
<h2>cipher.final([output_encoding])</h2>
<p>Returns any remaining enciphered contents, with <code class="language-javascript">output_encoding</code>
being one of: <code class="language-javascript">&#39;binary&#39;</code>, <code class="language-javascript">&#39;base64&#39;</code> or <code class="language-javascript">&#39;hex&#39;</code>.  If no encoding is
provided, then a buffer is returned.

</p>
<p>Note: <code class="language-javascript">cipher</code> object can not be used after <code class="language-javascript">final()</code> method has been
called.

</p>
<!--next-->
<h2>cipher.setAutoPadding(auto_padding=true)</h2>
<p>You can disable automatic padding of the input data to block size. If
<code class="language-javascript">auto_padding</code> is false, the length of the entire input data must be a
multiple of the cipher&#39;s block size or <code class="language-javascript">final</code> will fail.  Useful for
non-standard padding, e.g. using <code class="language-javascript">0x0</code> instead of PKCS padding. You
must call this before <code class="language-javascript">cipher.final</code>.

</p>
<!--next-->
<h2>cipher.getAuthTag()</h2>
<p>For authenticated encryption modes (currently supported: GCM), this
method returns a <code class="language-javascript">Buffer</code> that represents the <em>authentication tag</em> that
has been computed from the given data. Should be called after
encryption has been completed using the <code class="language-javascript">final</code> method!

</p>
<!--next-->
<h2>cipher.setAAD(buffer)</h2>
<p>For authenticated encryption modes (currently supported: GCM), this
method sets the value used for the additional authenticated data (AAD) input
parameter.


</p>
<!--next-->
<h2>crypto.createDecipher(algorithm, password)</h2>
<p>Creates and returns a decipher object, with the given algorithm and
key.  This is the mirror of the <a>createCipher()</a> above.

</p>
<!--next-->
<h2>crypto.createDecipheriv(algorithm, key, iv)</h2>
<p>Creates and returns a decipher object, with the given algorithm, key
and iv.  This is the mirror of the <a>createCipheriv()</a> above.

</p>
<!--next-->
<h2>Class: Decipher</h2>
<p>Class for decrypting data.

</p>
<p>Returned by <code class="language-javascript">crypto.createDecipher</code> and <code class="language-javascript">crypto.createDecipheriv</code>.

</p>
<p>Decipher objects are <a>streams</a> that are both readable and
writable.  The written enciphered data is used to produce the
plain-text data on the the readable side.  The legacy <code class="language-javascript">update</code> and
<code class="language-javascript">final</code> methods are also supported.

</p>
<!--next-->
<h2>decipher.update(data[, input_encoding][, output_encoding])</h2>
<p>Updates the decipher with <code class="language-javascript">data</code>, which is encoded in <code class="language-javascript">&#39;binary&#39;</code>,
<code class="language-javascript">&#39;base64&#39;</code> or <code class="language-javascript">&#39;hex&#39;</code>.  If no encoding is provided, then a buffer is
expected.
If <code class="language-javascript">data</code> is a <code class="language-javascript">Buffer</code> then <code class="language-javascript">input_encoding</code> is ignored.

</p>
<p>The <code class="language-javascript">output_decoding</code> specifies in what format to return the
deciphered plaintext: <code class="language-javascript">&#39;binary&#39;</code>, <code class="language-javascript">&#39;ascii&#39;</code> or <code class="language-javascript">&#39;utf8&#39;</code>.  If no
encoding is provided, then a buffer is returned.

</p>
<!--next-->
<h2>decipher.final([output_encoding])</h2>
<p>Returns any remaining plaintext which is deciphered, with
<code class="language-javascript">output_encoding</code> being one of: <code class="language-javascript">&#39;binary&#39;</code>, <code class="language-javascript">&#39;ascii&#39;</code> or <code class="language-javascript">&#39;utf8&#39;</code>.  If
no encoding is provided, then a buffer is returned.

</p>
<p>Note: <code class="language-javascript">decipher</code> object can not be used after <code class="language-javascript">final()</code> method has been
called.

</p>
<!--next-->
<h2>decipher.setAutoPadding(auto_padding=true)</h2>
<p>You can disable auto padding if the data has been encrypted without
standard block padding to prevent <code class="language-javascript">decipher.final</code> from checking and
removing it. Can only work if the input data&#39;s length is a multiple of
the ciphers block size. You must call this before streaming data to
<code class="language-javascript">decipher.update</code>.

</p>
<!--next-->
<h2>decipher.setAuthTag(buffer)</h2>
<p>For authenticated encryption modes (currently supported: GCM), this
method must be used to pass in the received <em>authentication tag</em>.
If no tag is provided or if the ciphertext has been tampered with,
<code class="language-javascript">final</code> will throw, thus indicating that the ciphertext should
be discarded due to failed authentication.

</p>
<!--next-->
<h2>decipher.setAAD(buffer)</h2>
<p>For authenticated encryption modes (currently supported: GCM), this
method sets the value used for the additional authenticated data (AAD) input
parameter.


</p>
<!--next-->
<h2>crypto.createSign(algorithm)</h2>
<p>Creates and returns a signing object, with the given algorithm.  On
recent OpenSSL releases, <code class="language-javascript">openssl list-public-key-algorithms</code> will
display the available signing algorithms. Examples are <code class="language-javascript">&#39;RSA-SHA256&#39;</code>.

</p>
<!--next-->
<h2>Class: Sign</h2>
<p>Class for generating signatures.

</p>
<p>Returned by <code class="language-javascript">crypto.createSign</code>.

</p>
<p>Sign objects are writable <a>streams</a>.  The written data is
used to generate the signature.  Once all of the data has been
written, the <code class="language-javascript">sign</code> method will return the signature.  The legacy
<code class="language-javascript">update</code> method is also supported.

</p>
<!--next-->
<h2>sign.update(data)</h2>
<p>Updates the sign object with data.  This can be called many times
with new data as it is streamed.

</p>
<!--next-->
<h2>sign.sign(private_key[, output_format])</h2>
<p>Calculates the signature on all the updated data passed through the
sign.

</p>
<p><code class="language-javascript">private_key</code> can be an object or a string. If <code class="language-javascript">private_key</code> is a string, it is
treated as the key with no passphrase.

</p>
<p><code class="language-javascript">private_key</code>:

</p>
<ul>
<li><code class="language-javascript">key</code> : A string holding the PEM encoded private key</li>
<li><code class="language-javascript">passphrase</code> : A string of passphrase for the private key</li>
</ul>
<p>Returns the signature in <code class="language-javascript">output_format</code> which can be <code class="language-javascript">&#39;binary&#39;</code>,
<code class="language-javascript">&#39;hex&#39;</code> or <code class="language-javascript">&#39;base64&#39;</code>. If no encoding is provided, then a buffer is
returned.

</p>
<p>Note: <code class="language-javascript">sign</code> object can not be used after <code class="language-javascript">sign()</code> method has been
called.

</p>
<!--next-->
<h2>crypto.createVerify(algorithm)</h2>
<p>Creates and returns a verification object, with the given algorithm.
This is the mirror of the signing object above.

</p>
<!--next-->
<h2>Class: Verify</h2>
<p>Class for verifying signatures.

</p>
<p>Returned by <code class="language-javascript">crypto.createVerify</code>.

</p>
<p>Verify objects are writable <a>streams</a>.  The written data
is used to validate against the supplied signature.  Once all of the
data has been written, the <code class="language-javascript">verify</code> method will return true if the
supplied signature is valid.  The legacy <code class="language-javascript">update</code> method is also
supported.

</p>
<!--next-->
<h2>verifier.update(data)</h2>
<p>Updates the verifier object with data.  This can be called many times
with new data as it is streamed.

</p>
<!--next-->
<h2>verifier.verify(object, signature[, signature_format])</h2>
<p>Verifies the signed data by using the <code class="language-javascript">object</code> and <code class="language-javascript">signature</code>.
<code class="language-javascript">object</code> is  a string containing a PEM encoded object, which can be
one of RSA public key, DSA public key, or X.509 certificate.
<code class="language-javascript">signature</code> is the previously calculated signature for the data, in
the <code class="language-javascript">signature_format</code> which can be <code class="language-javascript">&#39;binary&#39;</code>, <code class="language-javascript">&#39;hex&#39;</code> or <code class="language-javascript">&#39;base64&#39;</code>.
If no encoding is specified, then a buffer is expected.

</p>
<p>Returns true or false depending on the validity of the signature for
the data and public key.

</p>
<p>Note: <code class="language-javascript">verifier</code> object can not be used after <code class="language-javascript">verify()</code> method has been
called.

</p>
<!--next-->
<h2>crypto.createDiffieHellman(prime_length[, generator])</h2>
<p>Creates a Diffie-Hellman key exchange object and generates a prime of
<code class="language-javascript">prime_length</code> bits and using an optional specific numeric <code class="language-javascript">generator</code>.
If no <code class="language-javascript">generator</code> is specified, then <code class="language-javascript">2</code> is used.

</p>
<!--next-->
<h2>crypto.createDiffieHellman(prime[, prime_encoding][, generator][, generator_encoding])</h2>
<p>Creates a Diffie-Hellman key exchange object using the supplied <code class="language-javascript">prime</code> and an
optional specific <code class="language-javascript">generator</code>.
<code class="language-javascript">generator</code> can be a number, string, or Buffer.
If no <code class="language-javascript">generator</code> is specified, then <code class="language-javascript">2</code> is used.
<code class="language-javascript">prime_encoding</code> and <code class="language-javascript">generator_encoding</code> can be <code class="language-javascript">&#39;binary&#39;</code>, <code class="language-javascript">&#39;hex&#39;</code>, or <code class="language-javascript">&#39;base64&#39;</code>.
If no <code class="language-javascript">prime_encoding</code> is specified, then a Buffer is expected for <code class="language-javascript">prime</code>.
If no <code class="language-javascript">generator_encoding</code> is specified, then a Buffer is expected for <code class="language-javascript">generator</code>.

</p>
<!--next-->
<h2>Class: DiffieHellman</h2>
<p>The class for creating Diffie-Hellman key exchanges.

</p>
<p>Returned by <code class="language-javascript">crypto.createDiffieHellman</code>.

</p>
<!--next-->
<h2>diffieHellman.verifyError</h2>
<p>A bit field containing any warnings and/or errors as a result of a check performed
during initialization. The following values are valid for this property
(defined in <code class="language-javascript">constants</code> module):

</p>
<ul>
<li><code class="language-javascript">DH_CHECK_P_NOT_SAFE_PRIME</code></li>
<li><code class="language-javascript">DH_CHECK_P_NOT_PRIME</code></li>
<li><code class="language-javascript">DH_UNABLE_TO_CHECK_GENERATOR</code></li>
<li><code class="language-javascript">DH_NOT_SUITABLE_GENERATOR</code></li>
</ul>
<!--next-->
<h2>diffieHellman.generateKeys([encoding])</h2>
<p>Generates private and public Diffie-Hellman key values, and returns
the public key in the specified encoding. This key should be
transferred to the other party. Encoding can be <code class="language-javascript">&#39;binary&#39;</code>, <code class="language-javascript">&#39;hex&#39;</code>,
or <code class="language-javascript">&#39;base64&#39;</code>.  If no encoding is provided, then a buffer is returned.

</p>
<!--next-->
<h2>diffieHellman.computeSecret(other_public_key[, input_encoding][, output_encoding])</h2>
<p>Computes the shared secret using <code class="language-javascript">other_public_key</code> as the other
party&#39;s public key and returns the computed shared secret. Supplied
key is interpreted using specified <code class="language-javascript">input_encoding</code>, and secret is
encoded using specified <code class="language-javascript">output_encoding</code>. Encodings can be
<code class="language-javascript">&#39;binary&#39;</code>, <code class="language-javascript">&#39;hex&#39;</code>, or <code class="language-javascript">&#39;base64&#39;</code>. If the input encoding is not
provided, then a buffer is expected.

</p>
<p>If no output encoding is given, then a buffer is returned.

</p>
<!--next-->
<h2>diffieHellman.getPrime([encoding])</h2>
<p>Returns the Diffie-Hellman prime in the specified encoding, which can
be <code class="language-javascript">&#39;binary&#39;</code>, <code class="language-javascript">&#39;hex&#39;</code>, or <code class="language-javascript">&#39;base64&#39;</code>. If no encoding is provided,
then a buffer is returned.

</p>
<!--next-->
<h2>diffieHellman.getGenerator([encoding])</h2>
<p>Returns the Diffie-Hellman generator in the specified encoding, which can
be <code class="language-javascript">&#39;binary&#39;</code>, <code class="language-javascript">&#39;hex&#39;</code>, or <code class="language-javascript">&#39;base64&#39;</code>. If no encoding is provided,
then a buffer is returned.

</p>
<!--next-->
<h2>diffieHellman.getPublicKey([encoding])</h2>
<p>Returns the Diffie-Hellman public key in the specified encoding, which
can be <code class="language-javascript">&#39;binary&#39;</code>, <code class="language-javascript">&#39;hex&#39;</code>, or <code class="language-javascript">&#39;base64&#39;</code>. If no encoding is provided,
then a buffer is returned.

</p>
<!--next-->
<h2>diffieHellman.getPrivateKey([encoding])</h2>
<p>Returns the Diffie-Hellman private key in the specified encoding,
which can be <code class="language-javascript">&#39;binary&#39;</code>, <code class="language-javascript">&#39;hex&#39;</code>, or <code class="language-javascript">&#39;base64&#39;</code>. If no encoding is
provided, then a buffer is returned.

</p>
<!--next-->
<h2>diffieHellman.setPublicKey(public_key[, encoding])</h2>
<p>Sets the Diffie-Hellman public key. Key encoding can be <code class="language-javascript">&#39;binary&#39;</code>,
<code class="language-javascript">&#39;hex&#39;</code> or <code class="language-javascript">&#39;base64&#39;</code>. If no encoding is provided, then a buffer is
expected.

</p>
<!--next-->
<h2>diffieHellman.setPrivateKey(private_key[, encoding])</h2>
<p>Sets the Diffie-Hellman private key. Key encoding can be <code class="language-javascript">&#39;binary&#39;</code>,
<code class="language-javascript">&#39;hex&#39;</code> or <code class="language-javascript">&#39;base64&#39;</code>. If no encoding is provided, then a buffer is
expected.

</p>
<!--next-->
<h2>crypto.getDiffieHellman(group_name)</h2>
<p>Creates a predefined Diffie-Hellman key exchange object.  The
supported groups are: <code class="language-javascript">&#39;modp1&#39;</code>, <code class="language-javascript">&#39;modp2&#39;</code>, <code class="language-javascript">&#39;modp5&#39;</code> (defined in <a>RFC
2412</a>) and <code class="language-javascript">&#39;modp14&#39;</code>, <code class="language-javascript">&#39;modp15&#39;</code>, <code class="language-javascript">&#39;modp16&#39;</code>, <code class="language-javascript">&#39;modp17&#39;</code>,
<code class="language-javascript">&#39;modp18&#39;</code> (defined in <a>RFC 3526</a>).  The returned object mimics the
interface of objects created by <a>crypto.createDiffieHellman()</a>
above, but will not allow to change the keys (with
<a>diffieHellman.setPublicKey()</a> for example).  The advantage of using
this routine is that the parties don&#39;t have to generate nor exchange
group modulus beforehand, saving both processor and communication
time.

</p>
<p>Example (obtaining a shared secret):

</p>
<pre><code class="language-javascript">var crypto = require(&#39;crypto&#39;);
var alice = crypto.getDiffieHellman(&#39;modp5&#39;);
var bob = crypto.getDiffieHellman(&#39;modp5&#39;);

alice.generateKeys();
bob.generateKeys();

var alice_secret = alice.computeSecret(bob.getPublicKey(), null, &#39;hex&#39;);
var bob_secret = bob.computeSecret(alice.getPublicKey(), null, &#39;hex&#39;);

/* alice_secret and bob_secret should be the same */
console.log(alice_secret == bob_secret);</code></pre>
<!--next-->
<h2>crypto.createECDH(curve_name)</h2>
<p>Creates a Elliptic Curve (EC) Diffie-Hellman key exchange object using a
predefined curve specified by <code class="language-javascript">curve_name</code> string.

</p>
<!--next-->
<h2>Class: ECDH</h2>
<p>The class for creating EC Diffie-Hellman key exchanges.

</p>
<p>Returned by <code class="language-javascript">crypto.createECDH</code>.

</p>
<!--next-->
<h2>ECDH.generateKeys([encoding[, format]])</h2>
<p>Generates private and public EC Diffie-Hellman key values, and returns
the public key in the specified format and encoding. This key should be
transferred to the other party.

</p>
<p>Format specifies point encoding and can be <code class="language-javascript">&#39;compressed&#39;</code>, <code class="language-javascript">&#39;uncompressed&#39;</code>, or
<code class="language-javascript">&#39;hybrid&#39;</code>. If no format is provided - the point will be returned in
<code class="language-javascript">&#39;uncompressed&#39;</code> format.

</p>
<p>Encoding can be <code class="language-javascript">&#39;binary&#39;</code>, <code class="language-javascript">&#39;hex&#39;</code>, or <code class="language-javascript">&#39;base64&#39;</code>. If no encoding is provided,
then a buffer is returned.

</p>
<!--next-->
<h2>ECDH.computeSecret(other_public_key[, input_encoding][, output_encoding])</h2>
<p>Computes the shared secret using <code class="language-javascript">other_public_key</code> as the other
party&#39;s public key and returns the computed shared secret. Supplied
key is interpreted using specified <code class="language-javascript">input_encoding</code>, and secret is
encoded using specified <code class="language-javascript">output_encoding</code>. Encodings can be
<code class="language-javascript">&#39;binary&#39;</code>, <code class="language-javascript">&#39;hex&#39;</code>, or <code class="language-javascript">&#39;base64&#39;</code>. If the input encoding is not
provided, then a buffer is expected.

</p>
<p>If no output encoding is given, then a buffer is returned.

</p>
<!--next-->
<h2>ECDH.getPublicKey([encoding[, format]])</h2>
<p>Returns the EC Diffie-Hellman public key in the specified encoding and format.

</p>
<p>Format specifies point encoding and can be <code class="language-javascript">&#39;compressed&#39;</code>, <code class="language-javascript">&#39;uncompressed&#39;</code>, or
<code class="language-javascript">&#39;hybrid&#39;</code>. If no format is provided - the point will be returned in
<code class="language-javascript">&#39;uncompressed&#39;</code> format.

</p>
<p>Encoding can be <code class="language-javascript">&#39;binary&#39;</code>, <code class="language-javascript">&#39;hex&#39;</code>, or <code class="language-javascript">&#39;base64&#39;</code>. If no encoding is provided,
then a buffer is returned.

</p>
<!--next-->
<h2>ECDH.getPrivateKey([encoding])</h2>
<p>Returns the EC Diffie-Hellman private key in the specified encoding,
which can be <code class="language-javascript">&#39;binary&#39;</code>, <code class="language-javascript">&#39;hex&#39;</code>, or <code class="language-javascript">&#39;base64&#39;</code>. If no encoding is
provided, then a buffer is returned.

</p>
<!--next-->
<h2>ECDH.setPublicKey(public_key[, encoding])</h2>
<p>Sets the EC Diffie-Hellman public key. Key encoding can be <code class="language-javascript">&#39;binary&#39;</code>,
<code class="language-javascript">&#39;hex&#39;</code> or <code class="language-javascript">&#39;base64&#39;</code>. If no encoding is provided, then a buffer is
expected.

</p>
<!--next-->
<h2>ECDH.setPrivateKey(private_key[, encoding])</h2>
<p>Sets the EC Diffie-Hellman private key. Key encoding can be <code class="language-javascript">&#39;binary&#39;</code>,
<code class="language-javascript">&#39;hex&#39;</code> or <code class="language-javascript">&#39;base64&#39;</code>. If no encoding is provided, then a buffer is
expected.

</p>
<p>Example (obtaining a shared secret):

</p>
<pre><code class="language-javascript">var crypto = require(&#39;crypto&#39;);
var alice = crypto.createECDH(&#39;secp256k1&#39;);
var bob = crypto.createECDH(&#39;secp256k1&#39;);

alice.generateKeys();
bob.generateKeys();

var alice_secret = alice.computeSecret(bob.getPublicKey(), null, &#39;hex&#39;);
var bob_secret = bob.computeSecret(alice.getPublicKey(), null, &#39;hex&#39;);

/* alice_secret and bob_secret should be the same */
console.log(alice_secret == bob_secret);</code></pre>
<!--next-->
<h2>crypto.pbkdf2(password, salt, iterations, keylen[, digest], callback)</h2>
<p>Asynchronous PBKDF2 function.  Applies the selected HMAC digest function
(default: SHA1) to derive a key of the requested length from the password,
salt and number of iterations.  The callback gets two arguments:
<code class="language-javascript">(err, derivedKey)</code>.

</p>
<p>Example:

</p>
<pre><code class="language-javascript">crypto.pbkdf2(&#39;secret&#39;, &#39;salt&#39;, 4096, 512, &#39;sha256&#39;, function(err, key) {
  if (err)
    throw err;
  console.log(key.toString(&#39;hex&#39;));  // &#39;c5e478d...1469e50&#39;
});</code></pre>
<p>You can get a list of supported digest functions with
<a>crypto.getHashes()</a>.

</p>
<!--next-->
<h2>crypto.pbkdf2Sync(password, salt, iterations, keylen[, digest])</h2>
<p>Synchronous PBKDF2 function.  Returns derivedKey or throws error.

</p>
<!--next-->
<h2>crypto.randomBytes(size[, callback])</h2>
<p>Generates cryptographically strong pseudo-random data. Usage:

</p>
<pre><code class="language-javascript">// async
crypto.randomBytes(256, function(ex, buf) {
  if (ex) throw ex;
  console.log(&#39;Have %d bytes of random data: %s&#39;, buf.length, buf);
});

// sync
try {
  var buf = crypto.randomBytes(256);
  console.log(&#39;Have %d bytes of random data: %s&#39;, buf.length, buf);
} catch (ex) {
  // handle error
  // most likely, entropy sources are drained
}</code></pre>
<p>NOTE: Will throw error or invoke callback with error, if there is not enough
accumulated entropy to generate cryptographically strong data. In other words,
<code class="language-javascript">crypto.randomBytes</code> without callback will not block even if all entropy sources
are drained.

</p>
<!--next-->
<h2>crypto.pseudoRandomBytes(size[, callback])</h2>
<p>Generates <em>non</em>-cryptographically strong pseudo-random data. The data
returned will be unique if it is sufficiently long, but is not
necessarily unpredictable. For this reason, the output of this
function should never be used where unpredictability is important,
such as in the generation of encryption keys.

</p>
<p>Usage is otherwise identical to <code class="language-javascript">crypto.randomBytes</code>.

</p>
<!--next-->
<h2>Class: Certificate</h2>
<p>The class used for working with signed public key &amp; challenges. The most
common usage for this series of functions is when dealing with the <code class="language-javascript">&lt;keygen&gt;</code>
element. <a>http://www.openssl.org/docs/apps/spkac.html</a>

</p>
<p>Returned by <code class="language-javascript">crypto.Certificate</code>.

</p>
<!--next-->
<h2>Certificate.verifySpkac(spkac)</h2>
<p>Returns true of false based on the validity of the SPKAC.

</p>
<!--next-->
<h2>Certificate.exportChallenge(spkac)</h2>
<p>Exports the encoded public key from the supplied SPKAC.

</p>
<!--next-->
<h2>Certificate.exportPublicKey(spkac)</h2>
<p>Exports the encoded challenge associated with the SPKAC.

</p>
<!--next-->
<h2>crypto.publicEncrypt(public_key, buffer)</h2>
<p>Encrypts <code class="language-javascript">buffer</code> with <code class="language-javascript">public_key</code>. Only RSA is currently supported.

</p>
<p><code class="language-javascript">public_key</code> can be an object or a string. If <code class="language-javascript">public_key</code> is a string, it is
treated as the key with no passphrase and will use <code class="language-javascript">RSA_PKCS1_OAEP_PADDING</code>.

</p>
<p><code class="language-javascript">public_key</code>:

</p>
<ul>
<li><code class="language-javascript">key</code> : A string holding the PEM encoded private key</li>
<li><code class="language-javascript">padding</code> : An optional padding value, one of the following:<ul>
<li><code class="language-javascript">constants.RSA_NO_PADDING</code></li>
<li><code class="language-javascript">constants.RSA_PKCS1_PADDING</code></li>
<li><code class="language-javascript">constants.RSA_PKCS1_OAEP_PADDING</code></li>
</ul>
</li>
</ul>
<p>NOTE: All paddings are defined in <code class="language-javascript">constants</code> module.

</p>
<!--next-->
<h2>crypto.privateDecrypt(private_key, buffer)</h2>
<p>Decrypts <code class="language-javascript">buffer</code> with <code class="language-javascript">private_key</code>.

</p>
<p><code class="language-javascript">private_key</code> can be an object or a string. If <code class="language-javascript">private_key</code> is a string, it is
treated as the key with no passphrase and will use <code class="language-javascript">RSA_PKCS1_OAEP_PADDING</code>.

</p>
<p><code class="language-javascript">private_key</code>:

</p>
<ul>
<li><code class="language-javascript">key</code> : A string holding the PEM encoded private key</li>
<li><code class="language-javascript">passphrase</code> : An optional string of passphrase for the private key</li>
<li><code class="language-javascript">padding</code> : An optional padding value, one of the following:<ul>
<li><code class="language-javascript">constants.RSA_NO_PADDING</code></li>
<li><code class="language-javascript">constants.RSA_PKCS1_PADDING</code></li>
<li><code class="language-javascript">constants.RSA_PKCS1_OAEP_PADDING</code></li>
</ul>
</li>
</ul>
<p>NOTE: All paddings are defined in <code class="language-javascript">constants</code> module.

</p>
<!--next-->
<h2>crypto.DEFAULT_ENCODING</h2>
<p>The default encoding to use for functions that can take either strings
or buffers.  The default value is <code class="language-javascript">&#39;buffer&#39;</code>, which makes it default
to using Buffer objects.  This is here to make the crypto module more
easily compatible with legacy programs that expected <code class="language-javascript">&#39;binary&#39;</code> to be
the default encoding.

</p>
<p>Note that new programs will probably expect buffers, so only use this
as a temporary measure.

</p>
<!--next-->
<h2>Recent API Changes</h2>
<p>The Crypto module was added to Node before there was the concept of a
unified Stream API, and before there were Buffer objects for handling
binary data.

</p>
<p>As such, the streaming classes don&#39;t have the typical methods found on
other Node classes, and many methods accepted and returned
Binary-encoded strings by default rather than Buffers.  This was
changed to use Buffers by default instead.

</p>
<p>This is a breaking change for some use cases, but not all.

</p>
<p>For example, if you currently use the default arguments to the Sign
class, and then pass the results to the Verify class, without ever
inspecting the data, then it will continue to work as before.  Where
you once got a binary string and then presented the binary string to
the Verify object, you&#39;ll now get a Buffer, and present the Buffer to
the Verify object.

</p>
<p>However, if you were doing things with the string data that will not
work properly on Buffers (such as, concatenating them, storing in
databases, etc.), or you are passing binary strings to the crypto
functions without an encoding argument, then you will need to start
providing encoding arguments to specify which encoding you&#39;d like to
use.  To switch to the previous style of using binary strings by
default, set the <code class="language-javascript">crypto.DEFAULT_ENCODING</code> field to &#39;binary&#39;.  Note
that new programs will probably expect buffers, so only use this as a
temporary measure.


</p>
<!--next-->
<h2>TLS (SSL)</h2>
<pre class="stability">Stability: 3 - Stable</pre><p>Use <code class="language-javascript">require(&#39;tls&#39;)</code> to access this module.

</p>
<p>The <code class="language-javascript">tls</code> module uses OpenSSL to provide Transport Layer Security and/or
Secure Socket Layer: encrypted stream communication.

</p>
<p>TLS/SSL is a public/private key infrastructure. Each client and each
server must have a private key. A private key is created like this:

</p>
<pre><code class="language-javascript">openssl genrsa -out ryans-key.pem 2048</code></pre>
<p>All servers and some clients need to have a certificate. Certificates are public
keys signed by a Certificate Authority or self-signed. The first step to
getting a certificate is to create a &quot;Certificate Signing Request&quot; (CSR)
file. This is done with:

</p>
<pre><code class="language-javascript">openssl req -new -sha256 -key ryans-key.pem -out ryans-csr.pem</code></pre>
<p>To create a self-signed certificate with the CSR, do this:

</p>
<pre><code class="language-javascript">openssl x509 -req -in ryans-csr.pem -signkey ryans-key.pem -out ryans-cert.pem</code></pre>
<p>Alternatively you can send the CSR to a Certificate Authority for signing.

</p>
<p>(TODO: docs on creating a CA, for now interested users should just look at
<code class="language-javascript">test/fixtures/keys/Makefile</code> in the Node source code)

</p>
<p>To create .pfx or .p12, do this:

</p>
<pre><code class="language-javascript">openssl pkcs12 -export -in agent5-cert.pem -inkey agent5-key.pem \
    -certfile ca-cert.pem -out agent5.pfx</code></pre>
<ul>
<li><code class="language-javascript">in</code>:  certificate</li>
<li><code class="language-javascript">inkey</code>: private key</li>
<li><code class="language-javascript">certfile</code>: all CA certs concatenated in one file like
<code class="language-javascript">cat ca1-cert.pem ca2-cert.pem &gt; ca-cert.pem</code></li>
</ul>
<!--next-->
<h2>Protocol support</h2>
<p>Node.js is compiled with SSLv2 and SSLv3 protocol support by default, but these
protocols are <strong>disabled</strong>. They are considered insecure and could be easily
compromised as was shown by <a>CVE-2014-3566</a>. However, in some situations, it
may cause problems with legacy clients/servers (such as Internet Explorer 6).
If you wish to enable SSLv2 or SSLv3, run node with the <code class="language-javascript">--enable-ssl2</code> or
<code class="language-javascript">--enable-ssl3</code> flag respectively.  In future versions of Node.js SSLv2 and
SSLv3 will not be compiled in by default.

</p>
<p>There is a way to force node into using SSLv3 or SSLv2 only mode by explicitly
specifying <code class="language-javascript">secureProtocol</code> to <code class="language-javascript">&#39;SSLv3_method&#39;</code> or <code class="language-javascript">&#39;SSLv2_method&#39;</code>.

</p>
<p>The default protocol method Node.js uses is <code class="language-javascript">SSLv23_method</code> which would be more
accurately named <code class="language-javascript">AutoNegotiate_method</code>. This method will try and negotiate
from the highest level down to whatever the client supports.  To provide a
secure default, Node.js (since v0.10.33) explicitly disables the use of SSLv3
and SSLv2 by setting the <code class="language-javascript">secureOptions</code> to be
<code class="language-javascript">SSL_OP_NO_SSLv3|SSL_OP_NO_SSLv2</code> (again, unless you have passed
<code class="language-javascript">--enable-ssl3</code>, or <code class="language-javascript">--enable-ssl2</code>, or <code class="language-javascript">SSLv3_method</code> as <code class="language-javascript">secureProtocol</code>).

</p>
<p>If you have set <code class="language-javascript">secureOptions</code> to anything, we will not override your
options.

</p>
<p>The ramifications of this behavior change:

</p>
<ul>
<li>If your application is behaving as a secure server, clients who are <code class="language-javascript">SSLv3</code>
only will now not be able to appropriately negotiate a connection and will be
refused. In this case your server will emit a <code class="language-javascript">clientError</code> event. The error
message will include <code class="language-javascript">&#39;wrong version number&#39;</code>.</li>
<li>If your application is behaving as a secure client and communicating with a
server that doesn&#39;t support methods more secure than SSLv3 then your connection
won&#39;t be able to negotiate and will fail. In this case your client will emit a
an <code class="language-javascript">error</code> event. The error message will include <code class="language-javascript">&#39;wrong version number&#39;</code>.</li>
</ul>
<!--next-->
<h2>Client-initiated renegotiation attack mitigation</h2>
<!-- type=misc -->

<p>The TLS protocol lets the client renegotiate certain aspects of the TLS session.
Unfortunately, session renegotiation requires a disproportional amount of
server-side resources, which makes it a potential vector for denial-of-service
attacks.

</p>
<p>To mitigate this, renegotiations are limited to three times every 10 minutes. An
error is emitted on the <a>tls.TLSSocket</a> instance when the threshold is
exceeded. The limits are configurable:

</p>
<ul>
<li><p><code class="language-javascript">tls.CLIENT_RENEG_LIMIT</code>: renegotiation limit, default is 3.</p>
</li>
<li><p><code class="language-javascript">tls.CLIENT_RENEG_WINDOW</code>: renegotiation window in seconds, default is
10 minutes.</p>
</li>
</ul>
<p>Don&#39;t change the defaults unless you know what you are doing.

</p>
<p>To test your server, connect to it with <code class="language-javascript">openssl s_client -connect address:port</code>
and tap <code class="language-javascript">R&lt;CR&gt;</code> (that&#39;s the letter <code class="language-javascript">R</code> followed by a carriage return) a few
times.


</p>
<!--next-->
<h2>NPN and SNI</h2>
<!-- type=misc -->

<p>NPN (Next Protocol Negotiation) and SNI (Server Name Indication) are TLS
handshake extensions allowing you:

</p>
<ul>
<li>NPN - to use one TLS server for multiple protocols (HTTP, SPDY)</li>
<li>SNI - to use one TLS server for multiple hostnames with different SSL
certificates.</li>
</ul>
<!--next-->
<h2>Perfect Forward Secrecy</h2>
<!-- type=misc -->

<p>The term &quot;<a>Forward Secrecy</a>&quot; or &quot;Perfect Forward Secrecy&quot; describes a feature of
key-agreement (i.e. key-exchange) methods. Practically it means that even if the
private key of a (your) server is compromised, communication can only be
decrypted by eavesdroppers if they manage to obtain the key-pair specifically
generated for each session.

</p>
<p>This is achieved by randomly generating a key pair for key-agreement on every
handshake (in contrary to the same key for all sessions). Methods implementing
this technique, thus offering Perfect Forward Secrecy, are called &quot;ephemeral&quot;.

</p>
<p>Currently two methods are commonly used to achieve Perfect Forward Secrecy (note
the character &quot;E&quot; appended to the traditional abbreviations):

</p>
<ul>
<li><a>DHE</a> - An ephemeral version of the Diffie Hellman key-agreement protocol.</li>
<li><a>ECDHE</a> - An ephemeral version of the Elliptic Curve Diffie Hellman
key-agreement protocol.</li>
</ul>
<p>Ephemeral methods may have some performance drawbacks, because key generation
is expensive.


</p>
<!--next-->
<h2>tls.getCiphers()</h2>
<p>Returns an array with the names of the supported SSL ciphers.

</p>
<p>Example:

</p>
<pre><code class="language-javascript">var ciphers = tls.getCiphers();
console.log(ciphers); // [&#39;AES128-SHA&#39;, &#39;AES256-SHA&#39;, ...]</code></pre>
<!--next-->
<h2>tls.createServer(options[, secureConnectionListener])</h2>
<p>Creates a new <a>tls.Server</a>.  The <code class="language-javascript">connectionListener</code> argument is
automatically set as a listener for the <a>secureConnection</a> event.  The
<code class="language-javascript">options</code> object has these possibilities:

</p>
<ul>
<li><p><code class="language-javascript">pfx</code>: A string or <code class="language-javascript">Buffer</code> containing the private key, certificate and
CA certs of the server in PFX or PKCS12 format. (Mutually exclusive with
the <code class="language-javascript">key</code>, <code class="language-javascript">cert</code> and <code class="language-javascript">ca</code> options.)</p>
</li>
<li><p><code class="language-javascript">key</code>: A string or <code class="language-javascript">Buffer</code> containing the private key of the server in
PEM format. (Could be an array of keys). (Required)</p>
</li>
<li><p><code class="language-javascript">passphrase</code>: A string of passphrase for the private key or pfx.</p>
</li>
<li><p><code class="language-javascript">cert</code>: A string or <code class="language-javascript">Buffer</code> containing the certificate key of the server in
PEM format. (Could be an array of certs). (Required)</p>
</li>
<li><p><code class="language-javascript">ca</code>: An array of strings or <code class="language-javascript">Buffer</code>s of trusted certificates in PEM
format. If this is omitted several well known &quot;root&quot; CAs will be used,
like VeriSign. These are used to authorize connections.</p>
</li>
<li><p><code class="language-javascript">crl</code> : Either a string or list of strings of PEM encoded CRLs (Certificate
Revocation List)</p>
</li>
<li><p><code class="language-javascript">ciphers</code>: A string describing the ciphers to use or exclude.</p>
<p>To mitigate <a>BEAST attacks</a> it is recommended that you use this option in
conjunction with the <code class="language-javascript">honorCipherOrder</code> option described below to
prioritize the non-CBC cipher.</p>
<p>Defaults to
<code class="language-javascript">ECDHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA256:AES128-GCM-SHA256:RC4:HIGH:!MD5:!aNULL</code>.
Consult the <a>OpenSSL cipher list format documentation</a> for details
on the format.</p>
<p><code class="language-javascript">ECDHE-RSA-AES128-SHA256</code>, <code class="language-javascript">DHE-RSA-AES128-SHA256</code> and
<code class="language-javascript">AES128-GCM-SHA256</code> are TLS v1.2 ciphers and used when node.js is
linked against OpenSSL 1.0.1 or newer, such as the bundled version
of OpenSSL.  Note that it is still possible for a TLS v1.2 client
to negotiate a weaker cipher unless <code class="language-javascript">honorCipherOrder</code> is enabled.</p>
<p><code class="language-javascript">RC4</code> is used as a fallback for clients that speak on older version of
the TLS protocol.  <code class="language-javascript">RC4</code> has in recent years come under suspicion and
should be considered compromised for anything that is truly sensitive.
It is speculated that state-level actors possess the ability to break it.</p>
<p><strong>NOTE</strong>: Previous revisions of this section suggested <code class="language-javascript">AES256-SHA</code> as an
acceptable cipher. Unfortunately, <code class="language-javascript">AES256-SHA</code> is a CBC cipher and therefore
susceptible to <a>BEAST attacks</a>. Do <em>not</em> use it.</p>
</li>
<li><p><code class="language-javascript">ecdhCurve</code>: A string describing a named curve to use for ECDH key agreement
or false to disable ECDH.</p>
<p>Defaults to <code class="language-javascript">prime256v1</code>. Consult <a>RFC 4492</a> for more details.</p>
</li>
<li><p><code class="language-javascript">dhparam</code>: DH parameter file to use for DHE key agreement. Use
<code class="language-javascript">openssl dhparam</code> command to create it. If the file is invalid to
load, it is silently discarded.</p>
</li>
<li><p><code class="language-javascript">handshakeTimeout</code>: Abort the connection if the SSL/TLS handshake does not
finish in this many milliseconds. The default is 120 seconds.</p>
<p>A <code class="language-javascript">&#39;clientError&#39;</code> is emitted on the <code class="language-javascript">tls.Server</code> object whenever a handshake
times out.</p>
</li>
<li><p><code class="language-javascript">honorCipherOrder</code> : When choosing a cipher, use the server&#39;s preferences
instead of the client preferences.</p>
<p>Although, this option is disabled by default, it is <em>recommended</em> that you
use this option in conjunction with the <code class="language-javascript">ciphers</code> option to mitigate
BEAST attacks.</p>
<p>Note: If SSLv2 is used, the server will send its list of preferences to the
client, and the client chooses the cipher.  Support for SSLv2 is disabled
unless node.js was configured with <code class="language-javascript">./configure --with-sslv2</code>.</p>
</li>
<li><p><code class="language-javascript">requestCert</code>: If <code class="language-javascript">true</code> the server will request a certificate from
clients that connect and attempt to verify that certificate. Default:
<code class="language-javascript">false</code>.</p>
</li>
<li><p><code class="language-javascript">rejectUnauthorized</code>: If <code class="language-javascript">true</code> the server will reject any connection
which is not authorized with the list of supplied CAs. This option only
has an effect if <code class="language-javascript">requestCert</code> is <code class="language-javascript">true</code>. Default: <code class="language-javascript">false</code>.</p>
</li>
<li><p><code class="language-javascript">checkServerIdentity(servername, cert)</code>: Provide an override for checking
server&#39;s hostname against the certificate. Should return an error if verification
fails. Return <code class="language-javascript">undefined</code> if passing.</p>
</li>
<li><p><code class="language-javascript">NPNProtocols</code>: An array or <code class="language-javascript">Buffer</code> of possible NPN protocols. (Protocols
should be ordered by their priority).</p>
</li>
<li><p><code class="language-javascript">SNICallback(servername, cb)</code>: A function that will be called if client
supports SNI TLS extension. Two argument will be passed to it: <code class="language-javascript">servername</code>,
and <code class="language-javascript">cb</code>. <code class="language-javascript">SNICallback</code> should invoke <code class="language-javascript">cb(null, ctx)</code>, where <code class="language-javascript">ctx</code> is a
SecureContext instance.
(You can use <code class="language-javascript">tls.createSecureContext(...)</code> to get proper
SecureContext). If <code class="language-javascript">SNICallback</code> wasn&#39;t provided - default callback with
high-level API will be used (see below).</p>
</li>
<li><p><code class="language-javascript">sessionTimeout</code>: An integer specifying the seconds after which TLS
session identifiers and TLS session tickets created by the server are
timed out. See <a>SSL_CTX_set_timeout</a> for more details.</p>
</li>
<li><p><code class="language-javascript">ticketKeys</code>: A 48-byte <code class="language-javascript">Buffer</code> instance consisting of 16-byte prefix,
16-byte hmac key, 16-byte AES key. You could use it to accept tls session
tickets on multiple instances of tls server.</p>
<p>NOTE: Automatically shared between <code class="language-javascript">cluster</code> module workers.</p>
</li>
<li><p><code class="language-javascript">sessionIdContext</code>: A string containing an opaque identifier for session
resumption. If <code class="language-javascript">requestCert</code> is <code class="language-javascript">true</code>, the default is MD5 hash value
generated from command-line. Otherwise, the default is not provided.</p>
</li>
<li><p><code class="language-javascript">secureProtocol</code>: The SSL method to use, e.g. <code class="language-javascript">SSLv3_method</code> to force
SSL version 3. The possible values depend on your installation of
OpenSSL and are defined in the constant <a>SSL_METHODS</a>.</p>
</li>
<li><p><code class="language-javascript">secureOptions</code>: Set server options. For example, to disable the SSLv3
protocol set the <code class="language-javascript">SSL_OP_NO_SSLv3</code> flag. See <a>SSL_CTX_set_options</a>
for all available options.</p>
</li>
</ul>
<p>Here is a simple example echo server:

</p>
<pre><code class="language-javascript">var tls = require(&#39;tls&#39;);
var fs = require(&#39;fs&#39;);

var options = {
  key: fs.readFileSync(&#39;server-key.pem&#39;),
  cert: fs.readFileSync(&#39;server-cert.pem&#39;),

  // This is necessary only if using the client certificate authentication.
  requestCert: true,

  // This is necessary only if the client uses the self-signed certificate.
  ca: [ fs.readFileSync(&#39;client-cert.pem&#39;) ]
};

var server = tls.createServer(options, function(socket) {
  console.log(&#39;server connected&#39;,
              socket.authorized ? &#39;authorized&#39; : &#39;unauthorized&#39;);
  socket.write(&quot;welcome!\n&quot;);
  socket.setEncoding(&#39;utf8&#39;);
  socket.pipe(socket);
});
server.listen(8000, function() {
  console.log(&#39;server bound&#39;);
});</code></pre>
<p>Or

</p>
<pre><code class="language-javascript">var tls = require(&#39;tls&#39;);
var fs = require(&#39;fs&#39;);

var options = {
  pfx: fs.readFileSync(&#39;server.pfx&#39;),

  // This is necessary only if using the client certificate authentication.
  requestCert: true,

};

var server = tls.createServer(options, function(socket) {
  console.log(&#39;server connected&#39;,
              socket.authorized ? &#39;authorized&#39; : &#39;unauthorized&#39;);
  socket.write(&quot;welcome!\n&quot;);
  socket.setEncoding(&#39;utf8&#39;);
  socket.pipe(socket);
});
server.listen(8000, function() {
  console.log(&#39;server bound&#39;);
});</code></pre>
<p>You can test this server by connecting to it with <code class="language-javascript">openssl s_client</code>:


</p>
<pre><code class="language-javascript">openssl s_client -connect 127.0.0.1:8000</code></pre>
<!--next-->
<h2>tls.connect(options[, callback])</h2>
<!--next-->
<h2>tls.connect(port[, host][, options][, callback])</h2>
<p>Creates a new client connection to the given <code class="language-javascript">port</code> and <code class="language-javascript">host</code> (old API) or
<code class="language-javascript">options.port</code> and <code class="language-javascript">options.host</code>. (If <code class="language-javascript">host</code> is omitted, it defaults to
<code class="language-javascript">localhost</code>.) <code class="language-javascript">options</code> should be an object which specifies:

</p>
<ul>
<li><p><code class="language-javascript">host</code>: Host the client should connect to</p>
</li>
<li><p><code class="language-javascript">port</code>: Port the client should connect to</p>
</li>
<li><p><code class="language-javascript">socket</code>: Establish secure connection on a given socket rather than
creating a new socket. If this option is specified, <code class="language-javascript">host</code> and <code class="language-javascript">port</code>
are ignored.</p>
</li>
<li><p><code class="language-javascript">path</code>: Creates unix socket connection to path. If this option is
specified, <code class="language-javascript">host</code> and <code class="language-javascript">port</code> are ignored.</p>
</li>
<li><p><code class="language-javascript">pfx</code>: A string or <code class="language-javascript">Buffer</code> containing the private key, certificate and
CA certs of the client in PFX or PKCS12 format.</p>
</li>
<li><p><code class="language-javascript">key</code>: A string or <code class="language-javascript">Buffer</code> containing the private key of the client in
PEM format. (Could be an array of keys).</p>
</li>
<li><p><code class="language-javascript">passphrase</code>: A string of passphrase for the private key or pfx.</p>
</li>
<li><p><code class="language-javascript">cert</code>: A string or <code class="language-javascript">Buffer</code> containing the certificate key of the client in
PEM format. (Could be an array of certs).</p>
</li>
<li><p><code class="language-javascript">ca</code>: An array of strings or <code class="language-javascript">Buffer</code>s of trusted certificates in PEM
format. If this is omitted several well known &quot;root&quot; CAs will be used,
like VeriSign. These are used to authorize connections.</p>
</li>
<li><p><code class="language-javascript">rejectUnauthorized</code>: If <code class="language-javascript">true</code>, the server certificate is verified against
the list of supplied CAs. An <code class="language-javascript">&#39;error&#39;</code> event is emitted if verification
fails; <code class="language-javascript">err.code</code> contains the OpenSSL error code. Default: <code class="language-javascript">true</code>.</p>
</li>
<li><p><code class="language-javascript">NPNProtocols</code>: An array of strings or <code class="language-javascript">Buffer</code>s containing supported NPN
protocols. <code class="language-javascript">Buffer</code>s should have following format: <code class="language-javascript">0x05hello0x05world</code>,
where first byte is next protocol name&#39;s length. (Passing array should
usually be much simpler: <code class="language-javascript">[&#39;hello&#39;, &#39;world&#39;]</code>.)</p>
</li>
<li><p><code class="language-javascript">servername</code>: Servername for SNI (Server Name Indication) TLS extension.</p>
</li>
<li><p><code class="language-javascript">secureProtocol</code>: The SSL method to use, e.g. <code class="language-javascript">SSLv3_method</code> to force
SSL version 3. The possible values depend on your installation of
OpenSSL and are defined in the constant <a>SSL_METHODS</a>.</p>
</li>
<li><p><code class="language-javascript">session</code>: A <code class="language-javascript">Buffer</code> instance, containing TLS session.</p>
</li>
</ul>
<p>The <code class="language-javascript">callback</code> parameter will be added as a listener for the
<a>&#39;secureConnect&#39;</a> event.

</p>
<p><code class="language-javascript">tls.connect()</code> returns a <a>tls.TLSSocket</a> object.

</p>
<p>Here is an example of a client of echo server as described previously:

</p>
<pre><code class="language-javascript">var tls = require(&#39;tls&#39;);
var fs = require(&#39;fs&#39;);

var options = {
  // These are necessary only if using the client certificate authentication
  key: fs.readFileSync(&#39;client-key.pem&#39;),
  cert: fs.readFileSync(&#39;client-cert.pem&#39;),

  // This is necessary only if the server uses the self-signed certificate
  ca: [ fs.readFileSync(&#39;server-cert.pem&#39;) ]
};

var socket = tls.connect(8000, options, function() {
  console.log(&#39;client connected&#39;,
              socket.authorized ? &#39;authorized&#39; : &#39;unauthorized&#39;);
  process.stdin.pipe(socket);
  process.stdin.resume();
});
socket.setEncoding(&#39;utf8&#39;);
socket.on(&#39;data&#39;, function(data) {
  console.log(data);
});
socket.on(&#39;end&#39;, function() {
  server.close();
});</code></pre>
<p>Or

</p>
<pre><code class="language-javascript">var tls = require(&#39;tls&#39;);
var fs = require(&#39;fs&#39;);

var options = {
  pfx: fs.readFileSync(&#39;client.pfx&#39;)
};

var socket = tls.connect(8000, options, function() {
  console.log(&#39;client connected&#39;,
              socket.authorized ? &#39;authorized&#39; : &#39;unauthorized&#39;);
  process.stdin.pipe(socket);
  process.stdin.resume();
});
socket.setEncoding(&#39;utf8&#39;);
socket.on(&#39;data&#39;, function(data) {
  console.log(data);
});
socket.on(&#39;end&#39;, function() {
  server.close();
});</code></pre>
<!--next-->
<h2>Class: tls.TLSSocket</h2>
<p>Wrapper for instance of <a>net.Socket</a>, replaces internal socket read/write
routines to perform transparent encryption/decryption of incoming/outgoing data.

</p>
<!--next-->
<h2>new tls.TLSSocket(socket, options)</h2>
<p>Construct a new TLSSocket object from existing TCP socket.

</p>
<p><code class="language-javascript">socket</code> is an instance of <a>net.Socket</a>

</p>
<p><code class="language-javascript">options</code> is an object that might contain following properties:

</p>
<ul>
<li><p><code class="language-javascript">secureContext</code>: An optional TLS context object from
 <code class="language-javascript">tls.createSecureContext( ... )</code></p>
</li>
<li><p><code class="language-javascript">isServer</code>: If true - TLS socket will be instantiated in server-mode</p>
</li>
<li><p><code class="language-javascript">server</code>: An optional <a>net.Server</a> instance</p>
</li>
<li><p><code class="language-javascript">requestCert</code>: Optional, see <a>tls.createSecurePair</a></p>
</li>
<li><p><code class="language-javascript">rejectUnauthorized</code>: Optional, see <a>tls.createSecurePair</a></p>
</li>
<li><p><code class="language-javascript">NPNProtocols</code>: Optional, see <a>tls.createServer</a></p>
</li>
<li><p><code class="language-javascript">SNICallback</code>: Optional, see <a>tls.createServer</a></p>
</li>
<li><p><code class="language-javascript">session</code>: Optional, a <code class="language-javascript">Buffer</code> instance, containing TLS session</p>
</li>
<li><p><code class="language-javascript">requestOCSP</code>: Optional, if <code class="language-javascript">true</code> - OCSP status request extension would
be added to client hello, and <code class="language-javascript">OCSPResponse</code> event will be emitted on socket
before establishing secure communication</p>
</li>
</ul>
<!--next-->
<h2>tls.createSecureContext(details)</h2>
<p>Creates a credentials object, with the optional details being a
dictionary with keys:

</p>
<ul>
<li><code class="language-javascript">pfx</code> : A string or buffer holding the PFX or PKCS12 encoded private
key, certificate and CA certificates</li>
<li><code class="language-javascript">key</code> : A string holding the PEM encoded private key</li>
<li><code class="language-javascript">passphrase</code> : A string of passphrase for the private key or pfx</li>
<li><code class="language-javascript">cert</code> : A string holding the PEM encoded certificate</li>
<li><code class="language-javascript">ca</code> : Either a string or list of strings of PEM encoded CA
certificates to trust.</li>
<li><code class="language-javascript">crl</code> : Either a string or list of strings of PEM encoded CRLs
(Certificate Revocation List)</li>
<li><code class="language-javascript">ciphers</code>: A string describing the ciphers to use or exclude.
Consult
<a>http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT</a>
for details on the format.</li>
<li><code class="language-javascript">honorCipherOrder</code> : When choosing a cipher, use the server&#39;s preferences
instead of the client preferences. For further details see <code class="language-javascript">tls</code> module
documentation.</li>
</ul>
<p>If no &#39;ca&#39; details are given, then node.js will use the default
publicly trusted list of CAs as given in
</p>
<p><a>http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt</a>.


</p>
<!--next-->
<h2>tls.createSecurePair([context][, isServer][, requestCert][, rejectUnauthorized])</h2>
<p>Creates a new secure pair object with two streams, one of which reads/writes
encrypted data, and one reads/writes cleartext data.
Generally the encrypted one is piped to/from an incoming encrypted data stream,
and the cleartext one is used as a replacement for the initial encrypted stream.

</p>
<ul>
<li><p><code class="language-javascript">credentials</code>: A secure context object from tls.createSecureContext( ... )</p>
</li>
<li><p><code class="language-javascript">isServer</code>: A boolean indicating whether this tls connection should be
opened as a server or a client.</p>
</li>
<li><p><code class="language-javascript">requestCert</code>: A boolean indicating whether a server should request a
certificate from a connecting client. Only applies to server connections.</p>
</li>
<li><p><code class="language-javascript">rejectUnauthorized</code>: A boolean indicating whether a server should
automatically reject clients with invalid certificates. Only applies to
servers with <code class="language-javascript">requestCert</code> enabled.</p>
</li>
</ul>
<p><code class="language-javascript">tls.createSecurePair()</code> returns a SecurePair object with <code class="language-javascript">cleartext</code> and
<code class="language-javascript">encrypted</code> stream properties.

</p>
<p>NOTE: <code class="language-javascript">cleartext</code> has the same APIs as <a>tls.TLSSocket</a>

</p>
<!--next-->
<h2>Class: SecurePair</h2>
<p>Returned by tls.createSecurePair.

</p>
<!--next-->
<h2>Event: &#39;secure&#39;</h2>
<p>The event is emitted from the SecurePair once the pair has successfully
established a secure connection.

</p>
<p>Similarly to the checking for the server &#39;secureConnection&#39; event,
pair.cleartext.authorized should be checked to confirm whether the certificate
used properly authorized.

</p>
<!--next-->
<h2>Class: tls.Server</h2>
<p>This class is a subclass of <code class="language-javascript">net.Server</code> and has the same methods on it.
Instead of accepting just raw TCP connections, this accepts encrypted
connections using TLS or SSL.

</p>
<!--next-->
<h2>Event: &#39;secureConnection&#39;</h2>
<p><code class="language-javascript">function (tlsSocket) {}</code>

</p>
<p>This event is emitted after a new connection has been successfully
handshaked. The argument is an instance of <a>tls.TLSSocket</a>. It has all the
common stream methods and events.

</p>
<p><code class="language-javascript">socket.authorized</code> is a boolean value which indicates if the
client has verified by one of the supplied certificate authorities for the
server. If <code class="language-javascript">socket.authorized</code> is false, then
<code class="language-javascript">socket.authorizationError</code> is set to describe how authorization
failed. Implied but worth mentioning: depending on the settings of the TLS
server, you unauthorized connections may be accepted.
<code class="language-javascript">socket.npnProtocol</code> is a string containing selected NPN protocol.
<code class="language-javascript">socket.servername</code> is a string containing servername requested with
SNI.


</p>
<!--next-->
<h2>Event: &#39;clientError&#39;</h2>
<p><code class="language-javascript">function (exception, tlsSocket) { }</code>

</p>
<p>When a client connection emits an &#39;error&#39; event before secure connection is
established - it will be forwarded here.

</p>
<p><code class="language-javascript">tlsSocket</code> is the <a>tls.TLSSocket</a> that the error originated from.


</p>
<!--next-->
<h2>Event: &#39;newSession&#39;</h2>
<p><code class="language-javascript">function (sessionId, sessionData, callback) { }</code>

</p>
<p>Emitted on creation of TLS session. May be used to store sessions in external
storage. <code class="language-javascript">callback</code> must be invoked eventually, otherwise no data will be
sent or received from secure connection.

</p>
<p>NOTE: adding this event listener will have an effect only on connections
established after addition of event listener.


</p>
<!--next-->
<h2>Event: &#39;resumeSession&#39;</h2>
<p><code class="language-javascript">function (sessionId, callback) { }</code>

</p>
<p>Emitted when client wants to resume previous TLS session. Event listener may
perform lookup in external storage using given <code class="language-javascript">sessionId</code>, and invoke
<code class="language-javascript">callback(null, sessionData)</code> once finished. If session can&#39;t be resumed
(i.e. doesn&#39;t exist in storage) one may call <code class="language-javascript">callback(null, null)</code>. Calling
<code class="language-javascript">callback(err)</code> will terminate incoming connection and destroy socket.

</p>
<p>NOTE: adding this event listener will have an effect only on connections
established after addition of event listener.


</p>
<!--next-->
<h2>Event: &#39;OCSPRequest&#39;</h2>
<p><code class="language-javascript">function (certificate, issuer, callback) { }</code>

</p>
<p>Emitted when the client sends a certificate status request. You could parse
server&#39;s current certificate to obtain OCSP url and certificate id, and after
obtaining OCSP response invoke <code class="language-javascript">callback(null, resp)</code>, where <code class="language-javascript">resp</code> is a
<code class="language-javascript">Buffer</code> instance. Both <code class="language-javascript">certificate</code> and <code class="language-javascript">issuer</code> are a <code class="language-javascript">Buffer</code>
DER-representations of the primary and issuer&#39;s certificates. They could be used
to obtain OCSP certificate id and OCSP endpoint url.

</p>
<p>Alternatively, <code class="language-javascript">callback(null, null)</code> could be called, meaning that there is no
OCSP response.

</p>
<p>Calling <code class="language-javascript">callback(err)</code> will result in a <code class="language-javascript">socket.destroy(err)</code> call.

</p>
<p>Typical flow:

</p>
<ol>
<li>Client connects to server and sends <code class="language-javascript">OCSPRequest</code> to it (via status info
extension in ClientHello.)</li>
<li>Server receives request and invokes <code class="language-javascript">OCSPRequest</code> event listener if present</li>
<li>Server grabs OCSP url from either <code class="language-javascript">certificate</code> or <code class="language-javascript">issuer</code> and performs an
<a>OCSP request</a> to the CA</li>
<li>Server receives <code class="language-javascript">OCSPResponse</code> from CA and sends it back to client via
<code class="language-javascript">callback</code> argument</li>
<li>Client validates the response and either destroys socket or performs a
handshake.</li>
</ol>
<p>NOTE: <code class="language-javascript">issuer</code> could be null, if the certificate is self-signed or if the issuer
is not in the root certificates list. (You could provide an issuer via <code class="language-javascript">ca</code>
option.)

</p>
<p>NOTE: adding this event listener will have an effect only on connections
established after addition of event listener.

</p>
<p>NOTE: you may want to use some npm module like <a>asn1.js</a> to parse the
certificates.


</p>
<!--next-->
<h2>server.listen(port[, host][, callback])</h2>
<p>Begin accepting connections on the specified <code class="language-javascript">port</code> and <code class="language-javascript">host</code>.  If the
<code class="language-javascript">host</code> is omitted, the server will accept connections directed to any
IPv4 address (<code class="language-javascript">INADDR_ANY</code>).

</p>
<p>This function is asynchronous. The last parameter <code class="language-javascript">callback</code> will be called
when the server has been bound.

</p>
<p>See <code class="language-javascript">net.Server</code> for more information.


</p>
<!--next-->
<h2>server.close()</h2>
<p>Stops the server from accepting new connections. This function is
asynchronous, the server is finally closed when the server emits a <code class="language-javascript">&#39;close&#39;</code>
event.

</p>
<!--next-->
<h2>server.address()</h2>
<p>Returns the bound address, the address family name and port of the
server as reported by the operating system.  See <a>net.Server.address()</a> for
more information.

</p>
<!--next-->
<h2>server.addContext(hostname, context)</h2>
<p>Add secure context that will be used if client request&#39;s SNI hostname is
matching passed <code class="language-javascript">hostname</code> (wildcards can be used). <code class="language-javascript">context</code> can contain
<code class="language-javascript">key</code>, <code class="language-javascript">cert</code>, <code class="language-javascript">ca</code> and/or any other properties from <code class="language-javascript">tls.createSecureContext</code>
<code class="language-javascript">options</code> argument.

</p>
<!--next-->
<h2>server.maxConnections</h2>
<p>Set this property to reject connections when the server&#39;s connection count
gets high.

</p>
<!--next-->
<h2>server.connections</h2>
<p>The number of concurrent connections on the server.


</p>
<!--next-->
<h2>Class: CryptoStream</h2>
<pre class="stability">Stability: 0 - Deprecated. Use tls.TLSSocket instead.</pre><p>This is an encrypted stream.

</p>
<!--next-->
<h2>cryptoStream.bytesWritten</h2>
<p>A proxy to the underlying socket&#39;s bytesWritten accessor, this will return
the total bytes written to the socket, <em>including the TLS overhead</em>.

</p>
<!--next-->
<h2>Class: tls.TLSSocket</h2>
<p>This is a wrapped version of <a>net.Socket</a> that does transparent encryption
of written data and all required TLS negotiation.

</p>
<p>This instance implements a duplex <a>Stream</a> interfaces.  It has all the
common stream methods and events.

</p>
<!--next-->
<h2>Event: &#39;secureConnect&#39;</h2>
<p>This event is emitted after a new connection has been successfully handshaked.
The listener will be called no matter if the server&#39;s certificate was
authorized or not. It is up to the user to test <code class="language-javascript">tlsSocket.authorized</code>
to see if the server certificate was signed by one of the specified CAs.
If <code class="language-javascript">tlsSocket.authorized === false</code> then the error can be found in
<code class="language-javascript">tlsSocket.authorizationError</code>. Also if NPN was used - you can check
<code class="language-javascript">tlsSocket.npnProtocol</code> for negotiated protocol.

</p>
<!--next-->
<h2>Event: &#39;OCSPResponse&#39;</h2>
<p><code class="language-javascript">function (response) { }</code>

</p>
<p>This event will be emitted if <code class="language-javascript">requestOCSP</code> option was set. <code class="language-javascript">response</code> is a
buffer object, containing server&#39;s OCSP response.

</p>
<p>Traditionally, the <code class="language-javascript">response</code> is a signed object from the server&#39;s CA that
contains information about server&#39;s certificate revocation status.

</p>
<!--next-->
<h2>tlsSocket.encrypted</h2>
<p>Static boolean value, always <code class="language-javascript">true</code>. May be used to distinguish TLS sockets
from regular ones.

</p>
<!--next-->
<h2>tlsSocket.authorized</h2>
<p>A boolean that is <code class="language-javascript">true</code> if the peer certificate was signed by one of the
specified CAs, otherwise <code class="language-javascript">false</code>

</p>
<!--next-->
<h2>tlsSocket.authorizationError</h2>
<p>The reason why the peer&#39;s certificate has not been verified. This property
becomes available only when <code class="language-javascript">tlsSocket.authorized === false</code>.

</p>
<!--next-->
<h2>tlsSocket.getPeerCertificate([ detailed ])</h2>
<p>Returns an object representing the peer&#39;s certificate. The returned object has
some properties corresponding to the field of the certificate. If <code class="language-javascript">detailed</code>
argument is <code class="language-javascript">true</code> - the full chain with <code class="language-javascript">issuer</code> property will be returned,
if <code class="language-javascript">false</code> - only the top certificate without <code class="language-javascript">issuer</code> property.

</p>
<p>Example:

</p>
<pre><code class="language-javascript">{ subject:
   { C: &#39;UK&#39;,
     ST: &#39;Acknack Ltd&#39;,
     L: &#39;Rhys Jones&#39;,
     O: &#39;node.js&#39;,
     OU: &#39;Test TLS Certificate&#39;,
     CN: &#39;localhost&#39; },
  issuerInfo:
   { C: &#39;UK&#39;,
     ST: &#39;Acknack Ltd&#39;,
     L: &#39;Rhys Jones&#39;,
     O: &#39;node.js&#39;,
     OU: &#39;Test TLS Certificate&#39;,
     CN: &#39;localhost&#39; },
  issuer:
   { ... another certificate ... },
  raw: &lt; RAW DER buffer &gt;,
  valid_from: &#39;Nov 11 09:52:22 2009 GMT&#39;,
  valid_to: &#39;Nov  6 09:52:22 2029 GMT&#39;,
  fingerprint: &#39;2A:7A:C2:DD:E5:F9:CC:53:72:35:99:7A:02:5A:71:38:52:EC:8A:DF&#39;,
  serialNumber: &#39;B9B0D332A1AA5635&#39; }</code></pre>
<p>If the peer does not provide a certificate, it returns <code class="language-javascript">null</code> or an empty
object.

</p>
<!--next-->
<h2>tlsSocket.getCipher()</h2>
<p>Returns an object representing the cipher name and the SSL/TLS
protocol version of the current connection.

</p>
<p>Example:
{ name: &#39;AES256-SHA&#39;, version: &#39;TLSv1/SSLv3&#39; }

</p>
<p>See SSL_CIPHER_get_name() and SSL_CIPHER_get_version() in
<a>http://www.openssl.org/docs/ssl/ssl.html#DEALING_WITH_CIPHERS</a> for more
information.

</p>
<!--next-->
<h2>tlsSocket.renegotiate(options, callback)</h2>
<p>Initiate TLS renegotiation process. The <code class="language-javascript">options</code> may contain the following
fields: <code class="language-javascript">rejectUnauthorized</code>, <code class="language-javascript">requestCert</code> (See <a>tls.createServer</a>
for details). <code class="language-javascript">callback(err)</code> will be executed with <code class="language-javascript">null</code> as <code class="language-javascript">err</code>,
once the renegotiation is successfully completed.

</p>
<p>NOTE: Can be used to request peer&#39;s certificate after the secure connection
has been established.

</p>
<p>ANOTHER NOTE: When running as the server, socket will be destroyed
with an error after <code class="language-javascript">handshakeTimeout</code> timeout.

</p>
<!--next-->
<h2>tlsSocket.setMaxSendFragment(size)</h2>
<p>Set maximum TLS fragment size (default and maximum value is: <code class="language-javascript">16384</code>, minimum
is: <code class="language-javascript">512</code>). Returns <code class="language-javascript">true</code> on success, <code class="language-javascript">false</code> otherwise.

</p>
<p>Smaller fragment size decreases buffering latency on the client: large
fragments are buffered by the TLS layer until the entire fragment is received
and its integrity is verified; large fragments can span multiple roundtrips,
and their processing can be delayed due to packet loss or reordering. However,
smaller fragments add extra TLS framing bytes and CPU overhead, which may
decrease overall server throughput.

</p>
<!--next-->
<h2>tlsSocket.getSession()</h2>
<p>Return ASN.1 encoded TLS session or <code class="language-javascript">undefined</code> if none was negotiated. Could
be used to speed up handshake establishment when reconnecting to the server.

</p>
<!--next-->
<h2>tlsSocket.getTLSTicket()</h2>
<p>NOTE: Works only with client TLS sockets. Useful only for debugging, for
session reuse provide <code class="language-javascript">session</code> option to <code class="language-javascript">tls.connect</code>.

</p>
<p>Return TLS session ticket or <code class="language-javascript">undefined</code> if none was negotiated.

</p>
<!--next-->
<h2>tlsSocket.address()</h2>
<p>Returns the bound address, the address family name and port of the
underlying socket as reported by the operating system. Returns an
object with three properties, e.g.
<code class="language-javascript">{ port: 12346, family: &#39;IPv4&#39;, address: &#39;127.0.0.1&#39; }</code>

</p>
<!--next-->
<h2>tlsSocket.remoteAddress</h2>
<p>The string representation of the remote IP address. For example,
<code class="language-javascript">&#39;74.125.127.100&#39;</code> or <code class="language-javascript">&#39;2001:4860:a005::68&#39;</code>.

</p>
<!--next-->
<h2>tlsSocket.remoteFamily</h2>
<p>The string representation of the remote IP family. <code class="language-javascript">&#39;IPv4&#39;</code> or <code class="language-javascript">&#39;IPv6&#39;</code>.

</p>
<!--next-->
<h2>tlsSocket.remotePort</h2>
<p>The numeric representation of the remote port. For example, <code class="language-javascript">443</code>.

</p>
<!--next-->
<h2>tlsSocket.localAddress</h2>
<p>The string representation of the local IP address.

</p>
<!--next-->
<h2>tlsSocket.localPort</h2>
<p>The numeric representation of the local port.

</p>
<!--next-->
<h2>StringDecoder</h2>
<pre class="stability">Stability: 3 - Stable</pre><p>To use this module, do <code class="language-javascript">require(&#39;string_decoder&#39;)</code>. StringDecoder decodes a
buffer to a string. It is a simple interface to <code class="language-javascript">buffer.toString()</code> but provides
additional support for utf8.

</p>
<pre><code class="language-javascript">var StringDecoder = require(&#39;string_decoder&#39;).StringDecoder;
var decoder = new StringDecoder(&#39;utf8&#39;);

var cent = new Buffer([0xC2, 0xA2]);
console.log(decoder.write(cent));

var euro = new Buffer([0xE2, 0x82, 0xAC]);
console.log(decoder.write(euro));</code></pre>
<!--next-->
<h2>Class: StringDecoder</h2>
<p>Accepts a single argument, <code class="language-javascript">encoding</code> which defaults to <code class="language-javascript">utf8</code>.

</p>
<!--next-->
<h2>decoder.write(buffer)</h2>
<p>Returns a decoded string.

</p>
<!--next-->
<h2>decoder.end()</h2>
<p>Returns any trailing bytes that were left in the buffer.

</p>
<!--next-->
<h2>File System</h2>
<pre class="stability">Stability: 3 - Stable</pre>

<p>File I/O is provided by simple wrappers around standard POSIX functions.  To
use this module do <code class="language-javascript">require(&#39;fs&#39;)</code>. All the methods have asynchronous and
synchronous forms.

</p>
<p>The asynchronous form always take a completion callback as its last argument.
The arguments passed to the completion callback depend on the method, but the
first argument is always reserved for an exception. If the operation was
completed successfully, then the first argument will be <code class="language-javascript">null</code> or <code class="language-javascript">undefined</code>.

</p>
<p>When using the synchronous form any exceptions are immediately thrown.
You can use try/catch to handle exceptions or allow them to bubble up.

</p>
<p>Here is an example of the asynchronous version:

</p>
<pre><code class="language-javascript">var fs = require(&#39;fs&#39;);

fs.unlink(&#39;/tmp/hello&#39;, function (err) {
  if (err) throw err;
  console.log(&#39;successfully deleted /tmp/hello&#39;);
});</code></pre>
<p>Here is the synchronous version:

</p>
<pre><code class="language-javascript">var fs = require(&#39;fs&#39;);

fs.unlinkSync(&#39;/tmp/hello&#39;)
console.log(&#39;successfully deleted /tmp/hello&#39;);</code></pre>
<p>With the asynchronous methods there is no guaranteed ordering. So the
following is prone to error:

</p>
<pre><code class="language-javascript">fs.rename(&#39;/tmp/hello&#39;, &#39;/tmp/world&#39;, function (err) {
  if (err) throw err;
  console.log(&#39;renamed complete&#39;);
});
fs.stat(&#39;/tmp/world&#39;, function (err, stats) {
  if (err) throw err;
  console.log(&#39;stats: &#39; + JSON.stringify(stats));
});</code></pre>
<p>It could be that <code class="language-javascript">fs.stat</code> is executed before <code class="language-javascript">fs.rename</code>.
The correct way to do this is to chain the callbacks.

</p>
<pre><code class="language-javascript">fs.rename(&#39;/tmp/hello&#39;, &#39;/tmp/world&#39;, function (err) {
  if (err) throw err;
  fs.stat(&#39;/tmp/world&#39;, function (err, stats) {
    if (err) throw err;
    console.log(&#39;stats: &#39; + JSON.stringify(stats));
  });
});</code></pre>
<p>In busy processes, the programmer is <em>strongly encouraged</em> to use the
asynchronous versions of these calls. The synchronous versions will block
the entire process until they complete--halting all connections.

</p>
<p>Relative path to filename can be used, remember however that this path will be
relative to <code class="language-javascript">process.cwd()</code>.

</p>
<p>Most fs functions let you omit the callback argument. If you do, a default
callback is used that rethrows errors. To get a trace to the original call
site, set the NODE_DEBUG environment variable:

</p>
<pre><code class="language-javascript">$ cat script.js
function bad() {
  require(&#39;fs&#39;).readFile(&#39;/&#39;);
}
bad();

$ env NODE_DEBUG=fs node script.js
fs.js:66
        throw err;
              ^
Error: EISDIR, read
    at rethrow (fs.js:61:21)
    at maybeCallback (fs.js:79:42)
    at Object.fs.readFile (fs.js:153:18)
    at bad (/path/to/script.js:2:17)
    at Object.&lt;anonymous&gt; (/path/to/script.js:5:1)
    &lt;etc.&gt;</code></pre>
<!--next-->
<h2>fs.rename(oldPath, newPath, callback)</h2>
<p>Asynchronous rename(2). No arguments other than a possible exception are given
to the completion callback.

</p>
<!--next-->
<h2>fs.renameSync(oldPath, newPath)</h2>
<p>Synchronous rename(2).

</p>
<!--next-->
<h2>fs.ftruncate(fd, len, callback)</h2>
<p>Asynchronous ftruncate(2). No arguments other than a possible exception are
given to the completion callback.

</p>
<!--next-->
<h2>fs.ftruncateSync(fd, len)</h2>
<p>Synchronous ftruncate(2).

</p>
<!--next-->
<h2>fs.truncate(path, len, callback)</h2>
<p>Asynchronous truncate(2). No arguments other than a possible exception are
given to the completion callback.

</p>
<!--next-->
<h2>fs.truncateSync(path, len)</h2>
<p>Synchronous truncate(2).

</p>
<!--next-->
<h2>fs.chown(path, uid, gid, callback)</h2>
<p>Asynchronous chown(2). No arguments other than a possible exception are given
to the completion callback.

</p>
<!--next-->
<h2>fs.chownSync(path, uid, gid)</h2>
<p>Synchronous chown(2).

</p>
<!--next-->
<h2>fs.fchown(fd, uid, gid, callback)</h2>
<p>Asynchronous fchown(2). No arguments other than a possible exception are given
to the completion callback.

</p>
<!--next-->
<h2>fs.fchownSync(fd, uid, gid)</h2>
<p>Synchronous fchown(2).

</p>
<!--next-->
<h2>fs.lchown(path, uid, gid, callback)</h2>
<p>Asynchronous lchown(2). No arguments other than a possible exception are given
to the completion callback.

</p>
<!--next-->
<h2>fs.lchownSync(path, uid, gid)</h2>
<p>Synchronous lchown(2).

</p>
<!--next-->
<h2>fs.chmod(path, mode, callback)</h2>
<p>Asynchronous chmod(2). No arguments other than a possible exception are given
to the completion callback.

</p>
<!--next-->
<h2>fs.chmodSync(path, mode)</h2>
<p>Synchronous chmod(2).

</p>
<!--next-->
<h2>fs.fchmod(fd, mode, callback)</h2>
<p>Asynchronous fchmod(2). No arguments other than a possible exception
are given to the completion callback.

</p>
<!--next-->
<h2>fs.fchmodSync(fd, mode)</h2>
<p>Synchronous fchmod(2).

</p>
<!--next-->
<h2>fs.lchmod(path, mode, callback)</h2>
<p>Asynchronous lchmod(2). No arguments other than a possible exception
are given to the completion callback.

</p>
<p>Only available on Mac OS X.

</p>
<!--next-->
<h2>fs.lchmodSync(path, mode)</h2>
<p>Synchronous lchmod(2).

</p>
<!--next-->
<h2>fs.stat(path, callback)</h2>
<p>Asynchronous stat(2). The callback gets two arguments <code class="language-javascript">(err, stats)</code> where
<code class="language-javascript">stats</code> is a <a>fs.Stats</a> object.  See the <a>fs.Stats</a>
section below for more information.

</p>
<!--next-->
<h2>fs.lstat(path, callback)</h2>
<p>Asynchronous lstat(2). The callback gets two arguments <code class="language-javascript">(err, stats)</code> where
<code class="language-javascript">stats</code> is a <code class="language-javascript">fs.Stats</code> object. <code class="language-javascript">lstat()</code> is identical to <code class="language-javascript">stat()</code>, except that if
<code class="language-javascript">path</code> is a symbolic link, then the link itself is stat-ed, not the file that it
refers to.

</p>
<!--next-->
<h2>fs.fstat(fd, callback)</h2>
<p>Asynchronous fstat(2). The callback gets two arguments <code class="language-javascript">(err, stats)</code> where
<code class="language-javascript">stats</code> is a <code class="language-javascript">fs.Stats</code> object. <code class="language-javascript">fstat()</code> is identical to <code class="language-javascript">stat()</code>, except that
the file to be stat-ed is specified by the file descriptor <code class="language-javascript">fd</code>.

</p>
<!--next-->
<h2>fs.statSync(path)</h2>
<p>Synchronous stat(2). Returns an instance of <code class="language-javascript">fs.Stats</code>.

</p>
<!--next-->
<h2>fs.lstatSync(path)</h2>
<p>Synchronous lstat(2). Returns an instance of <code class="language-javascript">fs.Stats</code>.

</p>
<!--next-->
<h2>fs.fstatSync(fd)</h2>
<p>Synchronous fstat(2). Returns an instance of <code class="language-javascript">fs.Stats</code>.

</p>
<!--next-->
<h2>fs.link(srcpath, dstpath, callback)</h2>
<p>Asynchronous link(2). No arguments other than a possible exception are given to
the completion callback.

</p>
<!--next-->
<h2>fs.linkSync(srcpath, dstpath)</h2>
<p>Synchronous link(2).

</p>
<!--next-->
<h2>fs.symlink(srcpath, dstpath[, type], callback)</h2>
<p>Asynchronous symlink(2). No arguments other than a possible exception are given
to the completion callback.
The <code class="language-javascript">type</code> argument can be set to <code class="language-javascript">&#39;dir&#39;</code>, <code class="language-javascript">&#39;file&#39;</code>, or <code class="language-javascript">&#39;junction&#39;</code> (default
is <code class="language-javascript">&#39;file&#39;</code>) and is only available on Windows (ignored on other platforms).
Note that Windows junction points require the destination path to be absolute.  When using
<code class="language-javascript">&#39;junction&#39;</code>, the <code class="language-javascript">destination</code> argument will automatically be normalized to absolute path.

</p>
<!--next-->
<h2>fs.symlinkSync(srcpath, dstpath[, type])</h2>
<p>Synchronous symlink(2).

</p>
<!--next-->
<h2>fs.readlink(path, callback)</h2>
<p>Asynchronous readlink(2). The callback gets two arguments <code class="language-javascript">(err,
linkString)</code>.

</p>
<!--next-->
<h2>fs.readlinkSync(path)</h2>
<p>Synchronous readlink(2). Returns the symbolic link&#39;s string value.

</p>
<!--next-->
<h2>fs.realpath(path[, cache], callback)</h2>
<p>Asynchronous realpath(2). The <code class="language-javascript">callback</code> gets two arguments <code class="language-javascript">(err,
resolvedPath)</code>. May use <code class="language-javascript">process.cwd</code> to resolve relative paths. <code class="language-javascript">cache</code> is an
object literal of mapped paths that can be used to force a specific path
resolution or avoid additional <code class="language-javascript">fs.stat</code> calls for known real paths.

</p>
<p>Example:

</p>
<pre><code class="language-javascript">var cache = {&#39;/etc&#39;:&#39;/private/etc&#39;};
fs.realpath(&#39;/etc/passwd&#39;, cache, function (err, resolvedPath) {
  if (err) throw err;
  console.log(resolvedPath);
});</code></pre>
<!--next-->
<h2>fs.realpathSync(path[, cache])</h2>
<p>Synchronous realpath(2). Returns the resolved path.

</p>
<!--next-->
<h2>fs.unlink(path, callback)</h2>
<p>Asynchronous unlink(2). No arguments other than a possible exception are given
to the completion callback.

</p>
<!--next-->
<h2>fs.unlinkSync(path)</h2>
<p>Synchronous unlink(2).

</p>
<!--next-->
<h2>fs.rmdir(path, callback)</h2>
<p>Asynchronous rmdir(2). No arguments other than a possible exception are given
to the completion callback.

</p>
<!--next-->
<h2>fs.rmdirSync(path)</h2>
<p>Synchronous rmdir(2).

</p>
<!--next-->
<h2>fs.mkdir(path[, mode], callback)</h2>
<p>Asynchronous mkdir(2). No arguments other than a possible exception are given
to the completion callback. <code class="language-javascript">mode</code> defaults to <code class="language-javascript">0777</code>.

</p>
<!--next-->
<h2>fs.mkdirSync(path[, mode])</h2>
<p>Synchronous mkdir(2).

</p>
<!--next-->
<h2>fs.readdir(path, callback)</h2>
<p>Asynchronous readdir(3).  Reads the contents of a directory.
The callback gets two arguments <code class="language-javascript">(err, files)</code> where <code class="language-javascript">files</code> is an array of
the names of the files in the directory excluding <code class="language-javascript">&#39;.&#39;</code> and <code class="language-javascript">&#39;..&#39;</code>.

</p>
<!--next-->
<h2>fs.readdirSync(path)</h2>
<p>Synchronous readdir(3). Returns an array of filenames excluding <code class="language-javascript">&#39;.&#39;</code> and
<code class="language-javascript">&#39;..&#39;</code>.

</p>
<!--next-->
<h2>fs.close(fd, callback)</h2>
<p>Asynchronous close(2).  No arguments other than a possible exception are given
to the completion callback.

</p>
<!--next-->
<h2>fs.closeSync(fd)</h2>
<p>Synchronous close(2).

</p>
<!--next-->
<h2>fs.open(path, flags[, mode], callback)</h2>
<p>Asynchronous file open. See open(2). <code class="language-javascript">flags</code> can be:

</p>
<ul>
<li><p><code class="language-javascript">&#39;r&#39;</code> - Open file for reading.
An exception occurs if the file does not exist.</p>
</li>
<li><p><code class="language-javascript">&#39;r+&#39;</code> - Open file for reading and writing.
An exception occurs if the file does not exist.</p>
</li>
<li><p><code class="language-javascript">&#39;rs&#39;</code> - Open file for reading in synchronous mode. Instructs the operating
system to bypass the local file system cache.</p>
<p>This is primarily useful for opening files on NFS mounts as it allows you to
skip the potentially stale local cache. It has a very real impact on I/O
performance so don&#39;t use this flag unless you need it.</p>
<p>Note that this doesn&#39;t turn <code class="language-javascript">fs.open()</code> into a synchronous blocking call.
If that&#39;s what you want then you should be using <code class="language-javascript">fs.openSync()</code></p>
</li>
<li><p><code class="language-javascript">&#39;rs+&#39;</code> - Open file for reading and writing, telling the OS to open it
synchronously. See notes for <code class="language-javascript">&#39;rs&#39;</code> about using this with caution.</p>
</li>
<li><p><code class="language-javascript">&#39;w&#39;</code> - Open file for writing.
The file is created (if it does not exist) or truncated (if it exists).</p>
</li>
<li><p><code class="language-javascript">&#39;wx&#39;</code> - Like <code class="language-javascript">&#39;w&#39;</code> but fails if <code class="language-javascript">path</code> exists.</p>
</li>
<li><p><code class="language-javascript">&#39;w+&#39;</code> - Open file for reading and writing.
The file is created (if it does not exist) or truncated (if it exists).</p>
</li>
<li><p><code class="language-javascript">&#39;wx+&#39;</code> - Like <code class="language-javascript">&#39;w+&#39;</code> but fails if <code class="language-javascript">path</code> exists.</p>
</li>
<li><p><code class="language-javascript">&#39;a&#39;</code> - Open file for appending.
The file is created if it does not exist.</p>
</li>
<li><p><code class="language-javascript">&#39;ax&#39;</code> - Like <code class="language-javascript">&#39;a&#39;</code> but fails if <code class="language-javascript">path</code> exists.</p>
</li>
<li><p><code class="language-javascript">&#39;a+&#39;</code> - Open file for reading and appending.
The file is created if it does not exist.</p>
</li>
<li><p><code class="language-javascript">&#39;ax+&#39;</code> - Like <code class="language-javascript">&#39;a+&#39;</code> but fails if <code class="language-javascript">path</code> exists.</p>
</li>
</ul>
<p><code class="language-javascript">mode</code> sets the file mode (permission and sticky bits), but only if the file was
created. It defaults to <code class="language-javascript">0666</code>, readable and writeable.

</p>
<p>The callback gets two arguments <code class="language-javascript">(err, fd)</code>.

</p>
<p>The exclusive flag <code class="language-javascript">&#39;x&#39;</code> (<code class="language-javascript">O_EXCL</code> flag in open(2)) ensures that <code class="language-javascript">path</code> is newly
created. On POSIX systems, <code class="language-javascript">path</code> is considered to exist even if it is a symlink
to a non-existent file. The exclusive flag may or may not work with network file
systems.

</p>
<p>On Linux, positional writes don&#39;t work when the file is opened in append mode.
The kernel ignores the position argument and always appends the data to
the end of the file.

</p>
<!--next-->
<h2>fs.openSync(path, flags[, mode])</h2>
<p>Synchronous version of <code class="language-javascript">fs.open()</code>.

</p>
<!--next-->
<h2>fs.utimes(path, atime, mtime, callback)</h2>
<!--next-->
<h2>fs.utimesSync(path, atime, mtime)</h2>
<p>Change file timestamps of the file referenced by the supplied path.

</p>
<!--next-->
<h2>fs.futimes(fd, atime, mtime, callback)</h2>
<!--next-->
<h2>fs.futimesSync(fd, atime, mtime)</h2>
<p>Change the file timestamps of a file referenced by the supplied file
descriptor.

</p>
<!--next-->
<h2>fs.fsync(fd, callback)</h2>
<p>Asynchronous fsync(2). No arguments other than a possible exception are given
to the completion callback.

</p>
<!--next-->
<h2>fs.fsyncSync(fd)</h2>
<p>Synchronous fsync(2).

</p>
<!--next-->
<h2>fs.write(fd, buffer, offset, length[, position], callback)</h2>
<p>Write <code class="language-javascript">buffer</code> to the file specified by <code class="language-javascript">fd</code>.

</p>
<p><code class="language-javascript">offset</code> and <code class="language-javascript">length</code> determine the part of the buffer to be written.

</p>
<p><code class="language-javascript">position</code> refers to the offset from the beginning of the file where this data
should be written. If <code class="language-javascript">typeof position !== &#39;number&#39;</code>, the data will be written
at the current position. See pwrite(2).

</p>
<p>The callback will be given three arguments <code class="language-javascript">(err, written, buffer)</code> where
<code class="language-javascript">written</code> specifies how many <em>bytes</em> were written from <code class="language-javascript">buffer</code>.

</p>
<p>Note that it is unsafe to use <code class="language-javascript">fs.write</code> multiple times on the same file
without waiting for the callback. For this scenario,
<code class="language-javascript">fs.createWriteStream</code> is strongly recommended.

</p>
<p>On Linux, positional writes don&#39;t work when the file is opened in append mode.
The kernel ignores the position argument and always appends the data to
the end of the file.

</p>
<!--next-->
<h2>fs.write(fd, data[, position[, encoding]], callback)</h2>
<p>Write <code class="language-javascript">data</code> to the file specified by <code class="language-javascript">fd</code>.  If <code class="language-javascript">data</code> is not a Buffer instance
then the value will be coerced to a string.

</p>
<p><code class="language-javascript">position</code> refers to the offset from the beginning of the file where this data
should be written. If <code class="language-javascript">typeof position !== &#39;number&#39;</code> the data will be written at
the current position. See pwrite(2).

</p>
<p><code class="language-javascript">encoding</code> is the expected string encoding.

</p>
<p>The callback will receive the arguments <code class="language-javascript">(err, written, string)</code> where <code class="language-javascript">written</code>
specifies how many <em>bytes</em> the passed string required to be written. Note that
bytes written is not the same as string characters. See
<a>Buffer.byteLength</a>.

</p>
<p>Unlike when writing <code class="language-javascript">buffer</code>, the entire string must be written. No substring
may be specified. This is because the byte offset of the resulting data may not
be the same as the string offset.

</p>
<p>Note that it is unsafe to use <code class="language-javascript">fs.write</code> multiple times on the same file
without waiting for the callback. For this scenario,
<code class="language-javascript">fs.createWriteStream</code> is strongly recommended.

</p>
<p>On Linux, positional writes don&#39;t work when the file is opened in append mode.
The kernel ignores the position argument and always appends the data to
the end of the file.

</p>
<!--next-->
<h2>fs.writeSync(fd, buffer, offset, length[, position])</h2>
<!--next-->
<h2>fs.writeSync(fd, data[, position[, encoding]])</h2>
<p>Synchronous versions of <code class="language-javascript">fs.write()</code>. Returns the number of bytes written.

</p>
<!--next-->
<h2>fs.read(fd, buffer, offset, length, position, callback)</h2>
<p>Read data from the file specified by <code class="language-javascript">fd</code>.

</p>
<p><code class="language-javascript">buffer</code> is the buffer that the data will be written to.

</p>
<p><code class="language-javascript">offset</code> is the offset in the buffer to start writing at.

</p>
<p><code class="language-javascript">length</code> is an integer specifying the number of bytes to read.

</p>
<p><code class="language-javascript">position</code> is an integer specifying where to begin reading from in the file.
If <code class="language-javascript">position</code> is <code class="language-javascript">null</code>, data will be read from the current file position.

</p>
<p>The callback is given the three arguments, <code class="language-javascript">(err, bytesRead, buffer)</code>.

</p>
<!--next-->
<h2>fs.readSync(fd, buffer, offset, length, position)</h2>
<p>Synchronous version of <code class="language-javascript">fs.read</code>. Returns the number of <code class="language-javascript">bytesRead</code>.

</p>
<!--next-->
<h2>fs.readFile(filename[, options], callback)</h2>
<div class="signature"><ul>
<li><code class="language-javascript">filename</code> <span class="type">String</span></li>
<li><code class="language-javascript">options</code> <span class="type">Object</span><ul>
<li><code class="language-javascript">encoding</code> <span class="type">String | Null</span> default = <code class="language-javascript">null</code></li>
<li><code class="language-javascript">flag</code> <span class="type">String</span> default = <code class="language-javascript">&#39;r&#39;</code></li>
</ul>
</li>
<li><code class="language-javascript">callback</code> <span class="type">Function</span></li>
</div></ul>
<p>Asynchronously reads the entire contents of a file. Example:

</p>
<pre><code class="language-javascript">fs.readFile(&#39;/etc/passwd&#39;, function (err, data) {
  if (err) throw err;
  console.log(data);
});</code></pre>
<p>The callback is passed two arguments <code class="language-javascript">(err, data)</code>, where <code class="language-javascript">data</code> is the
contents of the file.

</p>
<p>If no encoding is specified, then the raw buffer is returned.


</p>
<!--next-->
<h2>fs.readFileSync(filename[, options])</h2>
<p>Synchronous version of <code class="language-javascript">fs.readFile</code>. Returns the contents of the <code class="language-javascript">filename</code>.

</p>
<p>If the <code class="language-javascript">encoding</code> option is specified then this function returns a
string. Otherwise it returns a buffer.


</p>
<!--next-->
<h2>fs.writeFile(filename, data[, options], callback)</h2>
<div class="signature"><ul>
<li><code class="language-javascript">filename</code> <span class="type">String</span></li>
<li><code class="language-javascript">data</code> <span class="type">String | Buffer</span></li>
<li><code class="language-javascript">options</code> <span class="type">Object</span><ul>
<li><code class="language-javascript">encoding</code> <span class="type">String | Null</span> default = <code class="language-javascript">&#39;utf8&#39;</code></li>
<li><code class="language-javascript">mode</code> <span class="type">Number</span> default = <code class="language-javascript">438</code> (aka <code class="language-javascript">0666</code> in Octal)</li>
<li><code class="language-javascript">flag</code> <span class="type">String</span> default = <code class="language-javascript">&#39;w&#39;</code></li>
</ul>
</li>
<li><code class="language-javascript">callback</code> <span class="type">Function</span></li>
</div></ul>
<p>Asynchronously writes data to a file, replacing the file if it already exists.
<code class="language-javascript">data</code> can be a string or a buffer.

</p>
<p>The <code class="language-javascript">encoding</code> option is ignored if <code class="language-javascript">data</code> is a buffer. It defaults
to <code class="language-javascript">&#39;utf8&#39;</code>.

</p>
<p>Example:

</p>
<pre><code class="language-javascript">fs.writeFile(&#39;message.txt&#39;, &#39;Hello Node&#39;, function (err) {
  if (err) throw err;
  console.log(&#39;It\&#39;s saved!&#39;);
});</code></pre>
<!--next-->
<h2>fs.writeFileSync(filename, data[, options])</h2>
<p>The synchronous version of <code class="language-javascript">fs.writeFile</code>.

</p>
<!--next-->
<h2>fs.appendFile(filename, data[, options], callback)</h2>
<div class="signature"><ul>
<li><code class="language-javascript">filename</code> <span class="type">String</span></li>
<li><code class="language-javascript">data</code> <span class="type">String | Buffer</span></li>
<li><code class="language-javascript">options</code> <span class="type">Object</span><ul>
<li><code class="language-javascript">encoding</code> <span class="type">String | Null</span> default = <code class="language-javascript">&#39;utf8&#39;</code></li>
<li><code class="language-javascript">mode</code> <span class="type">Number</span> default = <code class="language-javascript">438</code> (aka <code class="language-javascript">0666</code> in Octal)</li>
<li><code class="language-javascript">flag</code> <span class="type">String</span> default = <code class="language-javascript">&#39;a&#39;</code></li>
</ul>
</li>
<li><code class="language-javascript">callback</code> <span class="type">Function</span></li>
</div></ul>
<p>Asynchronously append data to a file, creating the file if it not yet exists.
<code class="language-javascript">data</code> can be a string or a buffer.

</p>
<p>Example:

</p>
<pre><code class="language-javascript">fs.appendFile(&#39;message.txt&#39;, &#39;data to append&#39;, function (err) {
  if (err) throw err;
  console.log(&#39;The &quot;data to append&quot; was appended to file!&#39;);
});</code></pre>
<!--next-->
<h2>fs.appendFileSync(filename, data[, options])</h2>
<p>The synchronous version of <code class="language-javascript">fs.appendFile</code>.

</p>
<!--next-->
<h2>fs.watchFile(filename[, options], listener)</h2>
<pre class="stability">Stability: 2 - Unstable.  Use fs.watch instead, if possible.</pre><p>Watch for changes on <code class="language-javascript">filename</code>. The callback <code class="language-javascript">listener</code> will be called each
time the file is accessed.

</p>
<p>The second argument is optional. The <code class="language-javascript">options</code> if provided should be an object
containing two members a boolean, <code class="language-javascript">persistent</code>, and <code class="language-javascript">interval</code>. <code class="language-javascript">persistent</code>
indicates whether the process should continue to run as long as files are
being watched. <code class="language-javascript">interval</code> indicates how often the target should be polled,
in milliseconds. The default is <code class="language-javascript">{ persistent: true, interval: 5007 }</code>.

</p>
<p>The <code class="language-javascript">listener</code> gets two arguments the current stat object and the previous
stat object:

</p>
<pre><code class="language-javascript">fs.watchFile(&#39;message.text&#39;, function (curr, prev) {
  console.log(&#39;the current mtime is: &#39; + curr.mtime);
  console.log(&#39;the previous mtime was: &#39; + prev.mtime);
});</code></pre>
<p>These stat objects are instances of <code class="language-javascript">fs.Stat</code>.

</p>
<p>If you want to be notified when the file was modified, not just accessed
you need to compare <code class="language-javascript">curr.mtime</code> and <code class="language-javascript">prev.mtime</code>.

</p>
<!--next-->
<h2>fs.unwatchFile(filename[, listener])</h2>
<pre class="stability">Stability: 2 - Unstable.  Use fs.watch instead, if possible.</pre><p>Stop watching for changes on <code class="language-javascript">filename</code>. If <code class="language-javascript">listener</code> is specified, only that
particular listener is removed. Otherwise, <em>all</em> listeners are removed and you
have effectively stopped watching <code class="language-javascript">filename</code>.

</p>
<p>Calling <code class="language-javascript">fs.unwatchFile()</code> with a filename that is not being watched is a
no-op, not an error.

</p>
<!--next-->
<h2>fs.watch(filename[, options][, listener])</h2>
<pre class="stability">Stability: 2 - Unstable.</pre><p>Watch for changes on <code class="language-javascript">filename</code>, where <code class="language-javascript">filename</code> is either a file or a
directory.  The returned object is a <a>fs.FSWatcher</a>.

</p>
<p>The second argument is optional. The <code class="language-javascript">options</code> if provided should be an object.
The supported boolean members are <code class="language-javascript">persistent</code> and <code class="language-javascript">recursive</code>. <code class="language-javascript">persistent</code>
indicates whether the process should continue to run as long as files are being
watched. <code class="language-javascript">recursive</code> indicates whether all subdirectories should be watched, or
only the current directory. This applies when a directory is specified, and only
on supported platforms (See Caveats below).

</p>
<p>The default is <code class="language-javascript">{ persistent: true, recursive: false }</code>.

</p>
<p>The listener callback gets two arguments <code class="language-javascript">(event, filename)</code>.  <code class="language-javascript">event</code> is either
&#39;rename&#39; or &#39;change&#39;, and <code class="language-javascript">filename</code> is the name of the file which triggered
the event.

</p>
<!--next-->
<h2>Caveats</h2>
<p>The <code class="language-javascript">fs.watch</code> API is not 100% consistent across platforms, and is
unavailable in some situations.

</p>
<p>The recursive option is currently supported on OS X. Only FSEvents supports this
type of file watching so it is unlikely any additional platforms will be added
soon.

</p>
<h4>Availability</h4>

<p>This feature depends on the underlying operating system providing a way
to be notified of filesystem changes.

</p>
<ul>
<li>On Linux systems, this uses <code class="language-javascript">inotify</code>.</li>
<li>On BSD systems, this uses <code class="language-javascript">kqueue</code>.</li>
<li>On OS X, this uses <code class="language-javascript">kqueue</code> for files and &#39;FSEvents&#39; for directories.</li>
<li>On SunOS systems (including Solaris and SmartOS), this uses <code class="language-javascript">event ports</code>.</li>
<li>On Windows systems, this feature depends on <code class="language-javascript">ReadDirectoryChangesW</code>.</li>
</ul>
<p>If the underlying functionality is not available for some reason, then
<code class="language-javascript">fs.watch</code> will not be able to function.  For example, watching files or
directories on network file systems (NFS, SMB, etc.) often doesn&#39;t work
reliably or at all.

</p>
<p>You can still use <code class="language-javascript">fs.watchFile</code>, which uses stat polling, but it is slower and
less reliable.

</p>
<h4>Filename Argument</h4>

<p>Providing <code class="language-javascript">filename</code> argument in the callback is not supported
on every platform (currently it&#39;s only supported on Linux and Windows).  Even
on supported platforms <code class="language-javascript">filename</code> is not always guaranteed to be provided.
Therefore, don&#39;t assume that <code class="language-javascript">filename</code> argument is always provided in the
callback, and have some fallback logic if it is null.

</p>
<pre><code class="language-javascript">fs.watch(&#39;somedir&#39;, function (event, filename) {
  console.log(&#39;event is: &#39; + event);
  if (filename) {
    console.log(&#39;filename provided: &#39; + filename);
  } else {
    console.log(&#39;filename not provided&#39;);
  }
});</code></pre>
<!--next-->
<h2>fs.exists(path, callback)</h2>
<p>Test whether or not the given path exists by checking with the file system.
Then call the <code class="language-javascript">callback</code> argument with either true or false.  Example:

</p>
<pre><code class="language-javascript">fs.exists(&#39;/etc/passwd&#39;, function (exists) {
  util.debug(exists ? &quot;it&#39;s there&quot; : &quot;no passwd!&quot;);
});</code></pre>
<p><code class="language-javascript">fs.exists()</code> is an anachronism and exists only for historical reasons.
There should almost never be a reason to use it in your own code.

</p>
<p>In particular, checking if a file exists before opening it is an anti-pattern
that leaves you vulnerable to race conditions: another process may remove the
file between the calls to <code class="language-javascript">fs.exists()</code> and <code class="language-javascript">fs.open()</code>.  Just open the file
and handle the error when it&#39;s not there.

</p>
<p><code class="language-javascript">fs.exists()</code> will be deprecated.

</p>
<!--next-->
<h2>fs.existsSync(path)</h2>
<p>Synchronous version of <code class="language-javascript">fs.exists</code>.

</p>
<p><code class="language-javascript">fs.existsSync()</code> will be deprecated.

</p>
<!--next-->
<h2>fs.access(path[, mode], callback)</h2>
<p>Tests a user&#39;s permissions for the file specified by <code class="language-javascript">path</code>. <code class="language-javascript">mode</code> is an
optional integer that specifies the accessibility checks to be performed. The
following constants define the possible values of <code class="language-javascript">mode</code>. It is possible to
create a mask consisting of the bitwise OR of two or more values.

</p>
<ul>
<li><code class="language-javascript">fs.F_OK</code> - File is visible to the calling process. This is useful for
determining if a file exists, but says nothing about <code class="language-javascript">rwx</code> permissions.
Default if no <code class="language-javascript">mode</code> is specified.</li>
<li><code class="language-javascript">fs.R_OK</code> - File can be read by the calling process.</li>
<li><code class="language-javascript">fs.W_OK</code> - File can be written by the calling process.</li>
<li><code class="language-javascript">fs.X_OK</code> - File can be executed by the calling process. This has no effect
on Windows (will behave like <code class="language-javascript">fs.F_OK</code>).</li>
</ul>
<p>The final argument, <code class="language-javascript">callback</code>, is a callback function that is invoked with
a possible error argument. If any of the accessibility checks fail, the error
argument will be populated. The following example checks if the file
<code class="language-javascript">/etc/passwd</code> can be read and written by the current process.

</p>
<pre><code class="language-javascript">fs.access(&#39;/etc/passwd&#39;, fs.R_OK | fs.W_OK, function(err) {
  util.debug(err ? &#39;no access!&#39; : &#39;can read/write&#39;);
});</code></pre>
<!--next-->
<h2>fs.accessSync(path[, mode])</h2>
<p>Synchronous version of <code class="language-javascript">fs.access</code>. This throws if any accessibility checks
fail, and does nothing otherwise.

</p>
<!--next-->
<h2>Class: fs.Stats</h2>
<p>Objects returned from <code class="language-javascript">fs.stat()</code>, <code class="language-javascript">fs.lstat()</code> and <code class="language-javascript">fs.fstat()</code> and their
synchronous counterparts are of this type.

</p>
<ul>
<li><code class="language-javascript">stats.isFile()</code></li>
<li><code class="language-javascript">stats.isDirectory()</code></li>
<li><code class="language-javascript">stats.isBlockDevice()</code></li>
<li><code class="language-javascript">stats.isCharacterDevice()</code></li>
<li><code class="language-javascript">stats.isSymbolicLink()</code> (only valid with  <code class="language-javascript">fs.lstat()</code>)</li>
<li><code class="language-javascript">stats.isFIFO()</code></li>
<li><code class="language-javascript">stats.isSocket()</code></li>
</ul>
<p>For a regular file <code class="language-javascript">util.inspect(stats)</code> would return a string very
similar to this:

</p>
<pre><code class="language-javascript">{ dev: 2114,
  ino: 48064969,
  mode: 33188,
  nlink: 1,
  uid: 85,
  gid: 100,
  rdev: 0,
  size: 527,
  blksize: 4096,
  blocks: 8,
  atime: Mon, 10 Oct 2011 23:24:11 GMT,
  mtime: Mon, 10 Oct 2011 23:24:11 GMT,
  ctime: Mon, 10 Oct 2011 23:24:11 GMT,
  birthtime: Mon, 10 Oct 2011 23:24:11 GMT }</code></pre>
<p>Please note that <code class="language-javascript">atime</code>, <code class="language-javascript">mtime</code>, <code class="language-javascript">birthtime</code>, and <code class="language-javascript">ctime</code> are
instances of <a>Date</a> object and to compare the values of
these objects you should use appropriate methods. For most general
uses <a>getTime()</a> will return the number of
milliseconds elapsed since <em>1 January 1970 00:00:00 UTC</em> and this
integer should be sufficient for any comparison, however there are
additional methods which can be used for displaying fuzzy information.
More details can be found in the <a>MDN JavaScript Reference</a>
page.

</p>
<!--next-->
<h2>Stat Time Values</h2>
<p>The times in the stat object have the following semantics:

</p>
<ul>
<li><code class="language-javascript">atime</code> &quot;Access Time&quot; - Time when file data last accessed.  Changed
by the <code class="language-javascript">mknod(2)</code>, <code class="language-javascript">utimes(2)</code>, and <code class="language-javascript">read(2)</code> system calls.</li>
<li><code class="language-javascript">mtime</code> &quot;Modified Time&quot; - Time when file data last modified.
Changed by the <code class="language-javascript">mknod(2)</code>, <code class="language-javascript">utimes(2)</code>, and <code class="language-javascript">write(2)</code> system calls.</li>
<li><code class="language-javascript">ctime</code> &quot;Change Time&quot; - Time when file status was last changed
(inode data modification).  Changed by the <code class="language-javascript">chmod(2)</code>, <code class="language-javascript">chown(2)</code>,
<code class="language-javascript">link(2)</code>, <code class="language-javascript">mknod(2)</code>, <code class="language-javascript">rename(2)</code>, <code class="language-javascript">unlink(2)</code>, <code class="language-javascript">utimes(2)</code>,
<code class="language-javascript">read(2)</code>, and <code class="language-javascript">write(2)</code> system calls.</li>
<li><code class="language-javascript">birthtime</code> &quot;Birth Time&quot; -  Time of file creation. Set once when the
file is created.  On filesystems where birthtime is not available,
this field may instead hold either the <code class="language-javascript">ctime</code> or
<code class="language-javascript">1970-01-01T00:00Z</code> (ie, unix epoch timestamp <code class="language-javascript">0</code>).  On Darwin and
other FreeBSD variants, also set if the <code class="language-javascript">atime</code> is explicitly set to
an earlier value than the current <code class="language-javascript">birthtime</code> using the <code class="language-javascript">utimes(2)</code>
system call.</li>
</ul>
<p>Prior to Node v0.12, the <code class="language-javascript">ctime</code> held the <code class="language-javascript">birthtime</code> on Windows
systems.  Note that as of v0.12, <code class="language-javascript">ctime</code> is not &quot;creation time&quot;, and
on Unix systems, it never was.

</p>
<!--next-->
<h2>fs.createReadStream(path[, options])</h2>
<p>Returns a new ReadStream object (See <code class="language-javascript">Readable Stream</code>).

</p>
<p><code class="language-javascript">options</code> is an object with the following defaults:

</p>
<pre><code class="language-javascript">{ flags: &#39;r&#39;,
  encoding: null,
  fd: null,
  mode: 0666,
  autoClose: true
}</code></pre>
<p><code class="language-javascript">options</code> can include <code class="language-javascript">start</code> and <code class="language-javascript">end</code> values to read a range of bytes from
the file instead of the entire file.  Both <code class="language-javascript">start</code> and <code class="language-javascript">end</code> are inclusive and
start at 0. The <code class="language-javascript">encoding</code> can be <code class="language-javascript">&#39;utf8&#39;</code>, <code class="language-javascript">&#39;ascii&#39;</code>, or <code class="language-javascript">&#39;base64&#39;</code>.

</p>
<p>If <code class="language-javascript">fd</code> is specified, <code class="language-javascript">ReadStream</code> will ignore the <code class="language-javascript">path</code> argument and will use
the specified file descriptor. This means that no <code class="language-javascript">open</code> event will be emitted.

</p>
<p>If <code class="language-javascript">autoClose</code> is false, then the file descriptor won&#39;t be closed, even if
there&#39;s an error.  It is your responsibility to close it and make sure
there&#39;s no file descriptor leak.  If <code class="language-javascript">autoClose</code> is set to true (default
behavior), on <code class="language-javascript">error</code> or <code class="language-javascript">end</code> the file descriptor will be closed
automatically.

</p>
<p>An example to read the last 10 bytes of a file which is 100 bytes long:

</p>
<pre><code class="language-javascript">fs.createReadStream(&#39;sample.txt&#39;, {start: 90, end: 99});</code></pre>
<!--next-->
<h2>Class: fs.ReadStream</h2>
<p><code class="language-javascript">ReadStream</code> is a <a>Readable Stream</a>.

</p>
<!--next-->
<h2>Event: &#39;open&#39;</h2>
<div class="signature"><ul>
<li><code class="language-javascript">fd</code> <span class="type">Integer</span> file descriptor used by the ReadStream.</li>
</div></ul>
<p>Emitted when the ReadStream&#39;s file is opened.


</p>
<!--next-->
<h2>fs.createWriteStream(path[, options])</h2>
<p>Returns a new WriteStream object (See <code class="language-javascript">Writable Stream</code>).

</p>
<p><code class="language-javascript">options</code> is an object with the following defaults:

</p>
<pre><code class="language-javascript">{ flags: &#39;w&#39;,
  encoding: null,
  fd: null,
  mode: 0666 }</code></pre>
<p><code class="language-javascript">options</code> may also include a <code class="language-javascript">start</code> option to allow writing data at
some position past the beginning of the file.  Modifying a file rather
than replacing it may require a <code class="language-javascript">flags</code> mode of <code class="language-javascript">r+</code> rather than the
default mode <code class="language-javascript">w</code>.

</p>
<p>Like <code class="language-javascript">ReadStream</code> above, if <code class="language-javascript">fd</code> is specified, <code class="language-javascript">WriteStream</code> will ignore the
<code class="language-javascript">path</code> argument and will use the specified file descriptor. This means that no
<code class="language-javascript">open</code> event will be emitted.


</p>
<!--next-->
<h2>Class: fs.WriteStream</h2>
<p><code class="language-javascript">WriteStream</code> is a <a>Writable Stream</a>.

</p>
<!--next-->
<h2>Event: &#39;open&#39;</h2>
<div class="signature"><ul>
<li><code class="language-javascript">fd</code> <span class="type">Integer</span> file descriptor used by the WriteStream.</li>
</div></ul>
<p>Emitted when the WriteStream&#39;s file is opened.

</p>
<!--next-->
<h2>file.bytesWritten</h2>
<p>The number of bytes written so far. Does not include data that is still queued
for writing.

</p>
<!--next-->
<h2>Class: fs.FSWatcher</h2>
<p>Objects returned from <code class="language-javascript">fs.watch()</code> are of this type.

</p>
<!--next-->
<h2>watcher.close()</h2>
<p>Stop watching for changes on the given <code class="language-javascript">fs.FSWatcher</code>.

</p>
<!--next-->
<h2>Event: &#39;change&#39;</h2>
<div class="signature"><ul>
<li><code class="language-javascript">event</code> <span class="type">String</span> The type of fs change</li>
<li><code class="language-javascript">filename</code> <span class="type">String</span> The filename that changed (if relevant/available)</li>
</div></ul>
<p>Emitted when something changes in a watched directory or file.
See more details in <a>fs.watch</a>.

</p>
<!--next-->
<h2>Event: &#39;error&#39;</h2>
<div class="signature"><ul>
<li><code class="language-javascript">error</code> <span class="type">Error object</span></li>
</div></ul>
<p>Emitted when an error occurs.

</p>
<!--next-->
<h2>Path</h2>
<pre class="stability">Stability: 3 - Stable</pre><p>This module contains utilities for handling and transforming file
paths.  Almost all these methods perform only string transformations.
The file system is not consulted to check whether paths are valid.

</p>
<p>Use <code class="language-javascript">require(&#39;path&#39;)</code> to use this module.  The following methods are provided:

</p>
<!--next-->
<h2>path.normalize(p)</h2>
<p>Normalize a string path, taking care of <code class="language-javascript">&#39;..&#39;</code> and <code class="language-javascript">&#39;.&#39;</code> parts.

</p>
<p>When multiple slashes are found, they&#39;re replaced by a single one;
when the path contains a trailing slash, it is preserved.
On Windows backslashes are used.

</p>
<p>Example:

</p>
<pre><code class="language-javascript">path.normalize(&#39;/foo/bar//baz/asdf/quux/..&#39;)
// returns
&#39;/foo/bar/baz/asdf&#39;</code></pre>
<!--next-->
<h2>path.join([path2][, path2][, ...])</h2>
<p>Join all arguments together and normalize the resulting path.

</p>
<p>Arguments must be strings.  In v0.8, non-string arguments were
silently ignored.  In v0.10 and up, an exception is thrown.

</p>
<p>Example:

</p>
<pre><code class="language-javascript">path.join(&#39;/foo&#39;, &#39;bar&#39;, &#39;baz/asdf&#39;, &#39;quux&#39;, &#39;..&#39;)
// returns
&#39;/foo/bar/baz/asdf&#39;

path.join(&#39;foo&#39;, {}, &#39;bar&#39;)
// throws exception
TypeError: Arguments to path.join must be strings</code></pre>
<!--next-->
<h2>path.resolve([from ...], to)</h2>
<p>Resolves <code class="language-javascript">to</code> to an absolute path.

</p>
<p>If <code class="language-javascript">to</code> isn&#39;t already absolute <code class="language-javascript">from</code> arguments are prepended in right to left
order, until an absolute path is found. If after using all <code class="language-javascript">from</code> paths still
no absolute path is found, the current working directory is used as well. The
resulting path is normalized, and trailing slashes are removed unless the path
gets resolved to the root directory. Non-string <code class="language-javascript">from</code> arguments are ignored.

</p>
<p>Another way to think of it is as a sequence of <code class="language-javascript">cd</code> commands in a shell.

</p>
<pre><code class="language-javascript">path.resolve(&#39;foo/bar&#39;, &#39;/tmp/file/&#39;, &#39;..&#39;, &#39;a/../subfile&#39;)</code></pre>
<p>Is similar to:

</p>
<pre><code class="language-javascript">cd foo/bar
cd /tmp/file/
cd ..
cd a/../subfile
pwd</code></pre>
<p>The difference is that the different paths don&#39;t need to exist and may also be
files.

</p>
<p>Examples:

</p>
<pre><code class="language-javascript">path.resolve(&#39;/foo/bar&#39;, &#39;./baz&#39;)
// returns
&#39;/foo/bar/baz&#39;

path.resolve(&#39;/foo/bar&#39;, &#39;/tmp/file/&#39;)
// returns
&#39;/tmp/file&#39;

path.resolve(&#39;wwwroot&#39;, &#39;static_files/png/&#39;, &#39;../gif/image.gif&#39;)
// if currently in /home/myself/node, it returns
&#39;/home/myself/node/wwwroot/static_files/gif/image.gif&#39;</code></pre>
<!--next-->
<h2>path.isAbsolute(path)</h2>
<p>Determines whether <code class="language-javascript">path</code> is an absolute path. An absolute path will always
resolve to the same location, regardless of the working directory.

</p>
<p>Posix examples:

</p>
<pre><code class="language-javascript">path.isAbsolute(&#39;/foo/bar&#39;) // true
path.isAbsolute(&#39;/baz/..&#39;)  // true
path.isAbsolute(&#39;qux/&#39;)     // false
path.isAbsolute(&#39;.&#39;)        // false</code></pre>
<p>Windows examples:

</p>
<pre><code class="language-javascript">path.isAbsolute(&#39;//server&#39;)  // true
path.isAbsolute(&#39;C:/foo/..&#39;) // true
path.isAbsolute(&#39;bar\\baz&#39;)   // false
path.isAbsolute(&#39;.&#39;)         // false</code></pre>
<!--next-->
<h2>path.relative(from, to)</h2>
<p>Solve the relative path from <code class="language-javascript">from</code> to <code class="language-javascript">to</code>.

</p>
<p>At times we have two absolute paths, and we need to derive the relative
path from one to the other.  This is actually the reverse transform of
<code class="language-javascript">path.resolve</code>, which means we see that:

</p>
<pre><code class="language-javascript">path.resolve(from, path.relative(from, to)) == path.resolve(to)</code></pre>
<p>Examples:

</p>
<pre><code class="language-javascript">path.relative(&#39;C:\\orandea\\test\\aaa&#39;, &#39;C:\\orandea\\impl\\bbb&#39;)
// returns
&#39;..\\..\\impl\\bbb&#39;

path.relative(&#39;/data/orandea/test/aaa&#39;, &#39;/data/orandea/impl/bbb&#39;)
// returns
&#39;../../impl/bbb&#39;</code></pre>
<!--next-->
<h2>path.dirname(p)</h2>
<p>Return the directory name of a path.  Similar to the Unix <code class="language-javascript">dirname</code> command.

</p>
<p>Example:

</p>
<pre><code class="language-javascript">path.dirname(&#39;/foo/bar/baz/asdf/quux&#39;)
// returns
&#39;/foo/bar/baz/asdf&#39;</code></pre>
<!--next-->
<h2>path.basename(p[, ext])</h2>
<p>Return the last portion of a path.  Similar to the Unix <code class="language-javascript">basename</code> command.

</p>
<p>Example:

</p>
<pre><code class="language-javascript">path.basename(&#39;/foo/bar/baz/asdf/quux.html&#39;)
// returns
&#39;quux.html&#39;

path.basename(&#39;/foo/bar/baz/asdf/quux.html&#39;, &#39;.html&#39;)
// returns
&#39;quux&#39;</code></pre>
<!--next-->
<h2>path.extname(p)</h2>
<p>Return the extension of the path, from the last &#39;.&#39; to end of string
in the last portion of the path.  If there is no &#39;.&#39; in the last portion
of the path or the first character of it is &#39;.&#39;, then it returns
an empty string.  Examples:

</p>
<pre><code class="language-javascript">path.extname(&#39;index.html&#39;)
// returns
&#39;.html&#39;

path.extname(&#39;index.coffee.md&#39;)
// returns
&#39;.md&#39;

path.extname(&#39;index.&#39;)
// returns
&#39;.&#39;

path.extname(&#39;index&#39;)
// returns
&#39;&#39;</code></pre>
<!--next-->
<h2>path.sep</h2>
<p>The platform-specific file separator. <code class="language-javascript">&#39;\\&#39;</code> or <code class="language-javascript">&#39;/&#39;</code>.

</p>
<p>An example on *nix:

</p>
<pre><code class="language-javascript">&#39;foo/bar/baz&#39;.split(path.sep)
// returns
[&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;]</code></pre>
<p>An example on Windows:

</p>
<pre><code class="language-javascript">&#39;foo\\bar\\baz&#39;.split(path.sep)
// returns
[&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;]</code></pre>
<!--next-->
<h2>path.delimiter</h2>
<p>The platform-specific path delimiter, <code class="language-javascript">;</code> or <code class="language-javascript">&#39;:&#39;</code>.

</p>
<p>An example on *nix:

</p>
<pre><code class="language-javascript">console.log(process.env.PATH)
// &#39;/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin&#39;

process.env.PATH.split(path.delimiter)
// returns
[&#39;/usr/bin&#39;, &#39;/bin&#39;, &#39;/usr/sbin&#39;, &#39;/sbin&#39;, &#39;/usr/local/bin&#39;]</code></pre>
<p>An example on Windows:

</p>
<pre><code class="language-javascript">console.log(process.env.PATH)
// &#39;C:\Windows\system32;C:\Windows;C:\Program Files\nodejs\&#39;

process.env.PATH.split(path.delimiter)
// returns
[&#39;C:\Windows\system32&#39;, &#39;C:\Windows&#39;, &#39;C:\Program Files\nodejs\&#39;]</code></pre>
<!--next-->
<h2>path.parse(pathString)</h2>
<p>Returns an object from a path string.

</p>
<p>An example on *nix:

</p>
<pre><code class="language-javascript">path.parse(&#39;/home/user/dir/file.txt&#39;)
// returns
{
    root : &quot;/&quot;,
    dir : &quot;/home/user/dir&quot;,
    base : &quot;file.txt&quot;,
    ext : &quot;.txt&quot;,
    name : &quot;file&quot;
}</code></pre>
<p>An example on Windows:

</p>
<pre><code class="language-javascript">path.parse(&#39;C:\\path\\dir\\index.html&#39;)
// returns
{
    root : &quot;C:\&quot;,
    dir : &quot;C:\path\dir&quot;,
    base : &quot;index.html&quot;,
    ext : &quot;.html&quot;,
    name : &quot;index&quot;
}</code></pre>
<!--next-->
<h2>path.format(pathObject)</h2>
<p>Returns a path string from an object, the opposite of <code class="language-javascript">path.parse</code> above.

</p>
<pre><code class="language-javascript">path.format({
    root : &quot;/&quot;,
    dir : &quot;/home/user/dir&quot;,
    base : &quot;file.txt&quot;,
    ext : &quot;.txt&quot;,
    name : &quot;file&quot;
})
// returns
&#39;/home/user/dir/file.txt&#39;</code></pre>
<!--next-->
<h2>path.posix</h2>
<p>Provide access to aforementioned <code class="language-javascript">path</code> methods but always interact in a posix
compatible way.

</p>
<!--next-->
<h2>path.win32</h2>
<p>Provide access to aforementioned <code class="language-javascript">path</code> methods but always interact in a win32
compatible way.

</p>
<!--next-->
<h2>net</h2>
<pre class="stability">Stability: 3 - Stable</pre><p>The <code class="language-javascript">net</code> module provides you with an asynchronous network wrapper. It contains
methods for creating both servers and clients (called streams). You can include
this module with <code class="language-javascript">require(&#39;net&#39;);</code>

</p>
<!--next-->
<h2>net.createServer([options][, connectionListener])</h2>
<p>Creates a new TCP server. The <code class="language-javascript">connectionListener</code> argument is
automatically set as a listener for the <a>&#39;connection&#39;</a> event.

</p>
<p><code class="language-javascript">options</code> is an object with the following defaults:

</p>
<pre><code class="language-javascript">{
  allowHalfOpen: false,
  pauseOnConnect: false
}</code></pre>
<p>If <code class="language-javascript">allowHalfOpen</code> is <code class="language-javascript">true</code>, then the socket won&#39;t automatically send a FIN
packet when the other end of the socket sends a FIN packet. The socket becomes
non-readable, but still writable. You should call the <code class="language-javascript">end()</code> method explicitly.
See <a>&#39;end&#39;</a> event for more information.

</p>
<p>If <code class="language-javascript">pauseOnConnect</code> is <code class="language-javascript">true</code>, then the socket associated with each incoming
connection will be paused, and no data will be read from its handle. This allows
connections to be passed between processes without any data being read by the
original process. To begin reading data from a paused socket, call <code class="language-javascript">resume()</code>.

</p>
<p>Here is an example of an echo server which listens for connections
on port 8124:

</p>
<pre><code class="language-javascript">var net = require(&#39;net&#39;);
var server = net.createServer(function(c) { //&#39;connection&#39; listener
  console.log(&#39;client connected&#39;);
  c.on(&#39;end&#39;, function() {
    console.log(&#39;client disconnected&#39;);
  });
  c.write(&#39;hello\r\n&#39;);
  c.pipe(c);
});
server.listen(8124, function() { //&#39;listening&#39; listener
  console.log(&#39;server bound&#39;);
});</code></pre>
<p>Test this by using <code class="language-javascript">telnet</code>:

</p>
<pre><code class="language-javascript">telnet localhost 8124</code></pre>
<p>To listen on the socket <code class="language-javascript">/tmp/echo.sock</code> the third line from the last would
just be changed to

</p>
<pre><code class="language-javascript">server.listen(&#39;/tmp/echo.sock&#39;, function() { //&#39;listening&#39; listener</code></pre>
<p>Use <code class="language-javascript">nc</code> to connect to a UNIX domain socket server:

</p>
<pre><code class="language-javascript">nc -U /tmp/echo.sock</code></pre>
<!--next-->
<h2>net.connect(options[, connectionListener])</h2>
<!--next-->
<h2>net.createConnection(options[, connectionListener])</h2>
<p>A factory method, which returns a new <a>&#39;net.Socket&#39;</a>
and connects to the supplied address and port.

</p>
<p>When the socket is established, the <a>&#39;connect&#39;</a> event will be emitted.

</p>
<p>Has the same events as <a>&#39;net.Socket&#39;</a>.

</p>
<p>For TCP sockets, <code class="language-javascript">options</code> argument should be an object which specifies:

</p>
<ul>
<li><p><code class="language-javascript">port</code>: Port the client should connect to (Required).</p>
</li>
<li><p><code class="language-javascript">host</code>: Host the client should connect to. Defaults to <code class="language-javascript">&#39;localhost&#39;</code>.</p>
</li>
<li><p><code class="language-javascript">localAddress</code>: Local interface to bind to for network connections.</p>
</li>
<li><p><code class="language-javascript">localPort</code>: Local port to bind to for network connections.</p>
</li>
<li><p><code class="language-javascript">family</code> : Version of IP stack. Defaults to <code class="language-javascript">4</code>.</p>
</li>
</ul>
<p>For local domain sockets, <code class="language-javascript">options</code> argument should be an object which
specifies:

</p>
<ul>
<li><code class="language-javascript">path</code>: Path the client should connect to (Required).</li>
</ul>
<p>Common options are:

</p>
<ul>
<li><code class="language-javascript">allowHalfOpen</code>: if <code class="language-javascript">true</code>, the socket won&#39;t automatically send
a FIN packet when the other end of the socket sends a FIN packet.
Defaults to <code class="language-javascript">false</code>.  See <a>&#39;end&#39;</a> event for more information.</li>
</ul>
<p>The <code class="language-javascript">connectListener</code> parameter will be added as an listener for the
<a>&#39;connect&#39;</a> event.

</p>
<p>Here is an example of a client of echo server as described previously:

</p>
<pre><code class="language-javascript">var net = require(&#39;net&#39;);
var client = net.connect({port: 8124},
    function() { //&#39;connect&#39; listener
  console.log(&#39;connected to server!&#39;);
  client.write(&#39;world!\r\n&#39;);
});
client.on(&#39;data&#39;, function(data) {
  console.log(data.toString());
  client.end();
});
client.on(&#39;end&#39;, function() {
  console.log(&#39;disconnected from server&#39;);
});</code></pre>
<p>To connect on the socket <code class="language-javascript">/tmp/echo.sock</code> the second line would just be
changed to

</p>
<pre><code class="language-javascript">var client = net.connect({path: &#39;/tmp/echo.sock&#39;});</code></pre>
<!--next-->
<h2>net.connect(port[, host][, connectListener])</h2>
<!--next-->
<h2>net.createConnection(port[, host][, connectListener])</h2>
<p>Creates a TCP connection to <code class="language-javascript">port</code> on <code class="language-javascript">host</code>. If <code class="language-javascript">host</code> is omitted,
<code class="language-javascript">&#39;localhost&#39;</code> will be assumed.
The <code class="language-javascript">connectListener</code> parameter will be added as an listener for the
<a>&#39;connect&#39;</a> event.

</p>
<p>Is a factory method which returns a new <a>&#39;net.Socket&#39;</a>.

</p>
<!--next-->
<h2>net.connect(path[, connectListener])</h2>
<!--next-->
<h2>net.createConnection(path[, connectListener])</h2>
<p>Creates unix socket connection to <code class="language-javascript">path</code>.
The <code class="language-javascript">connectListener</code> parameter will be added as an listener for the
<a>&#39;connect&#39;</a> event.

</p>
<p>A factory method which returns a new <a>&#39;net.Socket&#39;</a>.

</p>
<!--next-->
<h2>Class: net.Server</h2>
<p>This class is used to create a TCP or local server.

</p>
<!--next-->
<h2>server.listen(port[, host][, backlog][, callback])</h2>
<p>Begin accepting connections on the specified <code class="language-javascript">port</code> and <code class="language-javascript">host</code>.  If the
<code class="language-javascript">host</code> is omitted, the server will accept connections directed to any
IPv4 address (<code class="language-javascript">INADDR_ANY</code>). A port value of zero will assign a random port.

</p>
<p>Backlog is the maximum length of the queue of pending connections.
The actual length will be determined by your OS through sysctl settings such as
<code class="language-javascript">tcp_max_syn_backlog</code> and <code class="language-javascript">somaxconn</code> on linux. The default value of this
parameter is 511 (not 512).

</p>
<p>This function is asynchronous.  When the server has been bound,
<a>&#39;listening&#39;</a> event will be emitted.  The last parameter <code class="language-javascript">callback</code>
will be added as an listener for the <a>&#39;listening&#39;</a> event.

</p>
<p>One issue some users run into is getting <code class="language-javascript">EADDRINUSE</code> errors. This means that
another server is already running on the requested port. One way of handling this
would be to wait a second and then try again. This can be done with

</p>
<pre><code class="language-javascript">server.on(&#39;error&#39;, function (e) {
  if (e.code == &#39;EADDRINUSE&#39;) {
    console.log(&#39;Address in use, retrying...&#39;);
    setTimeout(function () {
      server.close();
      server.listen(PORT, HOST);
    }, 1000);
  }
});</code></pre>
<p>(Note: All sockets in Node set <code class="language-javascript">SO_REUSEADDR</code> already)


</p>
<!--next-->
<h2>server.listen(path[, callback])</h2>
<div class="signature"><ul>
<li><code class="language-javascript">path</code> <span class="type">String</span></li>
<li><code class="language-javascript">callback</code> <span class="type">Function</span></li>
</div></ul>
<p>Start a local socket server listening for connections on the given <code class="language-javascript">path</code>.

</p>
<p>This function is asynchronous.  When the server has been bound,
<a>&#39;listening&#39;</a> event will be emitted.  The last parameter <code class="language-javascript">callback</code>
will be added as an listener for the <a>&#39;listening&#39;</a> event.

</p>
<p>On UNIX, the local domain is usually known as the UNIX domain. The path is a
filesystem path name. It is subject to the same naming conventions and
permissions checks as would be done on file creation, will be visible in the
filesystem, and will <em>persist until unlinked</em>.

</p>
<p>On Windows, the local domain is implemented using a named pipe. The path <em>must</em>
refer to an entry in <code class="language-javascript">\\?\pipe\</code> or <code class="language-javascript">\\.\pipe\</code>. Any characters are permitted,
but the latter may do some processing of pipe names, such as resolving <code class="language-javascript">..</code>
sequences. Despite appearances, the pipe name space is flat.  Pipes will <em>not
persist</em>, they are removed when the last reference to them is closed. Do not
forget javascript string escaping requires paths to be specified with
double-backslashes, such as:

</p>
<pre><code class="language-javascript">net.createServer().listen(
    path.join(&#39;\\\\?\\pipe&#39;, process.cwd(), &#39;myctl&#39;))</code></pre>
<!--next-->
<h2>server.listen(handle[, callback])</h2>
<div class="signature"><ul>
<li><code class="language-javascript">handle</code> <span class="type">Object</span></li>
<li><code class="language-javascript">callback</code> <span class="type">Function</span></li>
</div></ul>
<p>The <code class="language-javascript">handle</code> object can be set to either a server or socket (anything
with an underlying <code class="language-javascript">_handle</code> member), or a <code class="language-javascript">{fd: &lt;n&gt;}</code> object.

</p>
<p>This will cause the server to accept connections on the specified
handle, but it is presumed that the file descriptor or handle has
already been bound to a port or domain socket.

</p>
<p>Listening on a file descriptor is not supported on Windows.

</p>
<p>This function is asynchronous.  When the server has been bound,
<a>&#39;listening&#39;</a> event will be emitted.
the last parameter <code class="language-javascript">callback</code> will be added as an listener for the
<a>&#39;listening&#39;</a> event.

</p>
<!--next-->
<h2>server.listen(options[, callback])</h2>
<div class="signature"><ul>
<li><code class="language-javascript">options</code> <span class="type">Object</span> - Required. Supports the following properties:<ul>
<li><code class="language-javascript">port</code> <span class="type">Number</span> - Optional.</li>
<li><code class="language-javascript">host</code> <span class="type">String</span> - Optional.</li>
<li><code class="language-javascript">backlog</code> <span class="type">Number</span> - Optional.</li>
<li><code class="language-javascript">path</code> <span class="type">String</span> - Optional.</li>
<li><code class="language-javascript">exclusive</code> <span class="type">Boolean</span> - Optional.</li>
</ul>
</li>
<li><code class="language-javascript">callback</code> <span class="type">Function</span> - Optional.</li>
</div></ul>
<p>The <code class="language-javascript">port</code>, <code class="language-javascript">host</code>, and <code class="language-javascript">backlog</code> properties of <code class="language-javascript">options</code>, as well as the
optional callback function, behave as they do on a call to
<a>server.listen(port, [host], [backlog], [callback])
</a>. Alternatively, the <code class="language-javascript">path</code>
option can be used to specify a UNIX socket.

</p>
<p>If <code class="language-javascript">exclusive</code> is <code class="language-javascript">false</code> (default), then cluster workers will use the same
underlying handle, allowing connection handling duties to be shared. When
<code class="language-javascript">exclusive</code> is <code class="language-javascript">true</code>, the handle is not shared, and attempted port sharing
results in an error. An example which listens on an exclusive port is
shown below.

</p>
<pre><code class="language-javascript">server.listen({
  host: &#39;localhost&#39;,
  port: 80,
  exclusive: true
});</code></pre>
<!--next-->
<h2>server.close([callback])</h2>
<p>Stops the server from accepting new connections and keeps existing
connections. This function is asynchronous, the server is finally
closed when all connections are ended and the server emits a <code class="language-javascript">&#39;close&#39;</code>
event. Optionally, you can pass a callback to listen for the <code class="language-javascript">&#39;close&#39;</code>
event. If present, the callback is invoked with any potential error
as the first and only argument.

</p>
<!--next-->
<h2>server.address()</h2>
<p>Returns the bound address, the address family name and port of the server
as reported by the operating system.
Useful to find which port was assigned when giving getting an OS-assigned address.
Returns an object with three properties, e.g.
<code class="language-javascript">{ port: 12346, family: &#39;IPv4&#39;, address: &#39;127.0.0.1&#39; }</code>

</p>
<p>Example:

</p>
<pre><code class="language-javascript">var server = net.createServer(function (socket) {
  socket.end(&quot;goodbye\n&quot;);
});

// grab a random port.
server.listen(function() {
  address = server.address();
  console.log(&quot;opened server on %j&quot;, address);
});</code></pre>
<p>Don&#39;t call <code class="language-javascript">server.address()</code> until the <code class="language-javascript">&#39;listening&#39;</code> event has been emitted.

</p>
<!--next-->
<h2>server.unref()</h2>
<p>Calling <code class="language-javascript">unref</code> on a server will allow the program to exit if this is the only
active server in the event system. If the server is already <code class="language-javascript">unref</code>d calling
<code class="language-javascript">unref</code> again will have no effect.

</p>
<!--next-->
<h2>server.ref()</h2>
<p>Opposite of <code class="language-javascript">unref</code>, calling <code class="language-javascript">ref</code> on a previously <code class="language-javascript">unref</code>d server will <em>not</em>
let the program exit if it&#39;s the only server left (the default behavior). If
the server is <code class="language-javascript">ref</code>d calling <code class="language-javascript">ref</code> again will have no effect.

</p>
<!--next-->
<h2>server.maxConnections</h2>
<p>Set this property to reject connections when the server&#39;s connection count gets
high.

</p>
<p>It is not recommended to use this option once a socket has been sent to a child
with <code class="language-javascript">child_process.fork()</code>.

</p>
<!--next-->
<h2>server.connections</h2>
<p>This function is <strong>deprecated</strong>; please use <a>server.getConnections()</a> instead.
The number of concurrent connections on the server.

</p>
<p>This becomes <code class="language-javascript">null</code> when sending a socket to a child with
<code class="language-javascript">child_process.fork()</code>. To poll forks and get current number of active
connections use asynchronous <code class="language-javascript">server.getConnections</code> instead.

</p>
<!--next-->
<h2>server.getConnections(callback)</h2>
<p>Asynchronously get the number of concurrent connections on the server. Works
when sockets were sent to forks.

</p>
<p>Callback should take two arguments <code class="language-javascript">err</code> and <code class="language-javascript">count</code>.

</p>
<p><code class="language-javascript">net.Server</code> is an <a>EventEmitter</a> with the following events:

</p>
<!--next-->
<h2>Event: &#39;listening&#39;</h2>
<p>Emitted when the server has been bound after calling <code class="language-javascript">server.listen</code>.

</p>
<!--next-->
<h2>Event: &#39;connection&#39;</h2>
<div class="signature"><ul>
<li><span class="type">Socket object</span> The connection object</li>
</div></ul>
<p>Emitted when a new connection is made. <code class="language-javascript">socket</code> is an instance of
<code class="language-javascript">net.Socket</code>.

</p>
<!--next-->
<h2>Event: &#39;close&#39;</h2>
<p>Emitted when the server closes. Note that if connections exist, this
event is not emitted until all connections are ended.

</p>
<!--next-->
<h2>Event: &#39;error&#39;</h2>
<div class="signature"><ul>
<li><span class="type">Error Object</span></li>
</div></ul>
<p>Emitted when an error occurs.  The <code class="language-javascript">&#39;close&#39;</code> event will be called directly
following this event.  See example in discussion of <code class="language-javascript">server.listen</code>.

</p>
<!--next-->
<h2>Class: net.Socket</h2>
<p>This object is an abstraction of a TCP or local socket.  <code class="language-javascript">net.Socket</code>
instances implement a duplex Stream interface.  They can be created by the
user and used as a client (with <code class="language-javascript">connect()</code>) or they can be created by Node
and passed to the user through the <code class="language-javascript">&#39;connection&#39;</code> event of a server.

</p>
<!--next-->
<h2>new net.Socket([options])</h2>
<p>Construct a new socket object.

</p>
<p><code class="language-javascript">options</code> is an object with the following defaults:

</p>
<pre><code class="language-javascript">{ fd: null
  allowHalfOpen: false,
  readable: false,
  writable: false
}</code></pre>
<p><code class="language-javascript">fd</code> allows you to specify the existing file descriptor of socket.
Set <code class="language-javascript">readable</code> and/or <code class="language-javascript">writable</code> to <code class="language-javascript">true</code> to allow reads and/or writes on this
socket (NOTE: Works only when <code class="language-javascript">fd</code> is passed).
About <code class="language-javascript">allowHalfOpen</code>, refer to <code class="language-javascript">createServer()</code> and <code class="language-javascript">&#39;end&#39;</code> event.

</p>
<!--next-->
<h2>socket.connect(port[, host][, connectListener])</h2>
<!--next-->
<h2>socket.connect(path[, connectListener])</h2>
<p>Opens the connection for a given socket. If <code class="language-javascript">port</code> and <code class="language-javascript">host</code> are given,
then the socket will be opened as a TCP socket, if <code class="language-javascript">host</code> is omitted,
<code class="language-javascript">localhost</code> will be assumed. If a <code class="language-javascript">path</code> is given, the socket will be
opened as a unix socket to that path.

</p>
<p>Normally this method is not needed, as <code class="language-javascript">net.createConnection</code> opens the
socket. Use this only if you are implementing a custom Socket.

</p>
<p>This function is asynchronous. When the <a>&#39;connect&#39;</a> event is emitted the
socket is established. If there is a problem connecting, the <code class="language-javascript">&#39;connect&#39;</code> event
will not be emitted, the <code class="language-javascript">&#39;error&#39;</code> event will be emitted with the exception.

</p>
<p>The <code class="language-javascript">connectListener</code> parameter will be added as an listener for the
<a>&#39;connect&#39;</a> event.


</p>
<!--next-->
<h2>socket.bufferSize</h2>
<p><code class="language-javascript">net.Socket</code> has the property that <code class="language-javascript">socket.write()</code> always works. This is to
help users get up and running quickly. The computer cannot always keep up
with the amount of data that is written to a socket - the network connection
simply might be too slow. Node will internally queue up the data written to a
socket and send it out over the wire when it is possible. (Internally it is
polling on the socket&#39;s file descriptor for being writable).

</p>
<p>The consequence of this internal buffering is that memory may grow. This
property shows the number of characters currently buffered to be written.
(Number of characters is approximately equal to the number of bytes to be
written, but the buffer may contain strings, and the strings are lazily
encoded, so the exact number of bytes is not known.)

</p>
<p>Users who experience large or growing <code class="language-javascript">bufferSize</code> should attempt to
&quot;throttle&quot; the data flows in their program with <code class="language-javascript">pause()</code> and <code class="language-javascript">resume()</code>.


</p>
<!--next-->
<h2>socket.setEncoding([encoding])</h2>
<p>Set the encoding for the socket as a Readable Stream. See
<a>stream.setEncoding()</a> for more information.

</p>
<!--next-->
<h2>socket.write(data[, encoding][, callback])</h2>
<p>Sends data on the socket. The second parameter specifies the encoding in the
case of a string--it defaults to UTF8 encoding.

</p>
<p>Returns <code class="language-javascript">true</code> if the entire data was flushed successfully to the kernel
buffer. Returns <code class="language-javascript">false</code> if all or part of the data was queued in user memory.
<code class="language-javascript">&#39;drain&#39;</code> will be emitted when the buffer is again free.

</p>
<p>The optional <code class="language-javascript">callback</code> parameter will be executed when the data is finally
written out - this may not be immediately.

</p>
<!--next-->
<h2>socket.end([data][, encoding])</h2>
<p>Half-closes the socket. i.e., it sends a FIN packet. It is possible the
server will still send some data.

</p>
<p>If <code class="language-javascript">data</code> is specified, it is equivalent to calling
<code class="language-javascript">socket.write(data, encoding)</code> followed by <code class="language-javascript">socket.end()</code>.

</p>
<!--next-->
<h2>socket.destroy()</h2>
<p>Ensures that no more I/O activity happens on this socket. Only necessary in
case of errors (parse error or so).

</p>
<!--next-->
<h2>socket.pause()</h2>
<p>Pauses the reading of data. That is, <code class="language-javascript">&#39;data&#39;</code> events will not be emitted.
Useful to throttle back an upload.

</p>
<!--next-->
<h2>socket.resume()</h2>
<p>Resumes reading after a call to <code class="language-javascript">pause()</code>.

</p>
<!--next-->
<h2>socket.setTimeout(timeout[, callback])</h2>
<p>Sets the socket to timeout after <code class="language-javascript">timeout</code> milliseconds of inactivity on
the socket. By default <code class="language-javascript">net.Socket</code> do not have a timeout.

</p>
<p>When an idle timeout is triggered the socket will receive a <code class="language-javascript">&#39;timeout&#39;</code>
event but the connection will not be severed. The user must manually <code class="language-javascript">end()</code>
or <code class="language-javascript">destroy()</code> the socket.

</p>
<p>If <code class="language-javascript">timeout</code> is 0, then the existing idle timeout is disabled.

</p>
<p>The optional <code class="language-javascript">callback</code> parameter will be added as a one time listener for the
<code class="language-javascript">&#39;timeout&#39;</code> event.

</p>
<!--next-->
<h2>socket.setNoDelay([noDelay])</h2>
<p>Disables the Nagle algorithm. By default TCP connections use the Nagle
algorithm, they buffer data before sending it off. Setting <code class="language-javascript">true</code> for
<code class="language-javascript">noDelay</code> will immediately fire off data each time <code class="language-javascript">socket.write()</code> is called.
<code class="language-javascript">noDelay</code> defaults to <code class="language-javascript">true</code>.

</p>
<!--next-->
<h2>socket.setKeepAlive([enable][, initialDelay])</h2>
<p>Enable/disable keep-alive functionality, and optionally set the initial
delay before the first keepalive probe is sent on an idle socket.
<code class="language-javascript">enable</code> defaults to <code class="language-javascript">false</code>.

</p>
<p>Set <code class="language-javascript">initialDelay</code> (in milliseconds) to set the delay between the last
data packet received and the first keepalive probe. Setting 0 for
initialDelay will leave the value unchanged from the default
(or previous) setting. Defaults to <code class="language-javascript">0</code>.

</p>
<!--next-->
<h2>socket.address()</h2>
<p>Returns the bound address, the address family name and port of the
socket as reported by the operating system. Returns an object with
three properties, e.g.
<code class="language-javascript">{ port: 12346, family: &#39;IPv4&#39;, address: &#39;127.0.0.1&#39; }</code>

</p>
<!--next-->
<h2>socket.unref()</h2>
<p>Calling <code class="language-javascript">unref</code> on a socket will allow the program to exit if this is the only
active socket in the event system. If the socket is already <code class="language-javascript">unref</code>d calling
<code class="language-javascript">unref</code> again will have no effect.

</p>
<!--next-->
<h2>socket.ref()</h2>
<p>Opposite of <code class="language-javascript">unref</code>, calling <code class="language-javascript">ref</code> on a previously <code class="language-javascript">unref</code>d socket will <em>not</em>
let the program exit if it&#39;s the only socket left (the default behavior). If
the socket is <code class="language-javascript">ref</code>d calling <code class="language-javascript">ref</code> again will have no effect.

</p>
<!--next-->
<h2>socket.remoteAddress</h2>
<p>The string representation of the remote IP address. For example,
<code class="language-javascript">&#39;74.125.127.100&#39;</code> or <code class="language-javascript">&#39;2001:4860:a005::68&#39;</code>.

</p>
<!--next-->
<h2>socket.remoteFamily</h2>
<p>The string representation of the remote IP family. <code class="language-javascript">&#39;IPv4&#39;</code> or <code class="language-javascript">&#39;IPv6&#39;</code>.

</p>
<!--next-->
<h2>socket.remotePort</h2>
<p>The numeric representation of the remote port. For example,
<code class="language-javascript">80</code> or <code class="language-javascript">21</code>.

</p>
<!--next-->
<h2>socket.localAddress</h2>
<p>The string representation of the local IP address the remote client is
connecting on. For example, if you are listening on <code class="language-javascript">&#39;0.0.0.0&#39;</code> and the
client connects on <code class="language-javascript">&#39;192.168.1.1&#39;</code>, the value would be <code class="language-javascript">&#39;192.168.1.1&#39;</code>.

</p>
<!--next-->
<h2>socket.localPort</h2>
<p>The numeric representation of the local port. For example,
<code class="language-javascript">80</code> or <code class="language-javascript">21</code>.

</p>
<!--next-->
<h2>socket.bytesRead</h2>
<p>The amount of received bytes.

</p>
<!--next-->
<h2>socket.bytesWritten</h2>
<p>The amount of bytes sent.


</p>
<p><code class="language-javascript">net.Socket</code> instances are <a>EventEmitter</a> with the following events:

</p>
<!--next-->
<h2>Event: &#39;lookup&#39;</h2>
<p>Emitted after resolving the hostname but before connecting.
Not applicable to UNIX sockets.

</p>
<ul>
<li><code class="language-javascript">err</code> {Error | Null} The error object.  See <a>dns.lookup()</a>.</li>
<li><code class="language-javascript">address</code> {String} The IP address.</li>
<li><code class="language-javascript">family</code> {String | Null} The address type.  See <a>dns.lookup()</a>.</li>
</ul>
<!--next-->
<h2>Event: &#39;connect&#39;</h2>
<p>Emitted when a socket connection is successfully established.
See <code class="language-javascript">connect()</code>.

</p>
<!--next-->
<h2>Event: &#39;data&#39;</h2>
<div class="signature"><ul>
<li><span class="type">Buffer object</span></li>
</div></ul>
<p>Emitted when data is received.  The argument <code class="language-javascript">data</code> will be a <code class="language-javascript">Buffer</code> or
<code class="language-javascript">String</code>.  Encoding of data is set by <code class="language-javascript">socket.setEncoding()</code>.
(See the <a>Readable Stream</a> section for more information.)

</p>
<p>Note that the <strong>data will be lost</strong> if there is no listener when a <code class="language-javascript">Socket</code>
emits a <code class="language-javascript">&#39;data&#39;</code> event.

</p>
<!--next-->
<h2>Event: &#39;end&#39;</h2>
<p>Emitted when the other end of the socket sends a FIN packet.

</p>
<p>By default (<code class="language-javascript">allowHalfOpen == false</code>) the socket will destroy its file
descriptor  once it has written out its pending write queue.  However, by
setting <code class="language-javascript">allowHalfOpen == true</code> the socket will not automatically <code class="language-javascript">end()</code>
its side allowing the user to write arbitrary amounts of data, with the
caveat that the user is required to <code class="language-javascript">end()</code> their side now.


</p>
<!--next-->
<h2>Event: &#39;timeout&#39;</h2>
<p>Emitted if the socket times out from inactivity. This is only to notify that
the socket has been idle. The user must manually close the connection.

</p>
<p>See also: <code class="language-javascript">socket.setTimeout()</code>


</p>
<!--next-->
<h2>Event: &#39;drain&#39;</h2>
<p>Emitted when the write buffer becomes empty. Can be used to throttle uploads.

</p>
<p>See also: the return values of <code class="language-javascript">socket.write()</code>

</p>
<!--next-->
<h2>Event: &#39;error&#39;</h2>
<div class="signature"><ul>
<li><span class="type">Error object</span></li>
</div></ul>
<p>Emitted when an error occurs.  The <code class="language-javascript">&#39;close&#39;</code> event will be called directly
following this event.

</p>
<!--next-->
<h2>Event: &#39;close&#39;</h2>
<div class="signature"><ul>
<li><code class="language-javascript">had_error</code> <span class="type">Boolean</span> true if the socket had a transmission error</li>
</div></ul>
<p>Emitted once the socket is fully closed. The argument <code class="language-javascript">had_error</code> is a boolean
which says if the socket was closed due to a transmission error.

</p>
<!--next-->
<h2>net.isIP(input)</h2>
<p>Tests if input is an IP address. Returns 0 for invalid strings,
returns 4 for IP version 4 addresses, and returns 6 for IP version 6 addresses.


</p>
<!--next-->
<h2>net.isIPv4(input)</h2>
<p>Returns true if input is a version 4 IP address, otherwise returns false.


</p>
<!--next-->
<h2>net.isIPv6(input)</h2>
<p>Returns true if input is a version 6 IP address, otherwise returns false.

</p>
<!--next-->
<h2>UDP / Datagram Sockets</h2>
<pre class="stability">Stability: 3 - Stable</pre><!-- name=dgram -->

<p>Datagram sockets are available through <code class="language-javascript">require(&#39;dgram&#39;)</code>.

</p>
<p>Important note: the behavior of <code class="language-javascript">dgram.Socket#bind()</code> has changed in v0.10
and is always asynchronous now.  If you have code that looks like this:

</p>
<pre><code class="language-javascript">var s = dgram.createSocket(&#39;udp4&#39;);
s.bind(1234);
s.addMembership(&#39;224.0.0.114&#39;);</code></pre>
<p>You have to change it to this:

</p>
<pre><code class="language-javascript">var s = dgram.createSocket(&#39;udp4&#39;);
s.bind(1234, function() {
  s.addMembership(&#39;224.0.0.114&#39;);
});</code></pre>
<!--next-->
<h2>dgram.createSocket(type[, callback])</h2>
<div class="signature"><ul>
<li><code class="language-javascript">type</code> String. Either &#39;udp4&#39; or &#39;udp6&#39;</li>
<li><code class="language-javascript">callback</code> Function. Attached as a listener to <code class="language-javascript">message</code> events.
Optional</li>
<li>Returns: Socket object</li>
</div></ul>
<p>Creates a datagram Socket of the specified types.  Valid types are <code class="language-javascript">udp4</code>
and <code class="language-javascript">udp6</code>.

</p>
<p>Takes an optional callback which is added as a listener for <code class="language-javascript">message</code> events.

</p>
<p>Call <code class="language-javascript">socket.bind()</code> if you want to receive datagrams. <code class="language-javascript">socket.bind()</code> will
bind to the &quot;all interfaces&quot; address on a random port (it does the right thing
for both <code class="language-javascript">udp4</code> and <code class="language-javascript">udp6</code> sockets). You can then retrieve the address and port
with <code class="language-javascript">socket.address().address</code> and <code class="language-javascript">socket.address().port</code>.

</p>
<!--next-->
<h2>dgram.createSocket(options[, callback])</h2>
<div class="signature"><ul>
<li><code class="language-javascript">options</code> Object</li>
<li><code class="language-javascript">callback</code> Function. Attached as a listener to <code class="language-javascript">message</code> events.</li>
<li>Returns: Socket object</li>
</div></ul>
<p>The <code class="language-javascript">options</code> object should contain a <code class="language-javascript">type</code> field of either <code class="language-javascript">udp4</code> or <code class="language-javascript">udp6</code>
and an optional boolean <code class="language-javascript">reuseAddr</code> field.

</p>
<p>When <code class="language-javascript">reuseAddr</code> is true <code class="language-javascript">socket.bind()</code> will reuse the address, even if
another process has already bound a socket on it. <code class="language-javascript">reuseAddr</code> defaults to
<code class="language-javascript">false</code>.

</p>
<p>Takes an optional callback which is added as a listener for <code class="language-javascript">message</code> events.

</p>
<p>Call <code class="language-javascript">socket.bind()</code> if you want to receive datagrams. <code class="language-javascript">socket.bind()</code> will
bind to the &quot;all interfaces&quot; address on a random port (it does the right thing
for both <code class="language-javascript">udp4</code> and <code class="language-javascript">udp6</code> sockets). You can then retrieve the address and port
with <code class="language-javascript">socket.address().address</code> and <code class="language-javascript">socket.address().port</code>.

</p>
<!--next-->
<h2>Class: dgram.Socket</h2>
<p>The dgram Socket class encapsulates the datagram functionality.  It
should be created via <code class="language-javascript">dgram.createSocket(...)</code>

</p>
<!--next-->
<h2>Event: &#39;message&#39;</h2>
<div class="signature"><ul>
<li><code class="language-javascript">msg</code> Buffer object. The message</li>
<li><code class="language-javascript">rinfo</code> Object. Remote address information</li>
</div></ul>
<p>Emitted when a new datagram is available on a socket.  <code class="language-javascript">msg</code> is a <code class="language-javascript">Buffer</code> and
<code class="language-javascript">rinfo</code> is an object with the sender&#39;s address information:

</p>
<pre><code class="language-javascript">socket.on(&#39;message&#39;, function(msg, rinfo) {
  console.log(&#39;Received %d bytes from %s:%d\n&#39;,
              msg.length, rinfo.address, rinfo.port);
});</code></pre>
<!--next-->
<h2>Event: &#39;listening&#39;</h2>
<p>Emitted when a socket starts listening for datagrams.  This happens as soon as UDP sockets
are created.

</p>
<!--next-->
<h2>Event: &#39;close&#39;</h2>
<p>Emitted when a socket is closed with <code class="language-javascript">close()</code>.  No new <code class="language-javascript">message</code> events will be emitted
on this socket.

</p>
<!--next-->
<h2>Event: &#39;error&#39;</h2>
<div class="signature"><ul>
<li><code class="language-javascript">exception</code> Error object</li>
</div></ul>
<p>Emitted when an error occurs.

</p>
<!--next-->
<h2>socket.send(buf, offset, length, port, address[, callback])</h2>
<div class="signature"><ul>
<li><code class="language-javascript">buf</code> Buffer object or string.  Message to be sent</li>
<li><code class="language-javascript">offset</code> Integer. Offset in the buffer where the message starts.</li>
<li><code class="language-javascript">length</code> Integer. Number of bytes in the message.</li>
<li><code class="language-javascript">port</code> Integer. Destination port.</li>
<li><code class="language-javascript">address</code> String. Destination hostname or IP address.</li>
<li><code class="language-javascript">callback</code> Function. Called when the message has been sent. Optional.</li>
</div></ul>
<p>For UDP sockets, the destination port and address must be specified.  A string
may be supplied for the <code class="language-javascript">address</code> parameter, and it will be resolved with DNS.

</p>
<p>If the address is omitted or is an empty string, <code class="language-javascript">&#39;0.0.0.0&#39;</code> or <code class="language-javascript">&#39;::0&#39;</code> is used
instead.  Depending on the network configuration, those defaults may or may not
work; it&#39;s best to be explicit about the destination address.

</p>
<p>If the socket has not been previously bound with a call to <code class="language-javascript">bind</code>, it gets
assigned a random port number and is bound to the &quot;all interfaces&quot; address
(<code class="language-javascript">&#39;0.0.0.0&#39;</code> for <code class="language-javascript">udp4</code> sockets, <code class="language-javascript">&#39;::0&#39;</code> for <code class="language-javascript">udp6</code> sockets.)

</p>
<p>An optional callback may be specified to detect DNS errors or for determining
when it&#39;s safe to reuse the <code class="language-javascript">buf</code> object.  Note that DNS lookups delay the time
to send for at least one tick.  The only way to know for sure that the datagram
has been sent is by using a callback.

</p>
<p>With consideration for multi-byte characters, <code class="language-javascript">offset</code> and <code class="language-javascript">length</code> will
be calculated with respect to
<a>byte length</a>
and not the character position.

</p>
<p>Example of sending a UDP packet to a random port on <code class="language-javascript">localhost</code>;

</p>
<pre><code class="language-javascript">var dgram = require(&#39;dgram&#39;);
var message = new Buffer(&quot;Some bytes&quot;);
var client = dgram.createSocket(&quot;udp4&quot;);
client.send(message, 0, message.length, 41234, &quot;localhost&quot;, function(err) {
  client.close();
});</code></pre>
<p><strong>A Note about UDP datagram size</strong>

</p>
<p>The maximum size of an <code class="language-javascript">IPv4/v6</code> datagram depends on the <code class="language-javascript">MTU</code> (<em>Maximum Transmission Unit</em>)
and on the <code class="language-javascript">Payload Length</code> field size.

</p>
<ul>
<li><p>The <code class="language-javascript">Payload Length</code> field is <code class="language-javascript">16 bits</code> wide, which means that a normal payload
cannot be larger than 64K octets including internet header and data
(65,507 bytes = 65,535  8 bytes UDP header  20 bytes IP header);
this is generally true for loopback interfaces, but such long datagrams
are impractical for most hosts and networks.</p>
</li>
<li><p>The <code class="language-javascript">MTU</code> is the largest size a given link layer technology can support for datagrams.
For any link, <code class="language-javascript">IPv4</code> mandates a minimum <code class="language-javascript">MTU</code> of <code class="language-javascript">68</code> octets, while the recommended <code class="language-javascript">MTU</code>
for IPv4 is <code class="language-javascript">576</code> (typically recommended as the <code class="language-javascript">MTU</code> for dial-up type applications),
whether they arrive whole or in fragments.</p>
<p>For <code class="language-javascript">IPv6</code>, the minimum <code class="language-javascript">MTU</code> is <code class="language-javascript">1280</code> octets, however, the mandatory minimum
fragment reassembly buffer size is <code class="language-javascript">1500</code> octets.
The value of <code class="language-javascript">68</code> octets is very small, since most current link layer technologies have
a minimum <code class="language-javascript">MTU</code> of <code class="language-javascript">1500</code> (like Ethernet).</p>
</li>
</ul>
<p>Note that it&#39;s impossible to know in advance the MTU of each link through which
a packet might travel, and that generally sending a datagram greater than
the (receiver) <code class="language-javascript">MTU</code> won&#39;t work (the packet gets silently dropped, without
informing the source that the data did not reach its intended recipient).

</p>
<!--next-->
<h2>socket.bind(port[, address][, callback])</h2>
<div class="signature"><ul>
<li><code class="language-javascript">port</code> Integer</li>
<li><code class="language-javascript">address</code> String, Optional</li>
<li><code class="language-javascript">callback</code> Function with no parameters, Optional. Callback when
binding is done.</li>
</div></ul>
<p>For UDP sockets, listen for datagrams on a named <code class="language-javascript">port</code> and optional
<code class="language-javascript">address</code>. If <code class="language-javascript">address</code> is not specified, the OS will try to listen on
all addresses.  After binding is done, a &quot;listening&quot; event is emitted
and the <code class="language-javascript">callback</code>(if specified) is called. Specifying both a
&quot;listening&quot; event listener and <code class="language-javascript">callback</code> is not harmful but not very
useful.

</p>
<p>A bound datagram socket keeps the node process running to receive
datagrams.

</p>
<p>If binding fails, an &quot;error&quot; event is generated. In rare case (e.g.
binding a closed socket), an <code class="language-javascript">Error</code> may be thrown by this method.

</p>
<p>Example of a UDP server listening on port 41234:

</p>
<pre><code class="language-javascript">var dgram = require(&quot;dgram&quot;);

var server = dgram.createSocket(&quot;udp4&quot;);

server.on(&quot;error&quot;, function (err) {
  console.log(&quot;server error:\n&quot; + err.stack);
  server.close();
});

server.on(&quot;message&quot;, function (msg, rinfo) {
  console.log(&quot;server got: &quot; + msg + &quot; from &quot; +
    rinfo.address + &quot;:&quot; + rinfo.port);
});

server.on(&quot;listening&quot;, function () {
  var address = server.address();
  console.log(&quot;server listening &quot; +
      address.address + &quot;:&quot; + address.port);
});

server.bind(41234);
// server listening 0.0.0.0:41234</code></pre>
<!--next-->
<h2>socket.bind(options[, callback])</h2>
<div class="signature"><ul>
<li><code class="language-javascript">options</code> <span class="type">Object</span> - Required. Supports the following properties:<ul>
<li><code class="language-javascript">port</code> <span class="type">Number</span> - Required.</li>
<li><code class="language-javascript">address</code> <span class="type">String</span> - Optional.</li>
<li><code class="language-javascript">exclusive</code> <span class="type">Boolean</span> - Optional.</li>
</ul>
</li>
<li><code class="language-javascript">callback</code> <span class="type">Function</span> - Optional.</li>
</div></ul>
<p>The <code class="language-javascript">port</code> and <code class="language-javascript">address</code> properties of <code class="language-javascript">options</code>, as well as the optional
callback function, behave as they do on a call to
<a>socket.bind(port, [address], [callback])
</a>.

</p>
<p>If <code class="language-javascript">exclusive</code> is <code class="language-javascript">false</code> (default), then cluster workers will use the same
underlying handle, allowing connection handling duties to be shared. When
<code class="language-javascript">exclusive</code> is <code class="language-javascript">true</code>, the handle is not shared, and attempted port sharing
results in an error. An example which listens on an exclusive port is
shown below.

</p>
<pre><code class="language-javascript">socket.bind({
  address: &#39;localhost&#39;,
  port: 8000,
  exclusive: true
});</code></pre>
<!--next-->
<h2>socket.close()</h2>
<p>Close the underlying socket and stop listening for data on it.

</p>
<!--next-->
<h2>socket.address()</h2>
<p>Returns an object containing the address information for a socket.  For UDP sockets,
this object will contain <code class="language-javascript">address</code> , <code class="language-javascript">family</code> and <code class="language-javascript">port</code>.

</p>
<!--next-->
<h2>socket.setBroadcast(flag)</h2>
<div class="signature"><ul>
<li><code class="language-javascript">flag</code> Boolean</li>
</div></ul>
<p>Sets or clears the <code class="language-javascript">SO_BROADCAST</code> socket option.  When this option is set, UDP packets
may be sent to a local interface&#39;s broadcast address.

</p>
<!--next-->
<h2>socket.setTTL(ttl)</h2>
<div class="signature"><ul>
<li><code class="language-javascript">ttl</code> Integer</li>
</div></ul>
<p>Sets the <code class="language-javascript">IP_TTL</code> socket option.  TTL stands for &quot;Time to Live,&quot; but in this context it
specifies the number of IP hops that a packet is allowed to go through.  Each router or
gateway that forwards a packet decrements the TTL.  If the TTL is decremented to 0 by a
router, it will not be forwarded.  Changing TTL values is typically done for network
probes or when multicasting.

</p>
<p>The argument to <code class="language-javascript">setTTL()</code> is a number of hops between 1 and 255.  The default on most
systems is 64.

</p>
<!--next-->
<h2>socket.setMulticastTTL(ttl)</h2>
<div class="signature"><ul>
<li><code class="language-javascript">ttl</code> Integer</li>
</div></ul>
<p>Sets the <code class="language-javascript">IP_MULTICAST_TTL</code> socket option.  TTL stands for &quot;Time to Live,&quot; but in this
context it specifies the number of IP hops that a packet is allowed to go through,
specifically for multicast traffic.  Each router or gateway that forwards a packet
decrements the TTL. If the TTL is decremented to 0 by a router, it will not be forwarded.

</p>
<p>The argument to <code class="language-javascript">setMulticastTTL()</code> is a number of hops between 0 and 255.  The default on most
systems is 1.

</p>
<!--next-->
<h2>socket.setMulticastLoopback(flag)</h2>
<div class="signature"><ul>
<li><code class="language-javascript">flag</code> Boolean</li>
</div></ul>
<p>Sets or clears the <code class="language-javascript">IP_MULTICAST_LOOP</code> socket option.  When this option is set, multicast
packets will also be received on the local interface.

</p>
<!--next-->
<h2>socket.addMembership(multicastAddress[, multicastInterface])</h2>
<div class="signature"><ul>
<li><code class="language-javascript">multicastAddress</code> String</li>
<li><code class="language-javascript">multicastInterface</code> String, Optional</li>
</div></ul>
<p>Tells the kernel to join a multicast group with <code class="language-javascript">IP_ADD_MEMBERSHIP</code> socket option.

</p>
<p>If <code class="language-javascript">multicastInterface</code> is not specified, the OS will try to add membership to all valid
interfaces.

</p>
<!--next-->
<h2>socket.dropMembership(multicastAddress[, multicastInterface])</h2>
<div class="signature"><ul>
<li><code class="language-javascript">multicastAddress</code> String</li>
<li><code class="language-javascript">multicastInterface</code> String, Optional</li>
</div></ul>
<p>Opposite of <code class="language-javascript">addMembership</code> - tells the kernel to leave a multicast group with
<code class="language-javascript">IP_DROP_MEMBERSHIP</code> socket option. This is automatically called by the kernel
when the socket is closed or process terminates, so most apps will never need to call
this.

</p>
<p>If <code class="language-javascript">multicastInterface</code> is not specified, the OS will try to drop membership to all valid
interfaces.

</p>
<!--next-->
<h2>socket.unref()</h2>
<p>Calling <code class="language-javascript">unref</code> on a socket will allow the program to exit if this is the only
active socket in the event system. If the socket is already <code class="language-javascript">unref</code>d calling
<code class="language-javascript">unref</code> again will have no effect.

</p>
<!--next-->
<h2>socket.ref()</h2>
<p>Opposite of <code class="language-javascript">unref</code>, calling <code class="language-javascript">ref</code> on a previously <code class="language-javascript">unref</code>d socket will <em>not</em>
let the program exit if it&#39;s the only socket left (the default behavior). If
the socket is <code class="language-javascript">ref</code>d calling <code class="language-javascript">ref</code> again will have no effect.

</p>
<!--next-->
<h2>DNS</h2>
<pre class="stability">Stability: 3 - Stable</pre><p>Use <code class="language-javascript">require(&#39;dns&#39;)</code> to access this module.

</p>
<p>This module contains functions that belong to two different categories:

</p>
<p>1) Functions that use the underlying operating system facilities to perform
name resolution, and that do not necessarily do any network communication.
This category contains only one function: <code class="language-javascript">dns.lookup</code>. <strong>Developers looking
to perform name resolution in the same way that other applications on the same
operating system behave should use <code class="language-javascript">dns.lookup</code>.</strong>

</p>
<p>Here is an example that does a lookup of <code class="language-javascript">www.google.com</code>.

</p>
<pre><code class="language-javascript">var dns = require(&#39;dns&#39;);

dns.lookup(&#39;www.google.com&#39;, function onLookup(err, addresses, family) {
  console.log(&#39;addresses:&#39;, addresses);
});</code></pre>
<p>2) Functions that connect to an actual DNS server to perform name resolution,
and that <em>always</em> use the network to perform DNS queries. This category
contains all functions in the <code class="language-javascript">dns</code> module but <code class="language-javascript">dns.lookup</code>. These functions
do not use the same set of configuration files than what <code class="language-javascript">dns.lookup</code> uses.
For instance, <em>they do not use the configuration from <code class="language-javascript">/etc/hosts</code></em>. These
functions should be used by developers who do not want to use the underlying
operating system&#39;s facilities for name resolution, and instead want to
<em>always</em> perform DNS queries.

</p>
<p>Here is an example which resolves <code class="language-javascript">&#39;www.google.com&#39;</code> then reverse
resolves the IP addresses which are returned.

</p>
<pre><code class="language-javascript">var dns = require(&#39;dns&#39;);

dns.resolve4(&#39;www.google.com&#39;, function (err, addresses) {
  if (err) throw err;

  console.log(&#39;addresses: &#39; + JSON.stringify(addresses));

  addresses.forEach(function (a) {
    dns.reverse(a, function (err, hostnames) {
      if (err) {
        throw err;
      }

      console.log(&#39;reverse for &#39; + a + &#39;: &#39; + JSON.stringify(hostnames));
    });
  });
});</code></pre>
<p>There are subtle consequences in choosing one or another, please consult the
<a>Implementation considerations section</a>
for more information.

</p>
<!--next-->
<h2>dns.lookup(hostname[, options], callback)</h2>
<p>Resolves a hostname (e.g. <code class="language-javascript">&#39;google.com&#39;</code>) into the first found A (IPv4) or
AAAA (IPv6) record. <code class="language-javascript">options</code> can be an object or integer. If <code class="language-javascript">options</code> is
not provided, then IP v4 and v6 addresses are both valid. If <code class="language-javascript">options</code> is
an integer, then it must be <code class="language-javascript">4</code> or <code class="language-javascript">6</code>.

</p>
<p>Alternatively, <code class="language-javascript">options</code> can be an object containing two properties,
<code class="language-javascript">family</code> and <code class="language-javascript">hints</code>. Both properties are optional. If <code class="language-javascript">family</code> is provided,
it must be the integer <code class="language-javascript">4</code> or <code class="language-javascript">6</code>. If <code class="language-javascript">family</code> is not provided then IP v4
and v6 addresses are accepted. The <code class="language-javascript">hints</code> field, if present, should be one
or more of the supported <code class="language-javascript">getaddrinfo</code> flags. If <code class="language-javascript">hints</code> is not provided,
then no flags are passed to <code class="language-javascript">getaddrinfo</code>. Multiple flags can be passed
through <code class="language-javascript">hints</code> by logically <code class="language-javascript">OR</code>ing their values. An example usage of
<code class="language-javascript">options</code> is shown below.

</p>
<pre><code class="language-javascript">{
  family: 4,
  hints: dns.ADDRCONFIG | dns.V4MAPPED
}</code></pre>
<p>See <a>supported <code class="language-javascript">getaddrinfo</code> flags</a> below for
more information on supported flags.

</p>
<p>The callback has arguments <code class="language-javascript">(err, address, family)</code>.  The <code class="language-javascript">address</code> argument
is a string representation of a IP v4 or v6 address. The <code class="language-javascript">family</code> argument
is either the integer 4 or 6 and denotes the family of <code class="language-javascript">address</code> (not
necessarily the value initially passed to <code class="language-javascript">lookup</code>).

</p>
<p>On error, <code class="language-javascript">err</code> is an <code class="language-javascript">Error</code> object, where <code class="language-javascript">err.code</code> is the error code.
Keep in mind that <code class="language-javascript">err.code</code> will be set to <code class="language-javascript">&#39;ENOENT&#39;</code> not only when
the hostname does not exist but also when the lookup fails in other ways
such as no available file descriptors.

</p>
<p><code class="language-javascript">dns.lookup</code> doesn&#39;t necessarily have anything to do with the DNS protocol.
It&#39;s only an operating system facility that can associate name with addresses,
and vice versa.

</p>
<p>Its implementation can have subtle but important consequences on the behavior
of any Node.js program. Please take some time to consult the <a>Implementation
considerations section</a> before using it.

</p>
<!--next-->
<h2>dns.lookupService(address, port, callback)</h2>
<p>Resolves the given address and port into a hostname and service using
<code class="language-javascript">getnameinfo</code>.

</p>
<p>The callback has arguments <code class="language-javascript">(err, hostname, service)</code>. The <code class="language-javascript">hostname</code> and
<code class="language-javascript">service</code> arguments are strings (e.g. <code class="language-javascript">&#39;localhost&#39;</code> and <code class="language-javascript">&#39;http&#39;</code> respectively).

</p>
<p>On error, <code class="language-javascript">err</code> is an <code class="language-javascript">Error</code> object, where <code class="language-javascript">err.code</code> is the error code.


</p>
<!--next-->
<h2>dns.resolve(hostname[, rrtype], callback)</h2>
<p>Resolves a hostname (e.g. <code class="language-javascript">&#39;google.com&#39;</code>) into an array of the record types
specified by rrtype.

</p>
<p>Valid rrtypes are:

</p>
<ul>
<li><code class="language-javascript">&#39;A&#39;</code> (IPV4 addresses, default)</li>
<li><code class="language-javascript">&#39;AAAA&#39;</code> (IPV6 addresses)</li>
<li><code class="language-javascript">&#39;MX&#39;</code> (mail exchange records)</li>
<li><code class="language-javascript">&#39;TXT&#39;</code> (text records)</li>
<li><code class="language-javascript">&#39;SRV&#39;</code> (SRV records)</li>
<li><code class="language-javascript">&#39;PTR&#39;</code> (used for reverse IP lookups)</li>
<li><code class="language-javascript">&#39;NS&#39;</code> (name server records)</li>
<li><code class="language-javascript">&#39;CNAME&#39;</code> (canonical name records)</li>
<li><code class="language-javascript">&#39;SOA&#39;</code> (start of authority record)</li>
</ul>
<p>The callback has arguments <code class="language-javascript">(err, addresses)</code>.  The type of each item
in <code class="language-javascript">addresses</code> is determined by the record type, and described in the
documentation for the corresponding lookup methods below.

</p>
<p>On error, <code class="language-javascript">err</code> is an <code class="language-javascript">Error</code> object, where <code class="language-javascript">err.code</code> is
one of the error codes listed below.


</p>
<!--next-->
<h2>dns.resolve4(hostname, callback)</h2>
<p>The same as <code class="language-javascript">dns.resolve()</code>, but only for IPv4 queries (<code class="language-javascript">A</code> records).
<code class="language-javascript">addresses</code> is an array of IPv4 addresses (e.g.
<code class="language-javascript">[&#39;74.125.79.104&#39;, &#39;74.125.79.105&#39;, &#39;74.125.79.106&#39;]</code>).

</p>
<!--next-->
<h2>dns.resolve6(hostname, callback)</h2>
<p>The same as <code class="language-javascript">dns.resolve4()</code> except for IPv6 queries (an <code class="language-javascript">AAAA</code> query).


</p>
<!--next-->
<h2>dns.resolveMx(hostname, callback)</h2>
<p>The same as <code class="language-javascript">dns.resolve()</code>, but only for mail exchange queries (<code class="language-javascript">MX</code> records).

</p>
<p><code class="language-javascript">addresses</code> is an array of MX records, each with a priority and an exchange
attribute (e.g. <code class="language-javascript">[{&#39;priority&#39;: 10, &#39;exchange&#39;: &#39;mx.example.com&#39;},...]</code>).

</p>
<!--next-->
<h2>dns.resolveTxt(hostname, callback)</h2>
<p>The same as <code class="language-javascript">dns.resolve()</code>, but only for text queries (<code class="language-javascript">TXT</code> records).
<code class="language-javascript">addresses</code> is an 2-d array of the text records available for <code class="language-javascript">hostname</code> (e.g.,
<code class="language-javascript">[ [&#39;v=spf1 ip4:0.0.0.0 &#39;, &#39;~all&#39; ] ]</code>). Each sub-array contains TXT chunks of
one record. Depending on the use case, the could be either joined together or
treated separately.

</p>
<!--next-->
<h2>dns.resolveSrv(hostname, callback)</h2>
<p>The same as <code class="language-javascript">dns.resolve()</code>, but only for service records (<code class="language-javascript">SRV</code> records).
<code class="language-javascript">addresses</code> is an array of the SRV records available for <code class="language-javascript">hostname</code>. Properties
of SRV records are priority, weight, port, and name (e.g.,
<code class="language-javascript">[{&#39;priority&#39;: 10, &#39;weight&#39;: 5, &#39;port&#39;: 21223, &#39;name&#39;: &#39;service.example.com&#39;}, ...]</code>).

</p>
<!--next-->
<h2>dns.resolveSoa(hostname, callback)</h2>
<p>The same as <code class="language-javascript">dns.resolve()</code>, but only for start of authority record queries
(<code class="language-javascript">SOA</code> record).

</p>
<p><code class="language-javascript">addresses</code> is an object with the following structure:

</p>
<pre><code class="language-javascript">{
  nsname: &#39;ns.example.com&#39;,
  hostmaster: &#39;root.example.com&#39;,
  serial: 2013101809,
  refresh: 10000,
  retry: 2400,
  expire: 604800,
  minttl: 3600
}</code></pre>
<!--next-->
<h2>dns.resolveNs(hostname, callback)</h2>
<p>The same as <code class="language-javascript">dns.resolve()</code>, but only for name server records (<code class="language-javascript">NS</code> records).
<code class="language-javascript">addresses</code> is an array of the name server records available for <code class="language-javascript">hostname</code>
(e.g., <code class="language-javascript">[&#39;ns1.example.com&#39;, &#39;ns2.example.com&#39;]</code>).

</p>
<!--next-->
<h2>dns.resolveCname(hostname, callback)</h2>
<p>The same as <code class="language-javascript">dns.resolve()</code>, but only for canonical name records (<code class="language-javascript">CNAME</code>
records). <code class="language-javascript">addresses</code> is an array of the canonical name records available for
<code class="language-javascript">hostname</code> (e.g., <code class="language-javascript">[&#39;bar.example.com&#39;]</code>).

</p>
<!--next-->
<h2>dns.reverse(ip, callback)</h2>
<p>Reverse resolves an ip address to an array of hostnames.

</p>
<p>The callback has arguments <code class="language-javascript">(err, hostnames)</code>.

</p>
<p>On error, <code class="language-javascript">err</code> is an <code class="language-javascript">Error</code> object, where <code class="language-javascript">err.code</code> is
one of the error codes listed below.

</p>
<!--next-->
<h2>dns.getServers()</h2>
<p>Returns an array of IP addresses as strings that are currently being used for
resolution

</p>
<!--next-->
<h2>dns.setServers(servers)</h2>
<p>Given an array of IP addresses as strings, set them as the servers to use for
resolving

</p>
<p>If you specify a port with the address it will be stripped, as the underlying
library doesn&#39;t support that.

</p>
<p>This will throw if you pass invalid input.

</p>
<!--next-->
<h2>Error codes</h2>
<p>Each DNS query can return one of the following error codes:

</p>
<ul>
<li><code class="language-javascript">dns.NODATA</code>: DNS server returned answer with no data.</li>
<li><code class="language-javascript">dns.FORMERR</code>: DNS server claims query was misformatted.</li>
<li><code class="language-javascript">dns.SERVFAIL</code>: DNS server returned general failure.</li>
<li><code class="language-javascript">dns.NOTFOUND</code>: Domain name not found.</li>
<li><code class="language-javascript">dns.NOTIMP</code>: DNS server does not implement requested operation.</li>
<li><code class="language-javascript">dns.REFUSED</code>: DNS server refused query.</li>
<li><code class="language-javascript">dns.BADQUERY</code>: Misformatted DNS query.</li>
<li><code class="language-javascript">dns.BADNAME</code>: Misformatted hostname.</li>
<li><code class="language-javascript">dns.BADFAMILY</code>: Unsupported address family.</li>
<li><code class="language-javascript">dns.BADRESP</code>: Misformatted DNS reply.</li>
<li><code class="language-javascript">dns.CONNREFUSED</code>: Could not contact DNS servers.</li>
<li><code class="language-javascript">dns.TIMEOUT</code>: Timeout while contacting DNS servers.</li>
<li><code class="language-javascript">dns.EOF</code>: End of file.</li>
<li><code class="language-javascript">dns.FILE</code>: Error reading file.</li>
<li><code class="language-javascript">dns.NOMEM</code>: Out of memory.</li>
<li><code class="language-javascript">dns.DESTRUCTION</code>: Channel is being destroyed.</li>
<li><code class="language-javascript">dns.BADSTR</code>: Misformatted string.</li>
<li><code class="language-javascript">dns.BADFLAGS</code>: Illegal flags specified.</li>
<li><code class="language-javascript">dns.NONAME</code>: Given hostname is not numeric.</li>
<li><code class="language-javascript">dns.BADHINTS</code>: Illegal hints flags specified.</li>
<li><code class="language-javascript">dns.NOTINITIALIZED</code>: c-ares library initialization not yet performed.</li>
<li><code class="language-javascript">dns.LOADIPHLPAPI</code>: Error loading iphlpapi.dll.</li>
<li><code class="language-javascript">dns.ADDRGETNETWORKPARAMS</code>: Could not find GetNetworkParams function.</li>
<li><code class="language-javascript">dns.CANCELLED</code>: DNS query cancelled.</li>
</ul>
<!--next-->
<h2>Supported getaddrinfo flags</h2>
<p>The following flags can be passed as hints to <code class="language-javascript">dns.lookup</code>.

</p>
<ul>
<li><code class="language-javascript">dns.ADDRCONFIG</code>: Returned address types are determined by the types
of addresses supported by the current system. For example, IPv4 addresses
are only returned if the current system has at least one IPv4 address
configured. Loopback addresses are not considered.</li>
<li><code class="language-javascript">dns.V4MAPPED</code>: If the IPv6 family was specified, but no IPv6 addresses
were found, then return IPv4 mapped IPv6 addresses.</li>
</ul>
<!--next-->
<h2>Implementation considerations</h2>
<p>Although <code class="language-javascript">dns.lookup</code> and <code class="language-javascript">dns.resolve*/dns.reverse</code> functions have the same
goal of associating a network name with a network address (or vice versa),
their behavior is quite different. These differences can have subtle but
significant consequences on the behavior of Node.js programs.

</p>
<!--next-->
<h2>dns.lookup</h2>
<p>Under the hood, <code class="language-javascript">dns.lookup</code> uses the same operating system facilities as most
other programs. For instance, <code class="language-javascript">dns.lookup</code> will almost always resolve a given
name the same way as the <code class="language-javascript">ping</code> command. On most POSIX-like operating systems,
the behavior of the <code class="language-javascript">dns.lookup</code> function can be tweaked by changing settings
in <code class="language-javascript">nsswitch.conf(5)</code> and/or <code class="language-javascript">resolv.conf(5)</code>, but be careful that changing
these files will change the behavior of all other programs running on the same
operating system.

</p>
<p>Though the call will be asynchronous from JavaScript&#39;s perspective, it is
implemented as a synchronous call to <code class="language-javascript">getaddrinfo(3)</code> that runs on libuv&#39;s
threadpool. Because libuv&#39;s threadpool has a fixed size, it means that if for
whatever reason the call to <code class="language-javascript">getaddrinfo(3)</code> takes a long time, other
operations that could run on libuv&#39;s threadpool (such as filesystem
operations) will experience degraded performance. In order to mitigate this
issue, one potential solution is to increase the size of libuv&#39;s threadpool by
setting the &#39;UV_THREADPOOL_SIZE&#39; environment variable to a value greater than
4 (its current default value). For more information on libuv&#39;s threadpool, see
<a>the official libuv
documentation</a>.

</p>
<!--next-->
<h2>dns.resolve, functions starting with dns.resolve and dns.reverse</h2>
<p>These functions are implemented quite differently than <code class="language-javascript">dns.lookup</code>. They do
not use <code class="language-javascript">getaddrinfo(3)</code> and they <em>always</em> perform a DNS query on the network.
This network communication is always done asynchronously, and does not use
libuv&#39;s threadpool.

</p>
<p>As a result, these functions cannot have the same negative impact on other
processing that happens on libuv&#39;s threadpool that <code class="language-javascript">dns.lookup</code> can have.

</p>
<p>They do not use the same set of configuration files than what <code class="language-javascript">dns.lookup</code>
uses. For instance, <em>they do not use the configuration from <code class="language-javascript">/etc/hosts</code></em>.

</p>
<!--next-->
<h2>HTTP</h2>
<pre class="stability">Stability: 3 - Stable</pre><p>To use the HTTP server and client one must <code class="language-javascript">require(&#39;http&#39;)</code>.

</p>
<p>The HTTP interfaces in Node are designed to support many features
of the protocol which have been traditionally difficult to use.
In particular, large, possibly chunk-encoded, messages. The interface is
careful to never buffer entire requests or responses--the
user is able to stream data.

</p>
<p>HTTP message headers are represented by an object like this:

</p>
<pre><code class="language-javascript">{ &#39;content-length&#39;: &#39;123&#39;,
  &#39;content-type&#39;: &#39;text/plain&#39;,
  &#39;connection&#39;: &#39;keep-alive&#39;,
  &#39;host&#39;: &#39;mysite.com&#39;,
  &#39;accept&#39;: &#39;*/*&#39; }</code></pre>
<p>Keys are lowercased. Values are not modified.

</p>
<p>In order to support the full spectrum of possible HTTP applications, Node&#39;s
HTTP API is very low-level. It deals with stream handling and message
parsing only. It parses a message into headers and body but it does not
parse the actual headers or the body.

</p>
<p>Defined headers that allow multiple values are concatenated with a <code class="language-javascript">,</code>
character, except for the <code class="language-javascript">set-cookie</code> and <code class="language-javascript">cookie</code> headers which are
represented as an array of values.  Headers such as <code class="language-javascript">content-length</code>
which can only have a single value are parsed accordingly, and only a
single value is represented on the parsed object.

</p>
<p>The raw headers as they were received are retained in the <code class="language-javascript">rawHeaders</code>
property, which is an array of <code class="language-javascript">[key, value, key2, value2, ...]</code>.  For
example, the previous message header object might have a <code class="language-javascript">rawHeaders</code>
list like the following:

</p>
<pre><code class="language-javascript">[ &#39;ConTent-Length&#39;, &#39;123456&#39;,
  &#39;content-LENGTH&#39;, &#39;123&#39;,
  &#39;content-type&#39;, &#39;text/plain&#39;,
  &#39;CONNECTION&#39;, &#39;keep-alive&#39;,
  &#39;Host&#39;, &#39;mysite.com&#39;,
  &#39;accepT&#39;, &#39;*/*&#39; ]</code></pre>
<!--next-->
<h2>http.METHODS</h2>
<div class="signature"><ul>
<li><span class="type">Array</span></li>
</div></ul>
<p>A list of the HTTP methods that are supported by the parser.

</p>
<!--next-->
<h2>http.STATUS_CODES</h2>
<div class="signature"><ul>
<li><span class="type">Object</span></li>
</div></ul>
<p>A collection of all the standard HTTP response status codes, and the
short description of each.  For example, <code class="language-javascript">http.STATUS_CODES[404] === &#39;Not
Found&#39;</code>.

</p>
<!--next-->
<h2>http.createServer([requestListener])</h2>
<p>Returns a new instance of <a>http.Server</a>.

</p>
<p>The <code class="language-javascript">requestListener</code> is a function which is automatically
added to the <code class="language-javascript">&#39;request&#39;</code> event.

</p>
<!--next-->
<h2>http.createClient([port][, host])</h2>
<p>This function is <strong>deprecated</strong>; please use <a>http.request()</a> instead.
Constructs a new HTTP client. <code class="language-javascript">port</code> and <code class="language-javascript">host</code> refer to the server to be
connected to.

</p>
<!--next-->
<h2>Class: http.Server</h2>
<p>This is an <a>EventEmitter</a> with the following events:

</p>
<!--next-->
<h2>Event: &#39;request&#39;</h2>
<p><code class="language-javascript">function (request, response) { }</code>

</p>
<p>Emitted each time there is a request. Note that there may be multiple requests
per connection (in the case of keep-alive connections).
 <code class="language-javascript">request</code> is an instance of <a>http.IncomingMessage</a> and <code class="language-javascript">response</code> is
an instance of <a>http.ServerResponse</a>.

</p>
<!--next-->
<h2>Event: &#39;connection&#39;</h2>
<p><code class="language-javascript">function (socket) { }</code>

</p>
<p>When a new TCP stream is established. <code class="language-javascript">socket</code> is an object of type
<code class="language-javascript">net.Socket</code>. Usually users will not want to access this event. In
particular, the socket will not emit <code class="language-javascript">readable</code> events because of how
the protocol parser attaches to the socket. The <code class="language-javascript">socket</code> can also be
accessed at <code class="language-javascript">request.connection</code>.

</p>
<!--next-->
<h2>Event: &#39;close&#39;</h2>
<p><code class="language-javascript">function () { }</code>

</p>
<p>Emitted when the server closes.

</p>
<!--next-->
<h2>Event: &#39;checkContinue&#39;</h2>
<p><code class="language-javascript">function (request, response) { }</code>

</p>
<p>Emitted each time a request with an http Expect: 100-continue is received.
If this event isn&#39;t listened for, the server will automatically respond
with a 100 Continue as appropriate.

</p>
<p>Handling this event involves calling <a>response.writeContinue()</a> if the client
should continue to send the request body, or generating an appropriate HTTP
response (e.g., 400 Bad Request) if the client should not continue to send the
request body.

</p>
<p>Note that when this event is emitted and handled, the <code class="language-javascript">request</code> event will
not be emitted.

</p>
<!--next-->
<h2>Event: &#39;connect&#39;</h2>
<p><code class="language-javascript">function (request, socket, head) { }</code>

</p>
<p>Emitted each time a client requests a http CONNECT method. If this event isn&#39;t
listened for, then clients requesting a CONNECT method will have their
connections closed.

</p>
<ul>
<li><code class="language-javascript">request</code> is the arguments for the http request, as it is in the request
event.</li>
<li><code class="language-javascript">socket</code> is the network socket between the server and client.</li>
<li><code class="language-javascript">head</code> is an instance of Buffer, the first packet of the tunneling stream,
this may be empty.</li>
</ul>
<p>After this event is emitted, the request&#39;s socket will not have a <code class="language-javascript">data</code>
event listener, meaning you will need to bind to it in order to handle data
sent to the server on that socket.

</p>
<!--next-->
<h2>Event: &#39;upgrade&#39;</h2>
<p><code class="language-javascript">function (request, socket, head) { }</code>

</p>
<p>Emitted each time a client requests a http upgrade. If this event isn&#39;t
listened for, then clients requesting an upgrade will have their connections
closed.

</p>
<ul>
<li><code class="language-javascript">request</code> is the arguments for the http request, as it is in the request
event.</li>
<li><code class="language-javascript">socket</code> is the network socket between the server and client.</li>
<li><code class="language-javascript">head</code> is an instance of Buffer, the first packet of the upgraded stream,
this may be empty.</li>
</ul>
<p>After this event is emitted, the request&#39;s socket will not have a <code class="language-javascript">data</code>
event listener, meaning you will need to bind to it in order to handle data
sent to the server on that socket.

</p>
<!--next-->
<h2>Event: &#39;clientError&#39;</h2>
<p><code class="language-javascript">function (exception, socket) { }</code>

</p>
<p>If a client connection emits an &#39;error&#39; event, it will be forwarded here.

</p>
<p><code class="language-javascript">socket</code> is the <code class="language-javascript">net.Socket</code> object that the error originated from.


</p>
<!--next-->
<h2>server.listen(port[, hostname][, backlog][, callback])</h2>
<p>Begin accepting connections on the specified port and hostname.  If the
hostname is omitted, the server will accept connections directed to any
IPv4 address (<code class="language-javascript">INADDR_ANY</code>).

</p>
<p>To listen to a unix socket, supply a filename instead of port and hostname.

</p>
<p>Backlog is the maximum length of the queue of pending connections.
The actual length will be determined by your OS through sysctl settings such as
<code class="language-javascript">tcp_max_syn_backlog</code> and <code class="language-javascript">somaxconn</code> on linux. The default value of this
parameter is 511 (not 512).

</p>
<p>This function is asynchronous. The last parameter <code class="language-javascript">callback</code> will be added as
a listener for the <a>&#39;listening&#39;</a> event.  See also <a>net.Server.listen(port)</a>.


</p>
<!--next-->
<h2>server.listen(path[, callback])</h2>
<p>Start a UNIX socket server listening for connections on the given <code class="language-javascript">path</code>.

</p>
<p>This function is asynchronous. The last parameter <code class="language-javascript">callback</code> will be added as
a listener for the <a>&#39;listening&#39;</a> event.  See also <a>net.Server.listen(path)</a>.


</p>
<!--next-->
<h2>server.listen(handle[, callback])</h2>
<div class="signature"><ul>
<li><code class="language-javascript">handle</code> <span class="type">Object</span></li>
<li><code class="language-javascript">callback</code> <span class="type">Function</span></li>
</div></ul>
<p>The <code class="language-javascript">handle</code> object can be set to either a server or socket (anything
with an underlying <code class="language-javascript">_handle</code> member), or a <code class="language-javascript">{fd: &lt;n&gt;}</code> object.

</p>
<p>This will cause the server to accept connections on the specified
handle, but it is presumed that the file descriptor or handle has
already been bound to a port or domain socket.

</p>
<p>Listening on a file descriptor is not supported on Windows.

</p>
<p>This function is asynchronous. The last parameter <code class="language-javascript">callback</code> will be added as
a listener for the <a>&#39;listening&#39;</a> event.
See also <a>net.Server.listen()</a>.

</p>
<!--next-->
<h2>server.close([callback])</h2>
<p>Stops the server from accepting new connections.  See <a>net.Server.close()</a>.


</p>
<!--next-->
<h2>server.maxHeadersCount</h2>
<p>Limits maximum incoming headers count, equal to 1000 by default. If set to 0 -
no limit will be applied.

</p>
<!--next-->
<h2>server.setTimeout(msecs, callback)</h2>
<div class="signature"><ul>
<li><code class="language-javascript">msecs</code> <span class="type">Number</span></li>
<li><code class="language-javascript">callback</code> <span class="type">Function</span></li>
</div></ul>
<p>Sets the timeout value for sockets, and emits a <code class="language-javascript">&#39;timeout&#39;</code> event on
the Server object, passing the socket as an argument, if a timeout
occurs.

</p>
<p>If there is a <code class="language-javascript">&#39;timeout&#39;</code> event listener on the Server object, then it
will be called with the timed-out socket as an argument.

</p>
<p>By default, the Server&#39;s timeout value is 2 minutes, and sockets are
destroyed automatically if they time out.  However, if you assign a
callback to the Server&#39;s <code class="language-javascript">&#39;timeout&#39;</code> event, then you are responsible
for handling socket timeouts.

</p>
<!--next-->
<h2>server.timeout</h2>
<div class="signature"><ul>
<li><span class="type">Number</span> Default = 120000 (2 minutes)</li>
</div></ul>
<p>The number of milliseconds of inactivity before a socket is presumed
to have timed out.

</p>
<p>Note that the socket timeout logic is set up on connection, so
changing this value only affects <em>new</em> connections to the server, not
any existing connections.

</p>
<p>Set to 0 to disable any kind of automatic timeout behavior on incoming
connections.

</p>
<!--next-->
<h2>Class: http.ServerResponse</h2>
<p>This object is created internally by a HTTP server--not by the user. It is
passed as the second parameter to the <code class="language-javascript">&#39;request&#39;</code> event.

</p>
<p>The response implements the <a>Writable Stream</a> interface. This is an
<a>EventEmitter</a> with the following events:

</p>
<!--next-->
<h2>Event: &#39;close&#39;</h2>
<p><code class="language-javascript">function () { }</code>

</p>
<p>Indicates that the underlying connection was terminated before
<a>response.end()</a> was called or able to flush.

</p>
<!--next-->
<h2>Event: &#39;finish&#39;</h2>
<p><code class="language-javascript">function () { }</code>

</p>
<p>Emitted when the response has been sent. More specifically, this event is
emitted when the last segment of the response headers and body have been
handed off to the operating system for transmission over the network. It
does not imply that the client has received anything yet.

</p>
<p>After this event, no more events will be emitted on the response object.

</p>
<!--next-->
<h2>response.writeContinue()</h2>
<p>Sends a HTTP/1.1 100 Continue message to the client, indicating that
the request body should be sent. See the <a>&#39;checkContinue&#39;</a> event on <code class="language-javascript">Server</code>.

</p>
<!--next-->
<h2>response.writeHead(statusCode[, statusMessage][, headers])</h2>
<p>Sends a response header to the request. The status code is a 3-digit HTTP
status code, like <code class="language-javascript">404</code>. The last argument, <code class="language-javascript">headers</code>, are the response headers.
Optionally one can give a human-readable <code class="language-javascript">statusMessage</code> as the second
argument.

</p>
<p>Example:

</p>
<pre><code class="language-javascript">var body = &#39;hello world&#39;;
response.writeHead(200, {
  &#39;Content-Length&#39;: body.length,
  &#39;Content-Type&#39;: &#39;text/plain&#39; });</code></pre>
<p>This method must only be called once on a message and it must
be called before <a>response.end()</a> is called.

</p>
<p>If you call <a>response.write()</a> or <a>response.end()</a> before calling this, the
implicit/mutable headers will be calculated and call this function for you.

</p>
<p>Note that Content-Length is given in bytes not characters. The above example
works because the string <code class="language-javascript">&#39;hello world&#39;</code> contains only single byte characters.
If the body contains higher coded characters then <code class="language-javascript">Buffer.byteLength()</code>
should be used to determine the number of bytes in a given encoding.
And Node does not check whether Content-Length and the length of the body
which has been transmitted are equal or not.

</p>
<!--next-->
<h2>response.setTimeout(msecs, callback)</h2>
<div class="signature"><ul>
<li><code class="language-javascript">msecs</code> <span class="type">Number</span></li>
<li><code class="language-javascript">callback</code> <span class="type">Function</span></li>
</div></ul>
<p>Sets the Socket&#39;s timeout value to <code class="language-javascript">msecs</code>.  If a callback is
provided, then it is added as a listener on the <code class="language-javascript">&#39;timeout&#39;</code> event on
the response object.

</p>
<p>If no <code class="language-javascript">&#39;timeout&#39;</code> listener is added to the request, the response, or
the server, then sockets are destroyed when they time out.  If you
assign a handler on the request, the response, or the server&#39;s
<code class="language-javascript">&#39;timeout&#39;</code> events, then it is your responsibility to handle timed out
sockets.

</p>
<!--next-->
<h2>response.statusCode</h2>
<p>When using implicit headers (not calling <a>response.writeHead()</a> explicitly),
this property controls the status code that will be sent to the client when
the headers get flushed.

</p>
<p>Example:

</p>
<pre><code class="language-javascript">response.statusCode = 404;</code></pre>
<p>After response header was sent to the client, this property indicates the
status code which was sent out.

</p>
<!--next-->
<h2>response.statusMessage</h2>
<p>When using implicit headers (not calling <code class="language-javascript">response.writeHead()</code> explicitly), this property
controls the status message that will be sent to the client when the headers get
flushed. If this is left as <code class="language-javascript">undefined</code> then the standard message for the status
code will be used.

</p>
<p>Example:

</p>
<pre><code class="language-javascript">response.statusMessage = &#39;Not found&#39;;</code></pre>
<p>After response header was sent to the client, this property indicates the
status message which was sent out.

</p>
<!--next-->
<h2>response.setHeader(name, value)</h2>
<p>Sets a single header value for implicit headers.  If this header already exists
in the to-be-sent headers, its value will be replaced.  Use an array of strings
here if you need to send multiple headers with the same name.

</p>
<p>Example:

</p>
<pre><code class="language-javascript">response.setHeader(&quot;Content-Type&quot;, &quot;text/html&quot;);</code></pre>
<p>or

</p>
<pre><code class="language-javascript">response.setHeader(&quot;Set-Cookie&quot;, [&quot;type=ninja&quot;, &quot;language=javascript&quot;]);</code></pre>
<!--next-->
<h2>response.headersSent</h2>
<p>Boolean (read-only). True if headers were sent, false otherwise.

</p>
<!--next-->
<h2>response.sendDate</h2>
<p>When true, the Date header will be automatically generated and sent in
the response if it is not already present in the headers. Defaults to true.

</p>
<p>This should only be disabled for testing; HTTP requires the Date header
in responses.

</p>
<!--next-->
<h2>response.getHeader(name)</h2>
<p>Reads out a header that&#39;s already been queued but not sent to the client.  Note
that the name is case insensitive.  This can only be called before headers get
implicitly flushed.

</p>
<p>Example:

</p>
<pre><code class="language-javascript">var contentType = response.getHeader(&#39;content-type&#39;);</code></pre>
<!--next-->
<h2>response.removeHeader(name)</h2>
<p>Removes a header that&#39;s queued for implicit sending.

</p>
<p>Example:

</p>
<pre><code class="language-javascript">response.removeHeader(&quot;Content-Encoding&quot;);</code></pre>
<!--next-->
<h2>response.write(chunk[, encoding][, callback])</h2>
<p>If this method is called and <a>response.writeHead()</a> has not been called,
it will switch to implicit header mode and flush the implicit headers.

</p>
<p>This sends a chunk of the response body. This method may
be called multiple times to provide successive parts of the body.

</p>
<p><code class="language-javascript">chunk</code> can be a string or a buffer. If <code class="language-javascript">chunk</code> is a string,
the second parameter specifies how to encode it into a byte stream.
By default the <code class="language-javascript">encoding</code> is <code class="language-javascript">&#39;utf8&#39;</code>. The last parameter <code class="language-javascript">callback</code>
will be called when this chunk of data is flushed.

</p>
<p><strong>Note</strong>: This is the raw HTTP body and has nothing to do with
higher-level multi-part body encodings that may be used.

</p>
<p>The first time <code class="language-javascript">response.write()</code> is called, it will send the buffered
header information and the first body to the client. The second time
<code class="language-javascript">response.write()</code> is called, Node assumes you&#39;re going to be streaming
data, and sends that separately. That is, the response is buffered up to the
first chunk of body.

</p>
<p>Returns <code class="language-javascript">true</code> if the entire data was flushed successfully to the kernel
buffer. Returns <code class="language-javascript">false</code> if all or part of the data was queued in user memory.
<code class="language-javascript">&#39;drain&#39;</code> will be emitted when the buffer is free again.

</p>
<!--next-->
<h2>response.addTrailers(headers)</h2>
<p>This method adds HTTP trailing headers (a header but at the end of the
message) to the response.

</p>
<p>Trailers will <strong>only</strong> be emitted if chunked encoding is used for the
response; if it is not (e.g., if the request was HTTP/1.0), they will
be silently discarded.

</p>
<p>Note that HTTP requires the <code class="language-javascript">Trailer</code> header to be sent if you intend to
emit trailers, with a list of the header fields in its value. E.g.,

</p>
<pre><code class="language-javascript">response.writeHead(200, { &#39;Content-Type&#39;: &#39;text/plain&#39;,
                          &#39;Trailer&#39;: &#39;Content-MD5&#39; });
response.write(fileData);
response.addTrailers({&#39;Content-MD5&#39;: &quot;7895bf4b8828b55ceaf47747b4bca667&quot;});
response.end();</code></pre>
<!--next-->
<h2>response.end([data][, encoding][, callback])</h2>
<p>This method signals to the server that all of the response headers and body
have been sent; that server should consider this message complete.
The method, <code class="language-javascript">response.end()</code>, MUST be called on each
response.

</p>
<p>If <code class="language-javascript">data</code> is specified, it is equivalent to calling
<code class="language-javascript">response.write(data, encoding)</code> followed by <code class="language-javascript">response.end(callback)</code>.

</p>
<p>If <code class="language-javascript">callback</code> is specified, it will be called when the response stream
is finished.

</p>
<!--next-->
<h2>http.request(options[, callback])</h2>
<p>Node maintains several connections per server to make HTTP requests.
This function allows one to transparently issue requests.

</p>
<p><code class="language-javascript">options</code> can be an object or a string. If <code class="language-javascript">options</code> is a string, it is
automatically parsed with <a>url.parse()</a>.

</p>
<p>Options:

</p>
<ul>
<li><code class="language-javascript">host</code>: A domain name or IP address of the server to issue the request to.
Defaults to <code class="language-javascript">&#39;localhost&#39;</code>.</li>
<li><code class="language-javascript">hostname</code>: To support <code class="language-javascript">url.parse()</code> <code class="language-javascript">hostname</code> is preferred over <code class="language-javascript">host</code></li>
<li><code class="language-javascript">port</code>: Port of remote server. Defaults to 80.</li>
<li><code class="language-javascript">localAddress</code>: Local interface to bind for network connections.</li>
<li><code class="language-javascript">socketPath</code>: Unix Domain Socket (use one of host:port or socketPath)</li>
<li><code class="language-javascript">method</code>: A string specifying the HTTP request method. Defaults to <code class="language-javascript">&#39;GET&#39;</code>.</li>
<li><code class="language-javascript">path</code>: Request path. Defaults to <code class="language-javascript">&#39;/&#39;</code>. Should include query string if any.
E.G. <code class="language-javascript">&#39;/index.html?page=12&#39;</code>. An exception is thrown when the request path
contains illegal characters. Currently, only spaces are rejected but that
may change in the future.</li>
<li><code class="language-javascript">headers</code>: An object containing request headers.</li>
<li><code class="language-javascript">auth</code>: Basic authentication i.e. <code class="language-javascript">&#39;user:password&#39;</code> to compute an
Authorization header.</li>
<li><code class="language-javascript">agent</code>: Controls <a>Agent</a> behavior. When an Agent is used request will
default to <code class="language-javascript">Connection: keep-alive</code>. Possible values:<ul>
<li><code class="language-javascript">undefined</code> (default): use <a>global Agent</a> for this host and port.</li>
<li><code class="language-javascript">Agent</code> object: explicitly use the passed in <code class="language-javascript">Agent</code>.</li>
<li><code class="language-javascript">false</code>: opts out of connection pooling with an Agent, defaults request to
<code class="language-javascript">Connection: close</code>.</li>
</ul>
</li>
<li><code class="language-javascript">keepAlive</code>: {Boolean} Keep sockets around in a pool to be used
by other requests in the future. Default = <code class="language-javascript">false</code></li>
<li><code class="language-javascript">keepAliveMsecs</code>: {Integer} When using HTTP KeepAlive, how often to
send TCP KeepAlive packets over sockets being kept alive.  Default =
<code class="language-javascript">1000</code>.  Only relevant if <code class="language-javascript">keepAlive</code> is set to <code class="language-javascript">true</code>.</li>
</ul>
<p>The optional <code class="language-javascript">callback</code> parameter will be added as a one time listener for
the <a>&#39;response&#39;</a> event.

</p>
<p><code class="language-javascript">http.request()</code> returns an instance of the <a>http.ClientRequest</a>
class. The <code class="language-javascript">ClientRequest</code> instance is a writable stream. If one needs to
upload a file with a POST request, then write to the <code class="language-javascript">ClientRequest</code> object.

</p>
<p>Example:

</p>
<pre><code class="language-javascript">var postData = querystring.stringify({
  &#39;msg&#39; : &#39;Hello World!&#39;
});

var options = {
  hostname: &#39;www.google.com&#39;,
  port: 80,
  path: &#39;/upload&#39;,
  method: &#39;POST&#39;,
  headers: {
    &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;,
    &#39;Content-Length&#39;: postData.length
  }
};

var req = http.request(options, function(res) {
  console.log(&#39;STATUS: &#39; + res.statusCode);
  console.log(&#39;HEADERS: &#39; + JSON.stringify(res.headers));
  res.setEncoding(&#39;utf8&#39;);
  res.on(&#39;data&#39;, function (chunk) {
    console.log(&#39;BODY: &#39; + chunk);
  });
});

req.on(&#39;error&#39;, function(e) {
  console.log(&#39;problem with request: &#39; + e.message);
});

// write data to request body
req.write(postData);
req.end();</code></pre>
<p>Note that in the example <code class="language-javascript">req.end()</code> was called. With <code class="language-javascript">http.request()</code> one
must always call <code class="language-javascript">req.end()</code> to signify that you&#39;re done with the request -
even if there is no data being written to the request body.

</p>
<p>If any error is encountered during the request (be that with DNS resolution,
TCP level errors, or actual HTTP parse errors) an <code class="language-javascript">&#39;error&#39;</code> event is emitted
on the returned request object.

</p>
<p>There are a few special headers that should be noted.

</p>
<ul>
<li><p>Sending a &#39;Connection: keep-alive&#39; will notify Node that the connection to
the server should be persisted until the next request.</p>
</li>
<li><p>Sending a &#39;Content-length&#39; header will disable the default chunked encoding.</p>
</li>
<li><p>Sending an &#39;Expect&#39; header will immediately send the request headers.
Usually, when sending &#39;Expect: 100-continue&#39;, you should both set a timeout
and listen for the <code class="language-javascript">continue</code> event. See RFC2616 Section 8.2.3 for more
information.</p>
</li>
<li><p>Sending an Authorization header will override using the <code class="language-javascript">auth</code> option
to compute basic authentication.</p>
</li>
</ul>
<!--next-->
<h2>http.get(options[, callback])</h2>
<p>Since most requests are GET requests without bodies, Node provides this
convenience method. The only difference between this method and <code class="language-javascript">http.request()</code>
is that it sets the method to GET and calls <code class="language-javascript">req.end()</code> automatically.

</p>
<p>Example:

</p>
<pre><code class="language-javascript">http.get(&quot;http://www.google.com/index.html&quot;, function(res) {
  console.log(&quot;Got response: &quot; + res.statusCode);
}).on(&#39;error&#39;, function(e) {
  console.log(&quot;Got error: &quot; + e.message);
});</code></pre>
<!--next-->
<h2>Class: http.Agent</h2>
<p>The HTTP Agent is used for pooling sockets used in HTTP client
requests.

</p>
<p>The HTTP Agent also defaults client requests to using
Connection:keep-alive. If no pending HTTP requests are waiting on a
socket to become free the socket is closed. This means that Node&#39;s
pool has the benefit of keep-alive when under load but still does not
require developers to manually close the HTTP clients using
KeepAlive.

</p>
<p>If you opt into using HTTP KeepAlive, you can create an Agent object
with that flag set to <code class="language-javascript">true</code>.  (See the <a>constructor
options</a> below.)  Then, the Agent will keep
unused sockets in a pool for later use.  They will be explicitly
marked so as to not keep the Node process running.  However, it is
still a good idea to explicitly <a><code class="language-javascript">destroy()</code></a>
KeepAlive agents when they are no longer in use, so that the Sockets
will be shut down.

</p>
<p>Sockets are removed from the agent&#39;s pool when the socket emits either
a &quot;close&quot; event or a special &quot;agentRemove&quot; event. This means that if
you intend to keep one HTTP request open for a long time and don&#39;t
want it to stay in the pool you can do something along the lines of:

</p>
<pre><code class="language-javascript">http.get(options, function(res) {
  // Do stuff
}).on(&quot;socket&quot;, function (socket) {
  socket.emit(&quot;agentRemove&quot;);
});</code></pre>
<p>Alternatively, you could just opt out of pooling entirely using
<code class="language-javascript">agent:false</code>:

</p>
<pre><code class="language-javascript">http.get({
  hostname: &#39;localhost&#39;,
  port: 80,
  path: &#39;/&#39;,
  agent: false  // create a new agent just for this one request
}, function (res) {
  // Do stuff with response
})</code></pre>
<!--next-->
<h2>new Agent([options])</h2>
<div class="signature"><ul>
<li><code class="language-javascript">options</code> <span class="type">Object</span> Set of configurable options to set on the agent.
Can have the following fields:<ul>
<li><code class="language-javascript">keepAlive</code> <span class="type">Boolean</span> Keep sockets around in a pool to be used by
other requests in the future. Default = <code class="language-javascript">false</code></li>
<li><code class="language-javascript">keepAliveMsecs</code> <span class="type">Integer</span> When using HTTP KeepAlive, how often
to send TCP KeepAlive packets over sockets being kept alive.
Default = <code class="language-javascript">1000</code>.  Only relevant if <code class="language-javascript">keepAlive</code> is set to <code class="language-javascript">true</code>.</li>
<li><code class="language-javascript">maxSockets</code> <span class="type">Number</span> Maximum number of sockets to allow per
host.  Default = <code class="language-javascript">Infinity</code>.</li>
<li><code class="language-javascript">maxFreeSockets</code> <span class="type">Number</span> Maximum number of sockets to leave open
in a free state.  Only relevant if <code class="language-javascript">keepAlive</code> is set to <code class="language-javascript">true</code>.
Default = <code class="language-javascript">256</code>.</li>
</ul>
</li>
</div></ul>
<p>The default <code class="language-javascript">http.globalAgent</code> that is used by <code class="language-javascript">http.request</code> has all
of these values set to their respective defaults.

</p>
<p>To configure any of them, you must create your own <code class="language-javascript">Agent</code> object.

</p>
<pre><code class="javascript">var http = require(&#39;http&#39;);
var keepAliveAgent = new http.Agent({ keepAlive: true });
options.agent = keepAliveAgent;
http.request(options, onResponseCallback);</code></pre>
<!--next-->
<h2>agent.maxSockets</h2>
<p>By default set to Infinity. Determines how many concurrent sockets the agent
can have open per origin. Origin is either a &#39;host:port&#39; or
&#39;host:port:localAddress&#39; combination.

</p>
<!--next-->
<h2>agent.maxFreeSockets</h2>
<p>By default set to 256.  For Agents supporting HTTP KeepAlive, this
sets the maximum number of sockets that will be left open in the free
state.

</p>
<!--next-->
<h2>agent.sockets</h2>
<p>An object which contains arrays of sockets currently in use by the
Agent.  Do not modify.

</p>
<!--next-->
<h2>agent.freeSockets</h2>
<p>An object which contains arrays of sockets currently awaiting use by
the Agent when HTTP KeepAlive is used.  Do not modify.

</p>
<!--next-->
<h2>agent.requests</h2>
<p>An object which contains queues of requests that have not yet been assigned to
sockets. Do not modify.

</p>
<!--next-->
<h2>agent.destroy()</h2>
<p>Destroy any sockets that are currently in use by the agent.

</p>
<p>It is usually not necessary to do this.  However, if you are using an
agent with KeepAlive enabled, then it is best to explicitly shut down
the agent when you know that it will no longer be used.  Otherwise,
sockets may hang open for quite a long time before the server
terminates them.

</p>
<!--next-->
<h2>agent.getName(options)</h2>
<p>Get a unique name for a set of request options, to determine whether a
connection can be reused.  In the http agent, this returns
<code class="language-javascript">host:port:localAddress</code>.  In the https agent, the name includes the
CA, cert, ciphers, and other HTTPS/TLS-specific options that determine
socket reusability.


</p>
<!--next-->
<h2>http.globalAgent</h2>
<p>Global instance of Agent which is used as the default for all http client
requests.


</p>
<!--next-->
<h2>Class: http.ClientRequest</h2>
<p>This object is created internally and returned from <code class="language-javascript">http.request()</code>.  It
represents an <em>in-progress</em> request whose header has already been queued.  The
header is still mutable using the <code class="language-javascript">setHeader(name, value)</code>, <code class="language-javascript">getHeader(name)</code>,
<code class="language-javascript">removeHeader(name)</code> API.  The actual header will be sent along with the first
data chunk or when closing the connection.

</p>
<p>To get the response, add a listener for <code class="language-javascript">&#39;response&#39;</code> to the request object.
<code class="language-javascript">&#39;response&#39;</code> will be emitted from the request object when the response
headers have been received.  The <code class="language-javascript">&#39;response&#39;</code> event is executed with one
argument which is an instance of <a>http.IncomingMessage</a>.

</p>
<p>During the <code class="language-javascript">&#39;response&#39;</code> event, one can add listeners to the
response object; particularly to listen for the <code class="language-javascript">&#39;data&#39;</code> event.

</p>
<p>If no <code class="language-javascript">&#39;response&#39;</code> handler is added, then the response will be
entirely discarded.  However, if you add a <code class="language-javascript">&#39;response&#39;</code> event handler,
then you <strong>must</strong> consume the data from the response object, either by
calling <code class="language-javascript">response.read()</code> whenever there is a <code class="language-javascript">&#39;readable&#39;</code> event, or
by adding a <code class="language-javascript">&#39;data&#39;</code> handler, or by calling the <code class="language-javascript">.resume()</code> method.
Until the data is consumed, the <code class="language-javascript">&#39;end&#39;</code> event will not fire.  Also, until
the data is read it will consume memory that can eventually lead to a
&#39;process out of memory&#39; error.

</p>
<p>Note: Node does not check whether Content-Length and the length of the body
which has been transmitted are equal or not.

</p>
<p>The request implements the <a>Writable Stream</a> interface. This is an
<a>EventEmitter</a> with the following events:

</p>
<!--next-->
<h2>Event: &#39;response&#39;</h2>
<p><code class="language-javascript">function (response) { }</code>

</p>
<p>Emitted when a response is received to this request. This event is emitted only
once. The <code class="language-javascript">response</code> argument will be an instance of <a>http.IncomingMessage</a>.

</p>
<p>Options:

</p>
<ul>
<li><code class="language-javascript">host</code>: A domain name or IP address of the server to issue the request to.</li>
<li><code class="language-javascript">port</code>: Port of remote server.</li>
<li><code class="language-javascript">socketPath</code>: Unix Domain Socket (use one of host:port or socketPath)</li>
</ul>
<!--next-->
<h2>Event: &#39;socket&#39;</h2>
<p><code class="language-javascript">function (socket) { }</code>

</p>
<p>Emitted after a socket is assigned to this request.

</p>
<!--next-->
<h2>Event: &#39;connect&#39;</h2>
<p><code class="language-javascript">function (response, socket, head) { }</code>

</p>
<p>Emitted each time a server responds to a request with a CONNECT method. If this
event isn&#39;t being listened for, clients receiving a CONNECT method will have
their connections closed.

</p>
<p>A client server pair that show you how to listen for the <code class="language-javascript">connect</code> event.

</p>
<pre><code class="language-javascript">var http = require(&#39;http&#39;);
var net = require(&#39;net&#39;);
var url = require(&#39;url&#39;);

// Create an HTTP tunneling proxy
var proxy = http.createServer(function (req, res) {
  res.writeHead(200, {&#39;Content-Type&#39;: &#39;text/plain&#39;});
  res.end(&#39;okay&#39;);
});
proxy.on(&#39;connect&#39;, function(req, cltSocket, head) {
  // connect to an origin server
  var srvUrl = url.parse(&#39;http://&#39; + req.url);
  var srvSocket = net.connect(srvUrl.port, srvUrl.hostname, function() {
    cltSocket.write(&#39;HTTP/1.1 200 Connection Established\r\n&#39; +
                    &#39;Proxy-agent: Node-Proxy\r\n&#39; +
                    &#39;\r\n&#39;);
    srvSocket.write(head);
    srvSocket.pipe(cltSocket);
    cltSocket.pipe(srvSocket);
  });
});

// now that proxy is running
proxy.listen(1337, &#39;127.0.0.1&#39;, function() {

  // make a request to a tunneling proxy
  var options = {
    port: 1337,
    hostname: &#39;127.0.0.1&#39;,
    method: &#39;CONNECT&#39;,
    path: &#39;www.google.com:80&#39;
  };

  var req = http.request(options);
  req.end();

  req.on(&#39;connect&#39;, function(res, socket, head) {
    console.log(&#39;got connected!&#39;);

    // make a request over an HTTP tunnel
    socket.write(&#39;GET / HTTP/1.1\r\n&#39; +
                 &#39;Host: www.google.com:80\r\n&#39; +
                 &#39;Connection: close\r\n&#39; +
                 &#39;\r\n&#39;);
    socket.on(&#39;data&#39;, function(chunk) {
      console.log(chunk.toString());
    });
    socket.on(&#39;end&#39;, function() {
      proxy.close();
    });
  });
});</code></pre>
<!--next-->
<h2>Event: &#39;upgrade&#39;</h2>
<p><code class="language-javascript">function (response, socket, head) { }</code>

</p>
<p>Emitted each time a server responds to a request with an upgrade. If this
event isn&#39;t being listened for, clients receiving an upgrade header will have
their connections closed.

</p>
<p>A client server pair that show you how to listen for the <code class="language-javascript">upgrade</code> event.

</p>
<pre><code class="language-javascript">var http = require(&#39;http&#39;);

// Create an HTTP server
var srv = http.createServer(function (req, res) {
  res.writeHead(200, {&#39;Content-Type&#39;: &#39;text/plain&#39;});
  res.end(&#39;okay&#39;);
});
srv.on(&#39;upgrade&#39;, function(req, socket, head) {
  socket.write(&#39;HTTP/1.1 101 Web Socket Protocol Handshake\r\n&#39; +
               &#39;Upgrade: WebSocket\r\n&#39; +
               &#39;Connection: Upgrade\r\n&#39; +
               &#39;\r\n&#39;);

  socket.pipe(socket); // echo back
});

// now that server is running
srv.listen(1337, &#39;127.0.0.1&#39;, function() {

  // make a request
  var options = {
    port: 1337,
    hostname: &#39;127.0.0.1&#39;,
    headers: {
      &#39;Connection&#39;: &#39;Upgrade&#39;,
      &#39;Upgrade&#39;: &#39;websocket&#39;
    }
  };

  var req = http.request(options);
  req.end();

  req.on(&#39;upgrade&#39;, function(res, socket, upgradeHead) {
    console.log(&#39;got upgraded!&#39;);
    socket.end();
    process.exit(0);
  });
});</code></pre>
<!--next-->
<h2>Event: &#39;continue&#39;</h2>
<p><code class="language-javascript">function () { }</code>

</p>
<p>Emitted when the server sends a &#39;100 Continue&#39; HTTP response, usually because
the request contained &#39;Expect: 100-continue&#39;. This is an instruction that
the client should send the request body.

</p>
<!--next-->
<h2>request.flushHeaders()</h2>
<p>Flush the request headers.

</p>
<p>For efficiency reasons, node.js normally buffers the request headers until you
call <code class="language-javascript">request.end()</code> or write the first chunk of request data.  It then tries
hard to pack the request headers and data into a single TCP packet.

</p>
<p>That&#39;s usually what you want (it saves a TCP round-trip) but not when the first
data isn&#39;t sent until possibly much later.  <code class="language-javascript">request.flush()</code> lets you bypass
the optimization and kickstart the request.

</p>
<!--next-->
<h2>request.write(chunk[, encoding][, callback])</h2>
<p>Sends a chunk of the body.  By calling this method
many times, the user can stream a request body to a
server--in that case it is suggested to use the
<code class="language-javascript">[&#39;Transfer-Encoding&#39;, &#39;chunked&#39;]</code> header line when
creating the request.

</p>
<p>The <code class="language-javascript">chunk</code> argument should be a <a>Buffer</a> or a string.

</p>
<p>The <code class="language-javascript">encoding</code> argument is optional and only applies when <code class="language-javascript">chunk</code> is a string.
Defaults to <code class="language-javascript">&#39;utf8&#39;</code>.

</p>
<p>The <code class="language-javascript">callback</code> argument is optional and will be called when this chunk of data
is flushed.

</p>
<!--next-->
<h2>request.end([data][, encoding][, callback])</h2>
<p>Finishes sending the request. If any parts of the body are
unsent, it will flush them to the stream. If the request is
chunked, this will send the terminating <code class="language-javascript">&#39;0\r\n\r\n&#39;</code>.

</p>
<p>If <code class="language-javascript">data</code> is specified, it is equivalent to calling
<code class="language-javascript">request.write(data, encoding)</code> followed by <code class="language-javascript">request.end(callback)</code>.

</p>
<p>If <code class="language-javascript">callback</code> is specified, it will be called when the request stream
is finished.

</p>
<!--next-->
<h2>request.abort()</h2>
<p>Aborts a request.  (New since v0.3.8.)

</p>
<!--next-->
<h2>request.setTimeout(timeout[, callback])</h2>
<p>Once a socket is assigned to this request and is connected
<a>socket.setTimeout()</a> will be called.

</p>
<!--next-->
<h2>request.setNoDelay([noDelay])</h2>
<p>Once a socket is assigned to this request and is connected
<a>socket.setNoDelay()</a> will be called.

</p>
<!--next-->
<h2>request.setSocketKeepAlive([enable][, initialDelay])</h2>
<p>Once a socket is assigned to this request and is connected
<a>socket.setKeepAlive()</a> will be called.


</p>
<!--next-->
<h2>http.IncomingMessage</h2>
<p>An <code class="language-javascript">IncomingMessage</code> object is created by <a>http.Server</a> or
<a>http.ClientRequest</a> and passed as the first argument to the <code class="language-javascript">&#39;request&#39;</code>
and <code class="language-javascript">&#39;response&#39;</code> event respectively. It may be used to access response status,
headers and data.

</p>
<p>It implements the <a>Readable Stream</a> interface, as well as the
following additional events, methods, and properties.

</p>
<!--next-->
<h2>Event: &#39;close&#39;</h2>
<p><code class="language-javascript">function () { }</code>

</p>
<p>Indicates that the underlying connection was closed.
Just like <code class="language-javascript">&#39;end&#39;</code>, this event occurs only once per response.

</p>
<!--next-->
<h2>message.httpVersion</h2>
<p>In case of server request, the HTTP version sent by the client. In the case of
client response, the HTTP version of the connected-to server.
Probably either <code class="language-javascript">&#39;1.1&#39;</code> or <code class="language-javascript">&#39;1.0&#39;</code>.

</p>
<p>Also <code class="language-javascript">response.httpVersionMajor</code> is the first integer and
<code class="language-javascript">response.httpVersionMinor</code> is the second.

</p>
<!--next-->
<h2>message.headers</h2>
<p>The request/response headers object.

</p>
<p>Read only map of header names and values. Header names are lower-cased.
Example:

</p>
<pre><code class="language-javascript">// Prints something like:
//
// { &#39;user-agent&#39;: &#39;curl/7.22.0&#39;,
//   host: &#39;127.0.0.1:8000&#39;,
//   accept: &#39;*/*&#39; }
console.log(request.headers);</code></pre>
<!--next-->
<h2>message.rawHeaders</h2>
<p>The raw request/response headers list exactly as they were received.

</p>
<p>Note that the keys and values are in the same list.  It is <em>not</em> a
list of tuples.  So, the even-numbered offsets are key values, and the
odd-numbered offsets are the associated values.

</p>
<p>Header names are not lowercased, and duplicates are not merged.

</p>
<pre><code class="language-javascript">// Prints something like:
//
// [ &#39;user-agent&#39;,
//   &#39;this is invalid because there can be only one&#39;,
//   &#39;User-Agent&#39;,
//   &#39;curl/7.22.0&#39;,
//   &#39;Host&#39;,
//   &#39;127.0.0.1:8000&#39;,
//   &#39;ACCEPT&#39;,
//   &#39;*/*&#39; ]
console.log(request.rawHeaders);</code></pre>
<!--next-->
<h2>message.trailers</h2>
<p>The request/response trailers object. Only populated at the &#39;end&#39; event.

</p>
<!--next-->
<h2>message.rawTrailers</h2>
<p>The raw request/response trailer keys and values exactly as they were
received.  Only populated at the &#39;end&#39; event.

</p>
<!--next-->
<h2>message.setTimeout(msecs, callback)</h2>
<div class="signature"><ul>
<li><code class="language-javascript">msecs</code> <span class="type">Number</span></li>
<li><code class="language-javascript">callback</code> <span class="type">Function</span></li>
</div></ul>
<p>Calls <code class="language-javascript">message.connection.setTimeout(msecs, callback)</code>.

</p>
<!--next-->
<h2>message.method</h2>
<p><strong>Only valid for request obtained from <a>http.Server</a>.</strong>

</p>
<p>The request method as a string. Read only. Example:
<code class="language-javascript">&#39;GET&#39;</code>, <code class="language-javascript">&#39;DELETE&#39;</code>.

</p>
<!--next-->
<h2>message.url</h2>
<p><strong>Only valid for request obtained from <a>http.Server</a>.</strong>

</p>
<p>Request URL string. This contains only the URL that is
present in the actual HTTP request. If the request is:

</p>
<pre><code class="language-javascript">GET /status?name=ryan HTTP/1.1\r\n
Accept: text/plain\r\n
\r\n</code></pre>
<p>Then <code class="language-javascript">request.url</code> will be:

</p>
<pre><code class="language-javascript">&#39;/status?name=ryan&#39;</code></pre>
<p>If you would like to parse the URL into its parts, you can use
<code class="language-javascript">require(&#39;url&#39;).parse(request.url)</code>.  Example:

</p>
<pre><code class="language-javascript">node&gt; require(&#39;url&#39;).parse(&#39;/status?name=ryan&#39;)
{ href: &#39;/status?name=ryan&#39;,
  search: &#39;?name=ryan&#39;,
  query: &#39;name=ryan&#39;,
  pathname: &#39;/status&#39; }</code></pre>
<p>If you would like to extract the params from the query string,
you can use the <code class="language-javascript">require(&#39;querystring&#39;).parse</code> function, or pass
<code class="language-javascript">true</code> as the second argument to <code class="language-javascript">require(&#39;url&#39;).parse</code>.  Example:

</p>
<pre><code class="language-javascript">node&gt; require(&#39;url&#39;).parse(&#39;/status?name=ryan&#39;, true)
{ href: &#39;/status?name=ryan&#39;,
  search: &#39;?name=ryan&#39;,
  query: { name: &#39;ryan&#39; },
  pathname: &#39;/status&#39; }</code></pre>
<!--next-->
<h2>message.statusCode</h2>
<p><strong>Only valid for response obtained from <code class="language-javascript">http.ClientRequest</code>.</strong>

</p>
<p>The 3-digit HTTP response status code. E.G. <code class="language-javascript">404</code>.

</p>
<!--next-->
<h2>message.statusMessage</h2>
<p><strong>Only valid for response obtained from <code class="language-javascript">http.ClientRequest</code>.</strong>

</p>
<p>The HTTP response status message (reason phrase). E.G. <code class="language-javascript">OK</code> or <code class="language-javascript">Internal Server Error</code>.

</p>
<!--next-->
<h2>message.socket</h2>
<p>The <code class="language-javascript">net.Socket</code> object associated with the connection.

</p>
<p>With HTTPS support, use request.connection.verifyPeer() and
request.connection.getPeerCertificate() to obtain the client&#39;s
authentication details.


</p>
<!--next-->
<h2>HTTPS</h2>
<pre class="stability">Stability: 3 - Stable</pre><p>HTTPS is the HTTP protocol over TLS/SSL. In Node this is implemented as a
separate module.

</p>
<!--next-->
<h2>Class: https.Server</h2>
<p>This class is a subclass of <code class="language-javascript">tls.Server</code> and emits events same as
<code class="language-javascript">http.Server</code>. See <code class="language-javascript">http.Server</code> for more information.

</p>
<!--next-->
<h2>server.setTimeout(msecs, callback)</h2>
<p>See <a>http.Server#setTimeout()</a>.

</p>
<!--next-->
<h2>server.timeout</h2>
<p>See <a>http.Server#timeout</a>.

</p>
<!--next-->
<h2>https.createServer(options[, requestListener])</h2>
<p>Returns a new HTTPS web server object. The <code class="language-javascript">options</code> is similar to
<a>tls.createServer()</a>.  The <code class="language-javascript">requestListener</code> is a function which is
automatically added to the <code class="language-javascript">&#39;request&#39;</code> event.

</p>
<p>Example:

</p>
<pre><code class="language-javascript">// curl -k https://localhost:8000/
var https = require(&#39;https&#39;);
var fs = require(&#39;fs&#39;);

var options = {
  key: fs.readFileSync(&#39;test/fixtures/keys/agent2-key.pem&#39;),
  cert: fs.readFileSync(&#39;test/fixtures/keys/agent2-cert.pem&#39;)
};

https.createServer(options, function (req, res) {
  res.writeHead(200);
  res.end(&quot;hello world\n&quot;);
}).listen(8000);</code></pre>
<p>Or

</p>
<pre><code class="language-javascript">var https = require(&#39;https&#39;);
var fs = require(&#39;fs&#39;);

var options = {
  pfx: fs.readFileSync(&#39;server.pfx&#39;)
};

https.createServer(options, function (req, res) {
  res.writeHead(200);
  res.end(&quot;hello world\n&quot;);
}).listen(8000);</code></pre>
<!--next-->
<h2>server.listen(port[, host][, backlog][, callback])</h2>
<!--next-->
<h2>server.listen(path[, callback])</h2>
<!--next-->
<h2>server.listen(handle[, callback])</h2>
<p>See <a>http.listen()</a> for details.

</p>
<!--next-->
<h2>server.close([callback])</h2>
<p>See <a>http.close()</a> for details.

</p>
<!--next-->
<h2>https.request(options, callback)</h2>
<p>Makes a request to a secure web server.

</p>
<p><code class="language-javascript">options</code> can be an object or a string. If <code class="language-javascript">options</code> is a string, it is
automatically parsed with <a>url.parse()</a>.

</p>
<p>All options from <a>http.request()</a> are valid.

</p>
<p>Example:

</p>
<pre><code class="language-javascript">var https = require(&#39;https&#39;);

var options = {
  hostname: &#39;encrypted.google.com&#39;,
  port: 443,
  path: &#39;/&#39;,
  method: &#39;GET&#39;
};

var req = https.request(options, function(res) {
  console.log(&quot;statusCode: &quot;, res.statusCode);
  console.log(&quot;headers: &quot;, res.headers);

  res.on(&#39;data&#39;, function(d) {
    process.stdout.write(d);
  });
});
req.end();

req.on(&#39;error&#39;, function(e) {
  console.error(e);
});</code></pre>
<p>The options argument has the following options

</p>
<ul>
<li><code class="language-javascript">host</code>: A domain name or IP address of the server to issue the request to.
Defaults to <code class="language-javascript">&#39;localhost&#39;</code>.</li>
<li><code class="language-javascript">hostname</code>: To support <code class="language-javascript">url.parse()</code> <code class="language-javascript">hostname</code> is preferred over <code class="language-javascript">host</code></li>
<li><code class="language-javascript">port</code>: Port of remote server. Defaults to 443.</li>
<li><code class="language-javascript">method</code>: A string specifying the HTTP request method. Defaults to <code class="language-javascript">&#39;GET&#39;</code>.</li>
<li><code class="language-javascript">path</code>: Request path. Defaults to <code class="language-javascript">&#39;/&#39;</code>. Should include query string if any.
E.G. <code class="language-javascript">&#39;/index.html?page=12&#39;</code></li>
<li><code class="language-javascript">headers</code>: An object containing request headers.</li>
<li><code class="language-javascript">auth</code>: Basic authentication i.e. <code class="language-javascript">&#39;user:password&#39;</code> to compute an
Authorization header.</li>
<li><code class="language-javascript">agent</code>: Controls <a>Agent</a> behavior. When an Agent is used request will
default to <code class="language-javascript">Connection: keep-alive</code>. Possible values:<ul>
<li><code class="language-javascript">undefined</code> (default): use <a>globalAgent</a> for this host and port.</li>
<li><code class="language-javascript">Agent</code> object: explicitly use the passed in <code class="language-javascript">Agent</code>.</li>
<li><code class="language-javascript">false</code>: opts out of connection pooling with an Agent, defaults request to
<code class="language-javascript">Connection: close</code>.</li>
</ul>
</li>
</ul>
<p>The following options from <a>tls.connect()</a> can also be specified. However, a
<a>globalAgent</a> silently ignores these.

</p>
<ul>
<li><code class="language-javascript">pfx</code>: Certificate, Private key and CA certificates to use for SSL. Default <code class="language-javascript">null</code>.</li>
<li><code class="language-javascript">key</code>: Private key to use for SSL. Default <code class="language-javascript">null</code>.</li>
<li><code class="language-javascript">passphrase</code>: A string of passphrase for the private key or pfx. Default <code class="language-javascript">null</code>.</li>
<li><code class="language-javascript">cert</code>: Public x509 certificate to use. Default <code class="language-javascript">null</code>.</li>
<li><code class="language-javascript">ca</code>: An authority certificate or array of authority certificates to check
the remote host against.</li>
<li><code class="language-javascript">ciphers</code>: A string describing the ciphers to use or exclude. Consult
<a>http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT</a> for
details on the format.</li>
<li><code class="language-javascript">rejectUnauthorized</code>: If <code class="language-javascript">true</code>, the server certificate is verified against
the list of supplied CAs. An <code class="language-javascript">&#39;error&#39;</code> event is emitted if verification
fails. Verification happens at the connection level, <em>before</em> the HTTP
request is sent. Default <code class="language-javascript">true</code>.</li>
<li><code class="language-javascript">secureProtocol</code>: The SSL method to use, e.g. <code class="language-javascript">TLSv1_method</code> to force
TLS version 1. The possible values depend on your installation of
OpenSSL and are defined in the constant <a>SSL_METHODS</a>.</li>
</ul>
<p>In order to specify these options, use a custom <code class="language-javascript">Agent</code>.

</p>
<p>Example:

</p>
<pre><code class="language-javascript">var options = {
  hostname: &#39;encrypted.google.com&#39;,
  port: 443,
  path: &#39;/&#39;,
  method: &#39;GET&#39;,
  key: fs.readFileSync(&#39;test/fixtures/keys/agent2-key.pem&#39;),
  cert: fs.readFileSync(&#39;test/fixtures/keys/agent2-cert.pem&#39;)
};
options.agent = new https.Agent(options);

var req = https.request(options, function(res) {
  ...
}</code></pre>
<p>Or does not use an <code class="language-javascript">Agent</code>.

</p>
<p>Example:

</p>
<pre><code class="language-javascript">var options = {
  hostname: &#39;encrypted.google.com&#39;,
  port: 443,
  path: &#39;/&#39;,
  method: &#39;GET&#39;,
  key: fs.readFileSync(&#39;test/fixtures/keys/agent2-key.pem&#39;),
  cert: fs.readFileSync(&#39;test/fixtures/keys/agent2-cert.pem&#39;),
  agent: false
};

var req = https.request(options, function(res) {
  ...
}</code></pre>
<!--next-->
<h2>https.get(options, callback)</h2>
<p>Like <code class="language-javascript">http.get()</code> but for HTTPS.

</p>
<p><code class="language-javascript">options</code> can be an object or a string. If <code class="language-javascript">options</code> is a string, it is
automatically parsed with <a>url.parse()</a>.

</p>
<p>Example:

</p>
<pre><code class="language-javascript">var https = require(&#39;https&#39;);

https.get(&#39;https://encrypted.google.com/&#39;, function(res) {
  console.log(&quot;statusCode: &quot;, res.statusCode);
  console.log(&quot;headers: &quot;, res.headers);

  res.on(&#39;data&#39;, function(d) {
    process.stdout.write(d);
  });

}).on(&#39;error&#39;, function(e) {
  console.error(e);
});</code></pre>
<!--next-->
<h2>Class: https.Agent</h2>
<p>An Agent object for HTTPS similar to <a>http.Agent</a>.  See <a>https.request()</a>
for more information.


</p>
<!--next-->
<h2>https.globalAgent</h2>
<p>Global instance of <a>https.Agent</a> for all HTTPS client requests.

</p>
<!--next-->
<h2>URL</h2>
<pre class="stability">Stability: 3 - Stable</pre><p>This module has utilities for URL resolution and parsing.
Call <code class="language-javascript">require(&#39;url&#39;)</code> to use it.

</p>
<p>Parsed URL objects have some or all of the following fields, depending on
whether or not they exist in the URL string. Any parts that are not in the URL
string will not be in the parsed object. Examples are shown for the URL

</p>
<p><code class="language-javascript">&#39;http://user:pass@host.com:8080/p/a/t/h?query=string#hash&#39;</code>

</p>
<ul>
<li><p><code class="language-javascript">href</code>: The full URL that was originally parsed. Both the protocol and host are lowercased.</p>
<p>  Example: <code class="language-javascript">&#39;http://user:pass@host.com:8080/p/a/t/h?query=string#hash&#39;</code></p>
</li>
<li><p><code class="language-javascript">protocol</code>: The request protocol, lowercased.</p>
<p>  Example: <code class="language-javascript">&#39;http:&#39;</code></p>
</li>
<li><p><code class="language-javascript">slashes</code>: The protocol requires slashes after the colon</p>
<p>  Example: true or false</p>
</li>
<li><p><code class="language-javascript">host</code>: The full lowercased host portion of the URL, including port
information.</p>
<p>  Example: <code class="language-javascript">&#39;host.com:8080&#39;</code></p>
</li>
<li><p><code class="language-javascript">auth</code>: The authentication information portion of a URL.</p>
<p>  Example: <code class="language-javascript">&#39;user:pass&#39;</code></p>
</li>
<li><p><code class="language-javascript">hostname</code>: Just the lowercased hostname portion of the host.</p>
<p>  Example: <code class="language-javascript">&#39;host.com&#39;</code></p>
</li>
<li><p><code class="language-javascript">port</code>: The port number portion of the host.</p>
<p>  Example: <code class="language-javascript">&#39;8080&#39;</code></p>
</li>
<li><p><code class="language-javascript">pathname</code>: The path section of the URL, that comes after the host and
before the query, including the initial slash if present.</p>
<p>  Example: <code class="language-javascript">&#39;/p/a/t/h&#39;</code></p>
</li>
<li><p><code class="language-javascript">search</code>: The &#39;query string&#39; portion of the URL, including the leading
question mark.</p>
<p>  Example: <code class="language-javascript">&#39;?query=string&#39;</code></p>
</li>
<li><p><code class="language-javascript">path</code>: Concatenation of <code class="language-javascript">pathname</code> and <code class="language-javascript">search</code>.</p>
<p>  Example: <code class="language-javascript">&#39;/p/a/t/h?query=string&#39;</code></p>
</li>
<li><p><code class="language-javascript">query</code>: Either the &#39;params&#39; portion of the query string, or a
querystring-parsed object.</p>
<p>  Example: <code class="language-javascript">&#39;query=string&#39;</code> or <code class="language-javascript">{&#39;query&#39;:&#39;string&#39;}</code></p>
</li>
<li><p><code class="language-javascript">hash</code>: The &#39;fragment&#39; portion of the URL including the pound-sign.</p>
<p>  Example: <code class="language-javascript">&#39;#hash&#39;</code></p>
</li>
</ul>
<p>The following methods are provided by the URL module:

</p>
<!--next-->
<h2>url.parse(urlStr[, parseQueryString][, slashesDenoteHost])</h2>
<p>Take a URL string, and return an object.

</p>
<p>Pass <code class="language-javascript">true</code> as the second argument to also parse the query string using the
<code class="language-javascript">querystring</code> module. If <code class="language-javascript">true</code> then the <code class="language-javascript">query</code> property will always be
assigned an object, and the <code class="language-javascript">search</code> property will always be a (possibly
empty) string.  Defaults to <code class="language-javascript">false</code>.

</p>
<p>Pass <code class="language-javascript">true</code> as the third argument to treat <code class="language-javascript">//foo/bar</code> as
<code class="language-javascript">{ host: &#39;foo&#39;, pathname: &#39;/bar&#39; }</code> rather than
<code class="language-javascript">{ pathname: &#39;//foo/bar&#39; }</code>. Defaults to <code class="language-javascript">false</code>.

</p>
<!--next-->
<h2>url.format(urlObj)</h2>
<p>Take a parsed URL object, and return a formatted URL string.

</p>
<p>Here&#39;s how the formatting process works:

</p>
<ul>
<li><code class="language-javascript">href</code> will be ignored.</li>
<li><code class="language-javascript">protocol</code> is treated the same with or without the trailing <code class="language-javascript">:</code> (colon).<ul>
<li>The protocols <code class="language-javascript">http</code>, <code class="language-javascript">https</code>, <code class="language-javascript">ftp</code>, <code class="language-javascript">gopher</code>, <code class="language-javascript">file</code> will be
postfixed with <code class="language-javascript">://</code> (colon-slash-slash).</li>
<li>All other protocols <code class="language-javascript">mailto</code>, <code class="language-javascript">xmpp</code>, <code class="language-javascript">aim</code>, <code class="language-javascript">sftp</code>, <code class="language-javascript">foo</code>, etc will
be postfixed with <code class="language-javascript">:</code> (colon)</li>
</ul>
</li>
<li><code class="language-javascript">slashes</code> set to <code class="language-javascript">true</code> if the protocol requires <code class="language-javascript">://</code> (colon-slash-slash)<ul>
<li>Only needs to be set for protocols not previously listed as requiring
slashes, such as <code class="language-javascript">mongodb://localhost:8000/</code></li>
</ul>
</li>
<li><code class="language-javascript">auth</code> will be used if present.</li>
<li><code class="language-javascript">hostname</code> will only be used if <code class="language-javascript">host</code> is absent.</li>
<li><code class="language-javascript">port</code> will only be used if <code class="language-javascript">host</code> is absent.</li>
<li><code class="language-javascript">host</code> will be used in place of <code class="language-javascript">hostname</code> and <code class="language-javascript">port</code></li>
<li><code class="language-javascript">pathname</code> is treated the same with or without the leading <code class="language-javascript">/</code> (slash).</li>
<li><code class="language-javascript">search</code> will be used in place of <code class="language-javascript">query</code>.<ul>
<li>It is treated the same with or without the leading <code class="language-javascript">?</code> (question mark)</li>
</ul>
</li>
<li><code class="language-javascript">query</code> (object; see <code class="language-javascript">querystring</code>) will only be used if <code class="language-javascript">search</code> is absent.</li>
<li><code class="language-javascript">hash</code> is treated the same with or without the leading <code class="language-javascript">#</code> (pound sign, anchor).</li>
</ul>
<!--next-->
<h2>url.resolve(from, to)</h2>
<p>Take a base URL, and a href URL, and resolve them as a browser would for
an anchor tag.  Examples:

</p>
<pre><code class="language-javascript">url.resolve(&#39;/one/two/three&#39;, &#39;four&#39;)         // &#39;/one/two/four&#39;
url.resolve(&#39;http://example.com/&#39;, &#39;/one&#39;)    // &#39;http://example.com/one&#39;
url.resolve(&#39;http://example.com/one&#39;, &#39;/two&#39;) // &#39;http://example.com/two&#39;</code></pre>
<!--next-->
<h2>Query String</h2>
<pre class="stability">Stability: 3 - Stable</pre>

<p>This module provides utilities for dealing with query strings.
It provides the following methods:

</p>
<!--next-->
<h2>querystring.stringify(obj[, sep][, eq][, options])</h2>
<p>Serialize an object to a query string.
Optionally override the default separator (<code class="language-javascript">&#39;&amp;&#39;</code>) and assignment (<code class="language-javascript">&#39;=&#39;</code>)
characters.

</p>
<p>Options object may contain <code class="language-javascript">encodeURIComponent</code> property (<code class="language-javascript">querystring.escape</code> by default),
it can be used to encode string with <code class="language-javascript">non-utf8</code> encoding if necessary.

</p>
<p>Example:

</p>
<pre><code class="language-javascript">querystring.stringify({ foo: &#39;bar&#39;, baz: [&#39;qux&#39;, &#39;quux&#39;], corge: &#39;&#39; })
// returns
&#39;foo=bar&amp;baz=qux&amp;baz=quux&amp;corge=&#39;

querystring.stringify({foo: &#39;bar&#39;, baz: &#39;qux&#39;}, &#39;;&#39;, &#39;:&#39;)
// returns
&#39;foo:bar;baz:qux&#39;

// Suppose gbkEncodeURIComponent function already exists,
// it can encode string with `gbk` encoding
querystring.stringify({ w: &#39;&#39;, foo: &#39;bar&#39; }, null, null,
  { encodeURIComponent: gbkEncodeURIComponent })
// returns
&#39;w=%D6%D0%CE%C4&amp;foo=bar&#39;</code></pre>
<!--next-->
<h2>querystring.parse(str[, sep][, eq][, options])</h2>
<p>Deserialize a query string to an object.
Optionally override the default separator (<code class="language-javascript">&#39;&amp;&#39;</code>) and assignment (<code class="language-javascript">&#39;=&#39;</code>)
characters.

</p>
<p>Options object may contain <code class="language-javascript">maxKeys</code> property (equal to 1000 by default), it&#39;ll
be used to limit processed keys. Set it to 0 to remove key count limitation.

</p>
<p>Options object may contain <code class="language-javascript">decodeURIComponent</code> property (<code class="language-javascript">decodeURIComponent</code> by default),
it can be used to decode <code class="language-javascript">non-utf8</code> encoding string if necessary.

</p>
<p>Example:

</p>
<pre><code class="language-javascript">querystring.parse(&#39;foo=bar&amp;baz=qux&amp;baz=quux&amp;corge&#39;)
// returns
{ foo: &#39;bar&#39;, baz: [&#39;qux&#39;, &#39;quux&#39;], corge: &#39;&#39; }

// Suppose gbkDecodeURIComponent function already exists,
// it can decode `gbk` encoding string
querystring.parse(&#39;w=%D6%D0%CE%C4&amp;foo=bar&#39;, null, null,
  { decodeURIComponent: gbkDecodeURIComponent })
// returns
{ w: &#39;&#39;, foo: &#39;bar&#39; }</code></pre>
<!--next-->
<h2>querystring.escape</h2>
<p>The escape function used by <code class="language-javascript">querystring.stringify</code>,
provided so that it could be overridden if necessary.

</p>
<!--next-->
<h2>querystring.unescape</h2>
<p>The unescape function used by <code class="language-javascript">querystring.parse</code>,
provided so that it could be overridden if necessary.

</p>
<!--next-->
<h2>punycode</h2>
<pre class="stability">Stability: 2 - Unstable</pre><p><a>Punycode.js</a> is bundled with Node.js v0.6.2+. Use
<code class="language-javascript">require(&#39;punycode&#39;)</code> to access it. (To use it with other Node.js versions,
use npm to install the <code class="language-javascript">punycode</code> module first.)

</p>
<!--next-->
<h2>punycode.decode(string)</h2>
<p>Converts a Punycode string of ASCII-only symbols to a string of Unicode symbols.

</p>
<pre><code class="language-javascript">// decode domain name parts
punycode.decode(&#39;maana-pta&#39;); // &#39;maana&#39;
punycode.decode(&#39;--dqo34k&#39;); // &#39;-&#39;</code></pre>
<!--next-->
<h2>punycode.encode(string)</h2>
<p>Converts a string of Unicode symbols to a Punycode string of ASCII-only symbols.

</p>
<pre><code class="language-javascript">// encode domain name parts
punycode.encode(&#39;maana&#39;); // &#39;maana-pta&#39;
punycode.encode(&#39;-&#39;); // &#39;--dqo34k&#39;</code></pre>
<!--next-->
<h2>punycode.toUnicode(domain)</h2>
<p>Converts a Punycode string representing a domain name to Unicode. Only the
Punycoded parts of the domain name will be converted, i.e. it doesn&#39;t matter if
you call it on a string that has already been converted to Unicode.

</p>
<pre><code class="language-javascript">// decode domain names
punycode.toUnicode(&#39;xn--maana-pta.com&#39;); // &#39;maana.com&#39;
punycode.toUnicode(&#39;xn----dqo34k.com&#39;); // &#39;-.com&#39;</code></pre>
<!--next-->
<h2>punycode.toASCII(domain)</h2>
<p>Converts a Unicode string representing a domain name to Punycode. Only the
non-ASCII parts of the domain name will be converted, i.e. it doesn&#39;t matter if
you call it with a domain that&#39;s already in ASCII.

</p>
<pre><code class="language-javascript">// encode domain names
punycode.toASCII(&#39;maana.com&#39;); // &#39;xn--maana-pta.com&#39;
punycode.toASCII(&#39;-.com&#39;); // &#39;xn----dqo34k.com&#39;</code></pre>
<!--next-->
<h2>punycode.ucs2</h2>
<!--next-->
<h2>punycode.ucs2.decode(string)</h2>
<p>Creates an array containing the numeric code point values of each Unicode
symbol in the string. While <a>JavaScript uses UCS-2
internally</a>, this function
will convert a pair of surrogate halves (each of which UCS-2 exposes as
separate characters) into a single code point, matching UTF-16.

</p>
<pre><code class="language-javascript">punycode.ucs2.decode(&#39;abc&#39;); // [0x61, 0x62, 0x63]
// surrogate pair for U+1D306 tetragram for centre:
punycode.ucs2.decode(&#39;\uD834\uDF06&#39;); // [0x1D306]</code></pre>
<!--next-->
<h2>punycode.ucs2.encode(codePoints)</h2>
<p>Creates a string based on an array of numeric code point values.

</p>
<pre><code class="language-javascript">punycode.ucs2.encode([0x61, 0x62, 0x63]); // &#39;abc&#39;
punycode.ucs2.encode([0x1D306]); // &#39;\uD834\uDF06&#39;</code></pre>
<!--next-->
<h2>punycode.version</h2>
<p>A string representing the current Punycode.js version number.

</p>
<!--next-->
<h2>Readline</h2>
<pre class="stability">Stability: 2 - Unstable</pre><p>To use this module, do <code class="language-javascript">require(&#39;readline&#39;)</code>. Readline allows reading of a
stream (such as <code class="language-javascript">process.stdin</code>) on a line-by-line basis.

</p>
<p>Note that once you&#39;ve invoked this module, your node program will not
terminate until you&#39;ve closed the interface. Here&#39;s how to allow your
program to gracefully exit:

</p>
<pre><code class="language-javascript">var readline = require(&#39;readline&#39;);

var rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

rl.question(&quot;What do you think of node.js? &quot;, function(answer) {
  // TODO: Log the answer in a database
  console.log(&quot;Thank you for your valuable feedback:&quot;, answer);

  rl.close();
});</code></pre>
<!--next-->
<h2>readline.createInterface(options)</h2>
<p>Creates a readline <code class="language-javascript">Interface</code> instance. Accepts an &quot;options&quot; Object that takes
the following values:

</p>
<ul>
<li><p><code class="language-javascript">input</code> - the readable stream to listen to (Required).</p>
</li>
<li><p><code class="language-javascript">output</code> - the writable stream to write readline data to (Optional).</p>
</li>
<li><p><code class="language-javascript">completer</code> - an optional function that is used for Tab autocompletion. See
below for an example of using this.</p>
</li>
<li><p><code class="language-javascript">terminal</code> - pass <code class="language-javascript">true</code> if the <code class="language-javascript">input</code> and <code class="language-javascript">output</code> streams should be
treated like a TTY, and have ANSI/VT100 escape codes written to it.
Defaults to checking <code class="language-javascript">isTTY</code> on the <code class="language-javascript">output</code> stream upon instantiation.</p>
</li>
</ul>
<p>The <code class="language-javascript">completer</code> function is given the current line entered by the user, and
is supposed to return an Array with 2 entries:

</p>
<ol>
<li><p>An Array with matching entries for the completion.</p>
</li>
<li><p>The substring that was used for the matching.</p>
</li>
</ol>
<p>Which ends up looking something like:
<code class="language-javascript">[[substr1, substr2, ...], originalsubstring]</code>.

</p>
<p>Example:

</p>
<pre><code class="language-javascript">function completer(line) {
  var completions = &#39;.help .error .exit .quit .q&#39;.split(&#39; &#39;)
  var hits = completions.filter(function(c) { return c.indexOf(line) == 0 })
  // show all completions if none found
  return [hits.length ? hits : completions, line]
}</code></pre>
<p>Also <code class="language-javascript">completer</code> can be run in async mode if it accepts two arguments:

</p>
<pre><code class="language-javascript">function completer(linePartial, callback) {
  callback(null, [[&#39;123&#39;], linePartial]);
}</code></pre>
<p><code class="language-javascript">createInterface</code> is commonly used with <code class="language-javascript">process.stdin</code> and
<code class="language-javascript">process.stdout</code> in order to accept user input:

</p>
<pre><code class="language-javascript">var readline = require(&#39;readline&#39;);
var rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});</code></pre>
<p>Once you have a readline instance, you most commonly listen for the
<code class="language-javascript">&quot;line&quot;</code> event.

</p>
<p>If <code class="language-javascript">terminal</code> is <code class="language-javascript">true</code> for this instance then the <code class="language-javascript">output</code> stream will get
the best compatibility if it defines an <code class="language-javascript">output.columns</code> property, and fires
a <code class="language-javascript">&quot;resize&quot;</code> event on the <code class="language-javascript">output</code> if/when the columns ever change
(<code class="language-javascript">process.stdout</code> does this automatically when it is a TTY).

</p>
<!--next-->
<h2>Class: Interface</h2>
<p>The class that represents a readline interface with an input and output
stream.

</p>
<!--next-->
<h2>rl.setPrompt(prompt)</h2>
<p>Sets the prompt, for example when you run <code class="language-javascript">node</code> on the command line, you see
<code class="language-javascript">&gt; </code>, which is node&#39;s prompt.

</p>
<!--next-->
<h2>rl.prompt([preserveCursor])</h2>
<p>Readies readline for input from the user, putting the current <code class="language-javascript">setPrompt</code>
options on a new line, giving the user a new spot to write. Set <code class="language-javascript">preserveCursor</code>
to <code class="language-javascript">true</code> to prevent the cursor placement being reset to <code class="language-javascript">0</code>.

</p>
<p>This will also resume the <code class="language-javascript">input</code> stream used with <code class="language-javascript">createInterface</code> if it has
been paused.

</p>
<p>If <code class="language-javascript">output</code> is set to <code class="language-javascript">null</code> or <code class="language-javascript">undefined</code> when calling <code class="language-javascript">createInterface</code>, the
prompt is not written.

</p>
<!--next-->
<h2>rl.question(query, callback)</h2>
<p>Prepends the prompt with <code class="language-javascript">query</code> and invokes <code class="language-javascript">callback</code> with the user&#39;s
response. Displays the query to the user, and then invokes <code class="language-javascript">callback</code>
with the user&#39;s response after it has been typed.

</p>
<p>This will also resume the <code class="language-javascript">input</code> stream used with <code class="language-javascript">createInterface</code> if
it has been paused.

</p>
<p>If <code class="language-javascript">output</code> is set to <code class="language-javascript">null</code> or <code class="language-javascript">undefined</code> when calling <code class="language-javascript">createInterface</code>,
nothing is displayed.

</p>
<p>Example usage:

</p>
<pre><code class="language-javascript">interface.question(&#39;What is your favorite food?&#39;, function(answer) {
  console.log(&#39;Oh, so your favorite food is &#39; + answer);
});</code></pre>
<!--next-->
<h2>rl.pause()</h2>
<p>Pauses the readline <code class="language-javascript">input</code> stream, allowing it to be resumed later if needed.

</p>
<p>Note that this doesn&#39;t immediately pause the stream of events. Several events may be emitted after calling <code class="language-javascript">pause</code>, including <code class="language-javascript">line</code>.

</p>
<!--next-->
<h2>rl.resume()</h2>
<p>Resumes the readline <code class="language-javascript">input</code> stream.

</p>
<!--next-->
<h2>rl.close()</h2>
<p>Closes the <code class="language-javascript">Interface</code> instance, relinquishing control on the <code class="language-javascript">input</code> and
<code class="language-javascript">output</code> streams. The &quot;close&quot; event will also be emitted.

</p>
<!--next-->
<h2>rl.write(data[, key])</h2>
<p>Writes <code class="language-javascript">data</code> to <code class="language-javascript">output</code> stream, unless <code class="language-javascript">output</code> is set to <code class="language-javascript">null</code> or
<code class="language-javascript">undefined</code> when calling <code class="language-javascript">createInterface</code>. <code class="language-javascript">key</code> is an object literal to
represent a key sequence; available if the terminal is a TTY.

</p>
<p>This will also resume the <code class="language-javascript">input</code> stream if it has been paused.

</p>
<p>Example:

</p>
<pre><code class="language-javascript">rl.write(&#39;Delete me!&#39;);
// Simulate ctrl+u to delete the line written previously
rl.write(null, {ctrl: true, name: &#39;u&#39;});</code></pre>
<!--next-->
<h2>Events</h2>
<!--next-->
<h2>Event: &#39;line&#39;</h2>
<p><code class="language-javascript">function (line) {}</code>

</p>
<p>Emitted whenever the <code class="language-javascript">input</code> stream receives a <code class="language-javascript">\n</code>, usually received when the
user hits enter, or return. This is a good hook to listen for user input.

</p>
<p>Example of listening for <code class="language-javascript">line</code>:

</p>
<pre><code class="language-javascript">rl.on(&#39;line&#39;, function (cmd) {
  console.log(&#39;You just typed: &#39;+cmd);
});</code></pre>
<!--next-->
<h2>Event: &#39;pause&#39;</h2>
<p><code class="language-javascript">function () {}</code>

</p>
<p>Emitted whenever the <code class="language-javascript">input</code> stream is paused.

</p>
<p>Also emitted whenever the <code class="language-javascript">input</code> stream is not paused and receives the
<code class="language-javascript">SIGCONT</code> event. (See events <code class="language-javascript">SIGTSTP</code> and <code class="language-javascript">SIGCONT</code>)

</p>
<p>Example of listening for <code class="language-javascript">pause</code>:

</p>
<pre><code class="language-javascript">rl.on(&#39;pause&#39;, function() {
  console.log(&#39;Readline paused.&#39;);
});</code></pre>
<!--next-->
<h2>Event: &#39;resume&#39;</h2>
<p><code class="language-javascript">function () {}</code>

</p>
<p>Emitted whenever the <code class="language-javascript">input</code> stream is resumed.

</p>
<p>Example of listening for <code class="language-javascript">resume</code>:

</p>
<pre><code class="language-javascript">rl.on(&#39;resume&#39;, function() {
  console.log(&#39;Readline resumed.&#39;);
});</code></pre>
<!--next-->
<h2>Event: &#39;close&#39;</h2>
<p><code class="language-javascript">function () {}</code>

</p>
<p>Emitted when <code class="language-javascript">close()</code> is called.

</p>
<p>Also emitted when the <code class="language-javascript">input</code> stream receives its &quot;end&quot; event. The <code class="language-javascript">Interface</code>
instance should be considered &quot;finished&quot; once this is emitted. For example, when
the <code class="language-javascript">input</code> stream receives <code class="language-javascript">^D</code>, respectively known as <code class="language-javascript">EOT</code>.

</p>
<p>This event is also called if there is no <code class="language-javascript">SIGINT</code> event listener present when
the <code class="language-javascript">input</code> stream receives a <code class="language-javascript">^C</code>, respectively known as <code class="language-javascript">SIGINT</code>.

</p>
<!--next-->
<h2>Event: &#39;SIGINT&#39;</h2>
<p><code class="language-javascript">function () {}</code>

</p>
<p>Emitted whenever the <code class="language-javascript">input</code> stream receives a <code class="language-javascript">^C</code>, respectively known as
<code class="language-javascript">SIGINT</code>. If there is no <code class="language-javascript">SIGINT</code> event listener present when the <code class="language-javascript">input</code>
stream receives a <code class="language-javascript">SIGINT</code>, <code class="language-javascript">pause</code> will be triggered.

</p>
<p>Example of listening for <code class="language-javascript">SIGINT</code>:

</p>
<pre><code class="language-javascript">rl.on(&#39;SIGINT&#39;, function() {
  rl.question(&#39;Are you sure you want to exit?&#39;, function(answer) {
    if (answer.match(/^y(es)?$/i)) rl.pause();
  });
});</code></pre>
<!--next-->
<h2>Event: &#39;SIGTSTP&#39;</h2>
<p><code class="language-javascript">function () {}</code>

</p>
<p><strong>This does not work on Windows.</strong>

</p>
<p>Emitted whenever the <code class="language-javascript">input</code> stream receives a <code class="language-javascript">^Z</code>, respectively known as
<code class="language-javascript">SIGTSTP</code>. If there is no <code class="language-javascript">SIGTSTP</code> event listener present when the <code class="language-javascript">input</code>
stream receives a <code class="language-javascript">SIGTSTP</code>, the program will be sent to the background.

</p>
<p>When the program is resumed with <code class="language-javascript">fg</code>, the <code class="language-javascript">pause</code> and <code class="language-javascript">SIGCONT</code> events will be
emitted. You can use either to resume the stream.

</p>
<p>The <code class="language-javascript">pause</code> and <code class="language-javascript">SIGCONT</code> events will not be triggered if the stream was paused
before the program was sent to the background.

</p>
<p>Example of listening for <code class="language-javascript">SIGTSTP</code>:

</p>
<pre><code class="language-javascript">rl.on(&#39;SIGTSTP&#39;, function() {
  // This will override SIGTSTP and prevent the program from going to the
  // background.
  console.log(&#39;Caught SIGTSTP.&#39;);
});</code></pre>
<!--next-->
<h2>Event: &#39;SIGCONT&#39;</h2>
<p><code class="language-javascript">function () {}</code>

</p>
<p><strong>This does not work on Windows.</strong>

</p>
<p>Emitted whenever the <code class="language-javascript">input</code> stream is sent to the background with <code class="language-javascript">^Z</code>,
respectively known as <code class="language-javascript">SIGTSTP</code>, and then continued with <code class="language-javascript">fg(1)</code>. This event
only emits if the stream was not paused before sending the program to the
background.

</p>
<p>Example of listening for <code class="language-javascript">SIGCONT</code>:

</p>
<pre><code class="language-javascript">rl.on(&#39;SIGCONT&#39;, function() {
  // `prompt` will automatically resume the stream
  rl.prompt();
});</code></pre>
<!--next-->
<h2>Example: Tiny CLI</h2>
<p>Here&#39;s an example of how to use all these together to craft a tiny command
line interface:

</p>
<pre><code class="language-javascript">var readline = require(&#39;readline&#39;),
    rl = readline.createInterface(process.stdin, process.stdout);

rl.setPrompt(&#39;OHAI&gt; &#39;);
rl.prompt();

rl.on(&#39;line&#39;, function(line) {
  switch(line.trim()) {
    case &#39;hello&#39;:
      console.log(&#39;world!&#39;);
      break;
    default:
      console.log(&#39;Say what? I might have heard `&#39; + line.trim() + &#39;`&#39;);
      break;
  }
  rl.prompt();
}).on(&#39;close&#39;, function() {
  console.log(&#39;Have a great day!&#39;);
  process.exit(0);
});</code></pre>
<!--next-->
<h2>readline.cursorTo(stream, x, y)</h2>
<p>Move cursor to the specified position in a given TTY stream.

</p>
<!--next-->
<h2>readline.moveCursor(stream, dx, dy)</h2>
<p>Move cursor relative to it&#39;s current position in a given TTY stream.

</p>
<!--next-->
<h2>readline.clearLine(stream, dir)</h2>
<p>Clears current line of given TTY stream in a specified direction.
<code class="language-javascript">dir</code> should have one of following values:

</p>
<ul>
<li><code class="language-javascript">-1</code> - to the left from cursor</li>
<li><code class="language-javascript">1</code> - to the right from cursor</li>
<li><code class="language-javascript">0</code> - the entire line</li>
</ul>
<!--next-->
<h2>readline.clearScreenDown(stream)</h2>
<p>Clears the screen from the current position of the cursor down.

</p>
<!--next-->
<h2>REPL</h2>
<pre class="stability">Stability: 3 - Stable</pre><p>A Read-Eval-Print-Loop (REPL) is available both as a standalone program and
easily includable in other programs. The REPL provides a way to interactively
run JavaScript and see the results.  It can be used for debugging, testing, or
just trying things out.

</p>
<p>By executing <code class="language-javascript">node</code> without any arguments from the command-line you will be
dropped into the REPL. It has simplistic emacs line-editing.

</p>
<pre><code class="language-javascript">mjr:~$ node
Type &#39;.help&#39; for options.
&gt; a = [ 1, 2, 3];
[ 1, 2, 3 ]
&gt; a.forEach(function (v) {
...   console.log(v);
...   });
1
2
3</code></pre>
<p>For advanced line-editors, start node with the environmental variable
<code class="language-javascript">NODE_NO_READLINE=1</code>. This will start the main and debugger REPL in canonical
terminal settings which will allow you to use with <code class="language-javascript">rlwrap</code>.

</p>
<p>For example, you could add this to your bashrc file:

</p>
<pre><code class="language-javascript">alias node=&quot;env NODE_NO_READLINE=1 rlwrap node&quot;</code></pre>
<!--next-->
<h2>repl.start(options)</h2>
<p>Returns and starts a <code class="language-javascript">REPLServer</code> instance, that inherits from
[Readline Interface][]. Accepts an &quot;options&quot; Object that takes
the following values:

</p>
<ul>
<li><p><code class="language-javascript">prompt</code> - the prompt and <code class="language-javascript">stream</code> for all I/O. Defaults to <code class="language-javascript">&gt; </code>.</p>
</li>
<li><p><code class="language-javascript">input</code> - the readable stream to listen to. Defaults to <code class="language-javascript">process.stdin</code>.</p>
</li>
<li><p><code class="language-javascript">output</code> - the writable stream to write readline data to. Defaults to
<code class="language-javascript">process.stdout</code>.</p>
</li>
<li><p><code class="language-javascript">terminal</code> - pass <code class="language-javascript">true</code> if the <code class="language-javascript">stream</code> should be treated like a TTY, and
have ANSI/VT100 escape codes written to it. Defaults to checking <code class="language-javascript">isTTY</code>
on the <code class="language-javascript">output</code> stream upon instantiation.</p>
</li>
<li><p><code class="language-javascript">eval</code> - function that will be used to eval each given line. Defaults to
an async wrapper for <code class="language-javascript">eval()</code>. See below for an example of a custom <code class="language-javascript">eval</code>.</p>
</li>
<li><p><code class="language-javascript">useColors</code> - a boolean which specifies whether or not the <code class="language-javascript">writer</code> function
should output colors. If a different <code class="language-javascript">writer</code> function is set then this does
nothing. Defaults to the repl&#39;s <code class="language-javascript">terminal</code> value.</p>
</li>
<li><p><code class="language-javascript">useGlobal</code> - if set to <code class="language-javascript">true</code>, then the repl will use the <code class="language-javascript">global</code> object,
instead of running scripts in a separate context. Defaults to <code class="language-javascript">false</code>.</p>
</li>
<li><p><code class="language-javascript">ignoreUndefined</code> - if set to <code class="language-javascript">true</code>, then the repl will not output the
return value of command if it&#39;s <code class="language-javascript">undefined</code>. Defaults to <code class="language-javascript">false</code>.</p>
</li>
<li><p><code class="language-javascript">writer</code> - the function to invoke for each command that gets evaluated which
returns the formatting (including coloring) to display. Defaults to
<code class="language-javascript">util.inspect</code>.</p>
</li>
</ul>
<p>You can use your own <code class="language-javascript">eval</code> function if it has following signature:

</p>
<pre><code class="language-javascript">function eval(cmd, context, filename, callback) {
  callback(null, result);
}</code></pre>
<p>Multiple REPLs may be started against the same running instance of node.  Each
will share the same global object but will have unique I/O.

</p>
<p>Here is an example that starts a REPL on stdin, a Unix socket, and a TCP socket:

</p>
<pre><code class="language-javascript">var net = require(&quot;net&quot;),
    repl = require(&quot;repl&quot;);

connections = 0;

repl.start({
  prompt: &quot;node via stdin&gt; &quot;,
  input: process.stdin,
  output: process.stdout
});

net.createServer(function (socket) {
  connections += 1;
  repl.start({
    prompt: &quot;node via Unix socket&gt; &quot;,
    input: socket,
    output: socket
  }).on(&#39;exit&#39;, function() {
    socket.end();
  })
}).listen(&quot;/tmp/node-repl-sock&quot;);

net.createServer(function (socket) {
  connections += 1;
  repl.start({
    prompt: &quot;node via TCP socket&gt; &quot;,
    input: socket,
    output: socket
  }).on(&#39;exit&#39;, function() {
    socket.end();
  });
}).listen(5001);</code></pre>
<p>Running this program from the command line will start a REPL on stdin.  Other
REPL clients may connect through the Unix socket or TCP socket. <code class="language-javascript">telnet</code> is useful
for connecting to TCP sockets, and <code class="language-javascript">socat</code> can be used to connect to both Unix and
TCP sockets.

</p>
<p>By starting a REPL from a Unix socket-based server instead of stdin, you can
connect to a long-running node process without restarting it.

</p>
<p>For an example of running a &quot;full-featured&quot; (<code class="language-javascript">terminal</code>) REPL over
a <code class="language-javascript">net.Server</code> and <code class="language-javascript">net.Socket</code> instance, see: <a>https://gist.github.com/2209310</a>

</p>
<p>For an example of running a REPL instance over <code class="language-javascript">curl(1)</code>,
see: <a>https://gist.github.com/2053342</a>

</p>
<!--next-->
<h2>Event: &#39;exit&#39;</h2>
<p><code class="language-javascript">function () {}</code>

</p>
<p>Emitted when the user exits the REPL in any of the defined ways. Namely, typing
<code class="language-javascript">.exit</code> at the repl, pressing Ctrl+C twice to signal SIGINT, or pressing Ctrl+D
to signal &quot;end&quot; on the <code class="language-javascript">input</code> stream.

</p>
<p>Example of listening for <code class="language-javascript">exit</code>:

</p>
<pre><code class="language-javascript">r.on(&#39;exit&#39;, function () {
  console.log(&#39;Got &quot;exit&quot; event from repl!&#39;);
  process.exit();
});</code></pre>
<!--next-->
<h2>Event: &#39;reset&#39;</h2>
<p><code class="language-javascript">function (context) {}</code>

</p>
<p>Emitted when the REPL&#39;s context is reset. This happens when you type <code class="language-javascript">.clear</code>.
If you start the repl with <code class="language-javascript">{ useGlobal: true }</code> then this event will never
be emitted.

</p>
<p>Example of listening for <code class="language-javascript">reset</code>:

</p>
<pre><code class="language-javascript">// Extend the initial repl context.
r = repl.start({ options ... });
someExtension.extend(r.context);

// When a new context is created extend it as well.
r.on(&#39;reset&#39;, function (context) {
  console.log(&#39;repl has a new context&#39;);
  someExtension.extend(context);
});</code></pre>
<!--next-->
<h2>REPL Features</h2>
<!-- type=misc -->

<p>Inside the REPL, Control+D will exit.  Multi-line expressions can be input.
Tab completion is supported for both global and local variables.

</p>
<p>The special variable <code class="language-javascript">_</code> (underscore) contains the result of the last expression.

</p>
<pre><code class="language-javascript">&gt; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
[ &#39;a&#39;, &#39;b&#39;, &#39;c&#39; ]
&gt; _.length
3
&gt; _ += 1
4</code></pre>
<p>The REPL provides access to any variables in the global scope. You can expose
a variable to the REPL explicitly by assigning it to the <code class="language-javascript">context</code> object
associated with each <code class="language-javascript">REPLServer</code>.  For example:

</p>
<pre><code class="language-javascript">// repl_test.js
var repl = require(&quot;repl&quot;),
    msg = &quot;message&quot;;

repl.start(&quot;&gt; &quot;).context.m = msg;</code></pre>
<p>Things in the <code class="language-javascript">context</code> object appear as local within the REPL:

</p>
<pre><code class="language-javascript">mjr:~$ node repl_test.js
&gt; m
&#39;message&#39;</code></pre>
<p>There are a few special REPL commands:

</p>
<ul>
<li><code class="language-javascript">.break</code> - While inputting a multi-line expression, sometimes you get lost
or just don&#39;t care about completing it. <code class="language-javascript">.break</code> will start over.</li>
<li><code class="language-javascript">.clear</code> - Resets the <code class="language-javascript">context</code> object to an empty object and clears any
multi-line expression.</li>
<li><code class="language-javascript">.exit</code> - Close the I/O stream, which will cause the REPL to exit.</li>
<li><code class="language-javascript">.help</code> - Show this list of special commands.</li>
<li><code class="language-javascript">.save</code> - Save the current REPL session to a file<blockquote>
<p>.save ./file/to/save.js</p>
</blockquote>
</li>
<li><code class="language-javascript">.load</code> - Load a file into the current REPL session.<blockquote>
<p>.load ./file/to/load.js</p>
</blockquote>
</li>
</ul>
<p>The following key combinations in the REPL have these special effects:

</p>
<ul>
<li><code class="language-javascript">&lt;ctrl&gt;C</code> - Similar to the <code class="language-javascript">.break</code> keyword.  Terminates the current
command.  Press twice on a blank line to forcibly exit.</li>
<li><code class="language-javascript">&lt;ctrl&gt;D</code> - Similar to the <code class="language-javascript">.exit</code> keyword.</li>
</ul>
<!--next-->
<h2>Executing JavaScript</h2>
<pre class="stability">Stability: 3 - Stable</pre>

<p>You can access this module with:

</p>
<pre><code class="language-javascript">var vm = require(&#39;vm&#39;);</code></pre>
<p>JavaScript code can be compiled and run immediately or compiled, saved, and run
later.

</p>
<!--next-->
<h2>vm.runInThisContext(code[, options])</h2>
<p><code class="language-javascript">vm.runInThisContext()</code> compiles <code class="language-javascript">code</code>, runs it and returns the result. Running
code does not have access to local scope, but does have access to the current
<code class="language-javascript">global</code> object.

</p>
<p>Example of using <code class="language-javascript">vm.runInThisContext</code> and <code class="language-javascript">eval</code> to run the same code:

</p>
<pre><code class="language-javascript">var localVar = &#39;initial value&#39;;

var vmResult = vm.runInThisContext(&#39;localVar = &quot;vm&quot;;&#39;);
console.log(&#39;vmResult: &#39;, vmResult);
console.log(&#39;localVar: &#39;, localVar);

var evalResult = eval(&#39;localVar = &quot;eval&quot;;&#39;);
console.log(&#39;evalResult: &#39;, evalResult);
console.log(&#39;localVar: &#39;, localVar);

// vmResult: &#39;vm&#39;, localVar: &#39;initial value&#39;
// evalResult: &#39;eval&#39;, localVar: &#39;eval&#39;</code></pre>
<p><code class="language-javascript">vm.runInThisContext</code> does not have access to the local scope, so <code class="language-javascript">localVar</code> is
unchanged. <code class="language-javascript">eval</code> does have access to the local scope, so <code class="language-javascript">localVar</code> is changed.

</p>
<p>In this way <code class="language-javascript">vm.runInThisContext</code> is much like an <a>indirect <code class="language-javascript">eval</code> call</a>,
e.g. <code class="language-javascript">(0,eval)(&#39;code&#39;)</code>. However, it also has the following additional options:

</p>
<ul>
<li><code class="language-javascript">filename</code>: allows you to control the filename that shows up in any stack
traces produced.</li>
<li><code class="language-javascript">displayErrors</code>: whether or not to print any errors to stderr, with the
line of code that caused them highlighted, before throwing an exception.
Will capture both syntax errors from compiling <code class="language-javascript">code</code> and runtime errors
thrown by executing the compiled code. Defaults to <code class="language-javascript">true</code>.</li>
<li><code class="language-javascript">timeout</code>: a number of milliseconds to execute <code class="language-javascript">code</code> before terminating
execution. If execution is terminated, an <code class="language-javascript">Error</code> will be thrown.</li>
</ul>
<!--next-->
<h2>vm.createContext([sandbox])</h2>
<p>If given a <code class="language-javascript">sandbox</code> object, will &quot;contextify&quot; that sandbox so that it can be
used in calls to <code class="language-javascript">vm.runInContext</code> or <code class="language-javascript">script.runInContext</code>. Inside scripts run
as such, <code class="language-javascript">sandbox</code> will be the global object, retaining all its existing
properties but also having the built-in objects and functions any standard
<a>global object</a> has. Outside of scripts run by the vm module, <code class="language-javascript">sandbox</code> will
be unchanged.

</p>
<p>If not given a sandbox object, returns a new, empty contextified sandbox object
you can use.

</p>
<p>This function is useful for creating a sandbox that can be used to run multiple
scripts, e.g. if you were emulating a web browser it could be used to create a
single sandbox representing a window&#39;s global object, then run all <code class="language-javascript">&lt;script&gt;</code>
tags together inside that sandbox.

</p>
<!--next-->
<h2>vm.isContext(sandbox)</h2>
<p>Returns whether or not a sandbox object has been contextified by calling
<code class="language-javascript">vm.createContext</code> on it.


</p>
<!--next-->
<h2>vm.runInContext(code, contextifiedSandbox[, options])</h2>
<p><code class="language-javascript">vm.runInContext</code> compiles <code class="language-javascript">code</code>, then runs it in <code class="language-javascript">contextifiedSandbox</code> and
returns the result. Running code does not have access to local scope. The
<code class="language-javascript">contextifiedSandbox</code> object must have been previously contextified via
<code class="language-javascript">vm.createContext</code>; it will be used as the global object for <code class="language-javascript">code</code>.

</p>
<p><code class="language-javascript">vm.runInContext</code> takes the same options as <code class="language-javascript">vm.runInThisContext</code>.

</p>
<p>Example: compile and execute different scripts in a single existing context.

</p>
<pre><code class="language-javascript">var util = require(&#39;util&#39;);
var vm = require(&#39;vm&#39;);

var sandbox = { globalVar: 1 };
vm.createContext(sandbox);

for (var i = 0; i &lt; 10; ++i) {
    vm.runInContext(&#39;globalVar *= 2;&#39;, sandbox);
}
console.log(util.inspect(sandbox));

// { globalVar: 1024 }</code></pre>
<p>Note that running untrusted code is a tricky business requiring great care.
<code class="language-javascript">vm.runInContext</code> is quite useful, but safely running untrusted code requires a
separate process.


</p>
<!--next-->
<h2>vm.runInNewContext(code[, sandbox][, options])</h2>
<p><code class="language-javascript">vm.runInNewContext</code> compiles <code class="language-javascript">code</code>, contextifies <code class="language-javascript">sandbox</code> if passed or
creates a new contextified sandbox if it&#39;s omitted, and then runs the code with
the sandbox as the global object and returns the result.

</p>
<p><code class="language-javascript">vm.runInNewContext</code> takes the same options as <code class="language-javascript">vm.runInThisContext</code>.

</p>
<p>Example: compile and execute code that increments a global variable and sets a
new one. These globals are contained in the sandbox.

</p>
<pre><code class="language-javascript">var util = require(&#39;util&#39;);
var vm = require(&#39;vm&#39;),

var sandbox = {
  animal: &#39;cat&#39;,
  count: 2
};

vm.runInNewContext(&#39;count += 1; name = &quot;kitty&quot;&#39;, sandbox);
console.log(util.inspect(sandbox));

// { animal: &#39;cat&#39;, count: 3, name: &#39;kitty&#39; }</code></pre>
<p>Note that running untrusted code is a tricky business requiring great care.
<code class="language-javascript">vm.runInNewContext</code> is quite useful, but safely running untrusted code requires
a separate process.


</p>
<!--next-->
<h2>vm.runInDebugContext(code)</h2>
<p><code class="language-javascript">vm.runInDebugContext</code> compiles and executes <code class="language-javascript">code</code> inside the V8 debug context.
The primary use case is to get access to the V8 debug object:

</p>
<pre><code class="language-javascript">var Debug = vm.runInDebugContext(&#39;Debug&#39;);
Debug.scripts().forEach(function(script) { console.log(script.name); });</code></pre>
<p>Note that the debug context and object are intrinsically tied to V8&#39;s debugger
implementation and may change (or even get removed) without prior warning.

</p>
<p>The debug object can also be exposed with the <code class="language-javascript">--expose_debug_as=</code> switch.


</p>
<!--next-->
<h2>Class: Script</h2>
<p>A class for holding precompiled scripts, and running them in specific sandboxes.


</p>
<!--next-->
<h2>new vm.Script(code, options)</h2>
<p>Creating a new <code class="language-javascript">Script</code> compiles <code class="language-javascript">code</code> but does not run it. Instead, the
created <code class="language-javascript">vm.Script</code> object represents this compiled code. This script can be run
later many times using methods below. The returned script is not bound to any
global object. It is bound before each run, just for that run.

</p>
<p>The options when creating a script are:

</p>
<ul>
<li><code class="language-javascript">filename</code>: allows you to control the filename that shows up in any stack
traces produced from this script.</li>
<li><code class="language-javascript">displayErrors</code>: whether or not to print any errors to stderr, with the
line of code that caused them highlighted, before throwing an exception.
Applies only to syntax errors compiling the code; errors while running the
code are controlled by the options to the script&#39;s methods.</li>
</ul>
<!--next-->
<h2>script.runInThisContext([options])</h2>
<p>Similar to <code class="language-javascript">vm.runInThisContext</code> but a method of a precompiled <code class="language-javascript">Script</code> object.
<code class="language-javascript">script.runInThisContext</code> runs <code class="language-javascript">script</code>&#39;s compiled code and returns the result.
Running code does not have access to local scope, but does have access to the
current <code class="language-javascript">global</code> object.

</p>
<p>Example of using <code class="language-javascript">script.runInThisContext</code> to compile code once and run it
multiple times:

</p>
<pre><code class="language-javascript">var vm = require(&#39;vm&#39;);

global.globalVar = 0;

var script = new vm.Script(&#39;globalVar += 1&#39;, { filename: &#39;myfile.vm&#39; });

for (var i = 0; i &lt; 1000; ++i) {
  script.runInThisContext();
}

console.log(globalVar);

// 1000</code></pre>
<p>The options for running a script are:

</p>
<ul>
<li><code class="language-javascript">displayErrors</code>: whether or not to print any runtime errors to stderr, with
the line of code that caused them highlighted, before throwing an exception.
Applies only to runtime errors executing the code; it is impossible to create
a <code class="language-javascript">Script</code> instance with syntax errors, as the constructor will throw.</li>
<li><code class="language-javascript">timeout</code>: a number of milliseconds to execute the script before terminating
execution. If execution is terminated, an <code class="language-javascript">Error</code> will be thrown.</li>
</ul>
<!--next-->
<h2>script.runInContext(contextifiedSandbox[, options])</h2>
<p>Similar to <code class="language-javascript">vm.runInContext</code> but a method of a precompiled <code class="language-javascript">Script</code> object.
<code class="language-javascript">script.runInContext</code> runs <code class="language-javascript">script</code>&#39;s compiled code in <code class="language-javascript">contextifiedSandbox</code>
and returns the result. Running code does not have access to local scope.

</p>
<p><code class="language-javascript">script.runInContext</code> takes the same options as <code class="language-javascript">script.runInThisContext</code>.

</p>
<p>Example: compile code that increments a global variable and sets one, then
execute the code multiple times. These globals are contained in the sandbox.

</p>
<pre><code class="language-javascript">var util = require(&#39;util&#39;);
var vm = require(&#39;vm&#39;);

var sandbox = {
  animal: &#39;cat&#39;,
  count: 2
};

var script = new vm.Script(&#39;count += 1; name = &quot;kitty&quot;&#39;);

for (var i = 0; i &lt; 10; ++i) {
  script.runInContext(sandbox);
}

console.log(util.inspect(sandbox));

// { animal: &#39;cat&#39;, count: 12, name: &#39;kitty&#39; }</code></pre>
<p>Note that running untrusted code is a tricky business requiring great care.
<code class="language-javascript">script.runInContext</code> is quite useful, but safely running untrusted code
requires a separate process.


</p>
<!--next-->
<h2>script.runInNewContext([sandbox][, options])</h2>
<p>Similar to <code class="language-javascript">vm.runInNewContext</code> but a method of a precompiled <code class="language-javascript">Script</code> object.
<code class="language-javascript">script.runInNewContext</code> contextifies <code class="language-javascript">sandbox</code> if passed or creates a new
contextified sandbox if it&#39;s omitted, and then runs <code class="language-javascript">script</code>&#39;s compiled code
with the sandbox as the global object and returns the result. Running code does
not have access to local scope.

</p>
<p><code class="language-javascript">script.runInNewContext</code> takes the same options as <code class="language-javascript">script.runInThisContext</code>.

</p>
<p>Example: compile code that sets a global variable, then execute the code
multiple times in different contexts. These globals are set on and contained in
the sandboxes.

</p>
<pre><code class="language-javascript">var util = require(&#39;util&#39;);
var vm = require(&#39;vm&#39;);

var sandboxes = [{}, {}, {}];

var script = new vm.Script(&#39;globalVar = &quot;set&quot;&#39;);

sandboxes.forEach(function (sandbox) {
  script.runInNewContext(sandbox);
});

console.log(util.inspect(sandboxes));

// [{ globalVar: &#39;set&#39; }, { globalVar: &#39;set&#39; }, { globalVar: &#39;set&#39; }]</code></pre>
<p>Note that running untrusted code is a tricky business requiring great care.
<code class="language-javascript">script.runInNewContext</code> is quite useful, but safely running untrusted code
requires a separate process.

</p>
<!--next-->
<h2>Child Process</h2>
<pre class="stability">Stability: 3 - Stable</pre><p>Node provides a tri-directional <code class="language-javascript">popen(3)</code> facility through the
<code class="language-javascript">child_process</code> module.

</p>
<p>It is possible to stream data through a child&#39;s <code class="language-javascript">stdin</code>, <code class="language-javascript">stdout</code>, and
<code class="language-javascript">stderr</code> in a fully non-blocking way.  (Note that some programs use
line-buffered I/O internally.  That doesn&#39;t affect node.js but it means
data you send to the child process may not be immediately consumed.)

</p>
<p>To create a child process use <code class="language-javascript">require(&#39;child_process&#39;).spawn()</code> or
<code class="language-javascript">require(&#39;child_process&#39;).fork()</code>.  The semantics of each are slightly
different, and explained <a>below</a>.

</p>
<p>For scripting purposes you may find the
<a>synchronous counterparts</a> more
convenient.

</p>
<!--next-->
<h2>Class: ChildProcess</h2>
<p><code class="language-javascript">ChildProcess</code> is an <a>EventEmitter</a>.

</p>
<p>Child processes always have three streams associated with them. <code class="language-javascript">child.stdin</code>,
<code class="language-javascript">child.stdout</code>, and <code class="language-javascript">child.stderr</code>.  These may be shared with the stdio
streams of the parent process, or they may be separate stream objects
which can be piped to and from.

</p>
<p>The ChildProcess class is not intended to be used directly.  Use the
<code class="language-javascript">spawn()</code>, <code class="language-javascript">exec()</code>, <code class="language-javascript">execFile()</code>, or <code class="language-javascript">fork()</code> methods to create a Child
Process instance.

</p>
<!--next-->
<h2>Event:  &#39;error&#39;</h2>
<div class="signature"><ul>
<li><code class="language-javascript">err</code> <span class="type">Error Object</span> the error.</li>
</div></ul>
<p>Emitted when:

</p>
<ol>
<li>The process could not be spawned, or</li>
<li>The process could not be killed, or</li>
<li>Sending a message to the child process failed for whatever reason.</li>
</ol>
<p>Note that the <code class="language-javascript">exit</code>-event may or may not fire after an error has occurred. If
you are listening on both events to fire a function, remember to guard against
calling your function twice.

</p>
<p>See also <a><code class="language-javascript">ChildProcess#kill()</code></a> and
<a><code class="language-javascript">ChildProcess#send()</code></a>.

</p>
<!--next-->
<h2>Event:  &#39;exit&#39;</h2>
<div class="signature"><ul>
<li><code class="language-javascript">code</code> <span class="type">Number</span> the exit code, if it exited normally.</li>
<li><code class="language-javascript">signal</code> <span class="type">String</span> the signal passed to kill the child process, if it
was killed by the parent.</li>
</div></ul>
<p>This event is emitted after the child process ends. If the process terminated
normally, <code class="language-javascript">code</code> is the final exit code of the process, otherwise <code class="language-javascript">null</code>. If
the process terminated due to receipt of a signal, <code class="language-javascript">signal</code> is the string name
of the signal, otherwise <code class="language-javascript">null</code>.

</p>
<p>Note that the child process stdio streams might still be open.

</p>
<p>Also, note that node establishes signal handlers for <code class="language-javascript">&#39;SIGINT&#39;</code> and <code class="language-javascript">&#39;SIGTERM</code>&#39;,
so it will not terminate due to receipt of those signals, it will exit.

</p>
<p>See <code class="language-javascript">waitpid(2)</code>.

</p>
<!--next-->
<h2>Event: &#39;close&#39;</h2>
<div class="signature"><ul>
<li><code class="language-javascript">code</code> <span class="type">Number</span> the exit code, if it exited normally.</li>
<li><code class="language-javascript">signal</code> <span class="type">String</span> the signal passed to kill the child process, if it
was killed by the parent.</li>
</div></ul>
<p>This event is emitted when the stdio streams of a child process have all
terminated.  This is distinct from &#39;exit&#39;, since multiple processes
might share the same stdio streams.

</p>
<!--next-->
<h2>Event: &#39;disconnect&#39;</h2>
<p>This event is emitted after calling the <code class="language-javascript">.disconnect()</code> method in the parent
or in the child. After disconnecting it is no longer possible to send messages,
and the <code class="language-javascript">.connected</code> property is false.

</p>
<!--next-->
<h2>Event: &#39;message&#39;</h2>
<div class="signature"><ul>
<li><code class="language-javascript">message</code> <span class="type">Object</span> a parsed JSON object or primitive value</li>
<li><code class="language-javascript">sendHandle</code> <span class="type">Handle object</span> a Socket or Server object</li>
</div></ul>
<p>Messages send by <code class="language-javascript">.send(message, [sendHandle])</code> are obtained using the
<code class="language-javascript">message</code> event.

</p>
<!--next-->
<h2>child.stdin</h2>
<div class="signature"><ul>
<li><span class="type">Stream object</span></li>
</div></ul>
<p>A <code class="language-javascript">Writable Stream</code> that represents the child process&#39;s <code class="language-javascript">stdin</code>.
If the child is waiting to read all its input, it will not continue until this
stream has been closed via <code class="language-javascript">end()</code>.

</p>
<p>If the child was not spawned with <code class="language-javascript">stdio[0]</code> set to <code class="language-javascript">&#39;pipe&#39;</code>, then this will
not be set.

</p>
<p><code class="language-javascript">child.stdin</code> is shorthand for <code class="language-javascript">child.stdio[0]</code>. Both properties will refer
to the same object, or null.

</p>
<!--next-->
<h2>child.stdout</h2>
<div class="signature"><ul>
<li><span class="type">Stream object</span></li>
</div></ul>
<p>A <code class="language-javascript">Readable Stream</code> that represents the child process&#39;s <code class="language-javascript">stdout</code>.

</p>
<p>If the child was not spawned with <code class="language-javascript">stdio[1]</code> set to <code class="language-javascript">&#39;pipe&#39;</code>, then this will
not be set.

</p>
<p><code class="language-javascript">child.stdout</code> is shorthand for <code class="language-javascript">child.stdio[1]</code>. Both properties will refer
to the same object, or null.

</p>
<!--next-->
<h2>child.stderr</h2>
<div class="signature"><ul>
<li><span class="type">Stream object</span></li>
</div></ul>
<p>A <code class="language-javascript">Readable Stream</code> that represents the child process&#39;s <code class="language-javascript">stderr</code>.

</p>
<p>If the child was not spawned with <code class="language-javascript">stdio[2]</code> set to <code class="language-javascript">&#39;pipe&#39;</code>, then this will
not be set.

</p>
<p><code class="language-javascript">child.stderr</code> is shorthand for <code class="language-javascript">child.stdio[2]</code>. Both properties will refer
to the same object, or null.

</p>
<!--next-->
<h2>child.stdio</h2>
<div class="signature"><ul>
<li><span class="type">Array</span></li>
</div></ul>
<p>A sparse array of pipes to the child process, corresponding with positions in
the <a>stdio</a> option to
<a>spawn</a> that have been
set to <code class="language-javascript">&#39;pipe&#39;</code>.
Note that streams 0-2 are also available as ChildProcess.stdin,
ChildProcess.stdout, and ChildProcess.stderr, respectively.

</p>
<p>In the following example, only the child&#39;s fd <code class="language-javascript">1</code> is setup as a pipe, so only
the parent&#39;s <code class="language-javascript">child.stdio[1]</code> is a stream, all other values in the array are
<code class="language-javascript">null</code>.

</p>
<pre><code class="language-javascript">child = child_process.spawn(&quot;ls&quot;, {
    stdio: [
      0, // use parents stdin for child
      &#39;pipe&#39;, // pipe child&#39;s stdout to parent
      fs.openSync(&quot;err.out&quot;, &quot;w&quot;) // direct child&#39;s stderr to a file
    ]
});

assert.equal(child.stdio[0], null);
assert.equal(child.stdio[0], child.stdin);

assert(child.stdout);
assert.equal(child.stdio[1], child.stdout);

assert.equal(child.stdio[2], null);
assert.equal(child.stdio[2], child.stderr);</code></pre>
<!--next-->
<h2>child.pid</h2>
<div class="signature"><ul>
<li><span class="type">Integer</span></li>
</div></ul>
<p>The PID of the child process.

</p>
<p>Example:

</p>
<pre><code class="language-javascript">var spawn = require(&#39;child_process&#39;).spawn,
    grep  = spawn(&#39;grep&#39;, [&#39;ssh&#39;]);

console.log(&#39;Spawned child pid: &#39; + grep.pid);
grep.stdin.end();</code></pre>
<!--next-->
<h2>child.connected</h2>
<div class="signature"><ul>
<li><span class="type">Boolean</span> Set to false after `.disconnect&#39; is called</li>
</div></ul>
<p>If <code class="language-javascript">.connected</code> is false, it is no longer possible to send messages.

</p>
<!--next-->
<h2>child.kill([signal])</h2>
<div class="signature"><ul>
<li><code class="language-javascript">signal</code> <span class="type">String</span></li>
</div></ul>
<p>Send a signal to the child process. If no argument is given, the process will
be sent <code class="language-javascript">&#39;SIGTERM&#39;</code>. See <code class="language-javascript">signal(7)</code> for a list of available signals.

</p>
<pre><code class="language-javascript">var spawn = require(&#39;child_process&#39;).spawn,
    grep  = spawn(&#39;grep&#39;, [&#39;ssh&#39;]);

grep.on(&#39;close&#39;, function (code, signal) {
  console.log(&#39;child process terminated due to receipt of signal &#39;+signal);
});

// send SIGHUP to process
grep.kill(&#39;SIGHUP&#39;);</code></pre>
<p>May emit an <code class="language-javascript">&#39;error&#39;</code> event when the signal cannot be delivered. Sending a
signal to a child process that has already exited is not an error but may
have unforeseen consequences: if the PID (the process ID) has been reassigned
to another process, the signal will be delivered to that process instead.
What happens next is anyone&#39;s guess.

</p>
<p>Note that while the function is called <code class="language-javascript">kill</code>, the signal delivered to the
child process may not actually kill it.  <code class="language-javascript">kill</code> really just sends a signal
to a process.

</p>
<p>See <code class="language-javascript">kill(2)</code>

</p>
<!--next-->
<h2>child.send(message[, sendHandle])</h2>
<div class="signature"><ul>
<li><code class="language-javascript">message</code> <span class="type">Object</span></li>
<li><code class="language-javascript">sendHandle</code> <span class="type">Handle object</span></li>
</div></ul>
<p>When using <code class="language-javascript">child_process.fork()</code> you can write to the child using
<code class="language-javascript">child.send(message, [sendHandle])</code> and messages are received by
a <code class="language-javascript">&#39;message&#39;</code> event on the child.

</p>
<p>For example:

</p>
<pre><code class="language-javascript">var cp = require(&#39;child_process&#39;);

var n = cp.fork(__dirname + &#39;/sub.js&#39;);

n.on(&#39;message&#39;, function(m) {
  console.log(&#39;PARENT got message:&#39;, m);
});

n.send({ hello: &#39;world&#39; });</code></pre>
<p>And then the child script, <code class="language-javascript">&#39;sub.js&#39;</code> might look like this:

</p>
<pre><code class="language-javascript">process.on(&#39;message&#39;, function(m) {
  console.log(&#39;CHILD got message:&#39;, m);
});

process.send({ foo: &#39;bar&#39; });</code></pre>
<p>In the child the <code class="language-javascript">process</code> object will have a <code class="language-javascript">send()</code> method, and <code class="language-javascript">process</code>
will emit objects each time it receives a message on its channel.

</p>
<p>Please note that the <code class="language-javascript">send()</code> method on both the parent and child are
synchronous - sending large chunks of data is not advised (pipes can be used
instead, see
<a><code class="language-javascript">child_process.spawn</code></a>).

</p>
<p>There is a special case when sending a <code class="language-javascript">{cmd: &#39;NODE_foo&#39;}</code> message. All messages
containing a <code class="language-javascript">NODE_</code> prefix in its <code class="language-javascript">cmd</code> property will not be emitted in
the <code class="language-javascript">message</code> event, since they are internal messages used by node core.
Messages containing the prefix are emitted in the <code class="language-javascript">internalMessage</code> event, you
should by all means avoid using this feature, it is subject to change without notice.

</p>
<p>The <code class="language-javascript">sendHandle</code> option to <code class="language-javascript">child.send()</code> is for sending a TCP server or
socket object to another process. The child will receive the object as its
second argument to the <code class="language-javascript">message</code> event.

</p>
<p>Emits an <code class="language-javascript">&#39;error&#39;</code> event if the message cannot be sent, for example because
the child process has already exited.

</p>
<h4>Example: sending server object</h4>
<p>Here is an example of sending a server:

</p>
<pre><code class="language-javascript">var child = require(&#39;child_process&#39;).fork(&#39;child.js&#39;);

// Open up the server object and send the handle.
var server = require(&#39;net&#39;).createServer();
server.on(&#39;connection&#39;, function (socket) {
  socket.end(&#39;handled by parent&#39;);
});
server.listen(1337, function() {
  child.send(&#39;server&#39;, server);
});</code></pre>
<p>And the child would the receive the server object as:

</p>
<pre><code class="language-javascript">process.on(&#39;message&#39;, function(m, server) {
  if (m === &#39;server&#39;) {
    server.on(&#39;connection&#39;, function (socket) {
      socket.end(&#39;handled by child&#39;);
    });
  }
});</code></pre>
<p>Note that the server is now shared between the parent and child, this means
that some connections will be handled by the parent and some by the child.

</p>
<p>For <code class="language-javascript">dgram</code> servers the workflow is exactly the same.  Here you listen on
a <code class="language-javascript">message</code> event instead of <code class="language-javascript">connection</code> and use <code class="language-javascript">server.bind</code> instead of
<code class="language-javascript">server.listen</code>.  (Currently only supported on UNIX platforms.)

</p>
<h4>Example: sending socket object</h4>
<p>Here is an example of sending a socket. It will spawn two children and handle
connections with the remote address <code class="language-javascript">74.125.127.100</code> as VIP by sending the
socket to a &quot;special&quot; child process. Other sockets will go to a &quot;normal&quot; process.

</p>
<pre><code class="language-javascript">var normal = require(&#39;child_process&#39;).fork(&#39;child.js&#39;, [&#39;normal&#39;]);
var special = require(&#39;child_process&#39;).fork(&#39;child.js&#39;, [&#39;special&#39;]);

// Open up the server and send sockets to child
var server = require(&#39;net&#39;).createServer();
server.on(&#39;connection&#39;, function (socket) {

  // if this is a VIP
  if (socket.remoteAddress === &#39;74.125.127.100&#39;) {
    special.send(&#39;socket&#39;, socket);
    return;
  }
  // just the usual dudes
  normal.send(&#39;socket&#39;, socket);
});
server.listen(1337);</code></pre>
<p>The <code class="language-javascript">child.js</code> could look like this:

</p>
<pre><code class="language-javascript">process.on(&#39;message&#39;, function(m, socket) {
  if (m === &#39;socket&#39;) {
    socket.end(&#39;You were handled as a &#39; + process.argv[2] + &#39; person&#39;);
  }
});</code></pre>
<p>Note that once a single socket has been sent to a child the parent can no
longer keep track of when the socket is destroyed. To indicate this condition
the <code class="language-javascript">.connections</code> property becomes <code class="language-javascript">null</code>.
It is also recommended not to use <code class="language-javascript">.maxConnections</code> in this condition.

</p>
<!--next-->
<h2>child.disconnect()</h2>
<p>Close the IPC channel between parent and child, allowing the child to exit
gracefully once there are no other connections keeping it alive. After calling
this method the <code class="language-javascript">.connected</code> flag will be set to <code class="language-javascript">false</code> in both the parent and
child, and it is no longer possible to send messages.

</p>
<p>The &#39;disconnect&#39; event will be emitted when there are no messages in the process
of being received, most likely immediately.

</p>
<p>Note that you can also call <code class="language-javascript">process.disconnect()</code> in the child process when the
child process has any open IPC channels with the parent (i.e <code class="language-javascript">fork()</code>).

</p>
<!--next-->
<h2>Asynchronous Process Creation</h2>
<p>These methods follow the common async programming patterns (accepting a
callback or returning an EventEmitter).

</p>
<!--next-->
<h2>child_process.spawn(command[, args][, options])</h2>
<div class="signature"><ul>
<li><code class="language-javascript">command</code> <span class="type">String</span> The command to run</li>
<li><code class="language-javascript">args</code> <span class="type">Array</span> List of string arguments</li>
<li><code class="language-javascript">options</code> <span class="type">Object</span><ul>
<li><code class="language-javascript">cwd</code> <span class="type">String</span> Current working directory of the child process</li>
<li><code class="language-javascript">env</code> <span class="type">Object</span> Environment key-value pairs</li>
<li><code class="language-javascript">stdio</code> <span class="type">Array|String</span> Child&#39;s stdio configuration. (See
<a>below</a>)</li>
<li><code class="language-javascript">customFds</code> <span class="type">Array</span> <strong>Deprecated</strong> File descriptors for the child to use
for stdio.  (See <a>below</a>)</li>
<li><code class="language-javascript">detached</code> <span class="type">Boolean</span> The child will be a process group leader.  (See
<a>below</a>)</li>
<li><code class="language-javascript">uid</code> <span class="type">Number</span> Sets the user identity of the process. (See setuid(2).)</li>
<li><code class="language-javascript">gid</code> <span class="type">Number</span> Sets the group identity of the process. (See setgid(2).)</li>
</ul>
</li>
<li>return: <span class="type">ChildProcess object</span></li>
</div></ul>
<p>Launches a new process with the given <code class="language-javascript">command</code>, with  command line arguments in <code class="language-javascript">args</code>.
If omitted, <code class="language-javascript">args</code> defaults to an empty Array.

</p>
<p>The third argument is used to specify additional options, with these defaults:

</p>
<pre><code class="language-javascript">{ cwd: undefined,
  env: process.env
}</code></pre>
<p>Use <code class="language-javascript">cwd</code> to specify the working directory from which the process is spawned.
If not given, the default is to inherit the current working directory.

</p>
<p>Use <code class="language-javascript">env</code> to specify environment variables that will be visible to the new
process, the default is <code class="language-javascript">process.env</code>.

</p>
<p>Example of running <code class="language-javascript">ls -lh /usr</code>, capturing <code class="language-javascript">stdout</code>, <code class="language-javascript">stderr</code>, and the exit code:

</p>
<pre><code class="language-javascript">var spawn = require(&#39;child_process&#39;).spawn,
    ls    = spawn(&#39;ls&#39;, [&#39;-lh&#39;, &#39;/usr&#39;]);

ls.stdout.on(&#39;data&#39;, function (data) {
  console.log(&#39;stdout: &#39; + data);
});

ls.stderr.on(&#39;data&#39;, function (data) {
  console.log(&#39;stderr: &#39; + data);
});

ls.on(&#39;close&#39;, function (code) {
  console.log(&#39;child process exited with code &#39; + code);
});</code></pre>
<p>Example: A very elaborate way to run &#39;ps ax | grep ssh&#39;

</p>
<pre><code class="language-javascript">var spawn = require(&#39;child_process&#39;).spawn,
    ps    = spawn(&#39;ps&#39;, [&#39;ax&#39;]),
    grep  = spawn(&#39;grep&#39;, [&#39;ssh&#39;]);

ps.stdout.on(&#39;data&#39;, function (data) {
  grep.stdin.write(data);
});

ps.stderr.on(&#39;data&#39;, function (data) {
  console.log(&#39;ps stderr: &#39; + data);
});

ps.on(&#39;close&#39;, function (code) {
  if (code !== 0) {
    console.log(&#39;ps process exited with code &#39; + code);
  }
  grep.stdin.end();
});

grep.stdout.on(&#39;data&#39;, function (data) {
  console.log(&#39;&#39; + data);
});

grep.stderr.on(&#39;data&#39;, function (data) {
  console.log(&#39;grep stderr: &#39; + data);
});

grep.on(&#39;close&#39;, function (code) {
  if (code !== 0) {
    console.log(&#39;grep process exited with code &#39; + code);
  }
});</code></pre>
<!--next-->
<h2>options.stdio</h2>
<p>As a shorthand, the <code class="language-javascript">stdio</code> argument may also be one of the following
strings:

</p>
<ul>
<li><code class="language-javascript">&#39;pipe&#39;</code> - <code class="language-javascript">[&#39;pipe&#39;, &#39;pipe&#39;, &#39;pipe&#39;]</code>, this is the default value</li>
<li><code class="language-javascript">&#39;ignore&#39;</code> - <code class="language-javascript">[&#39;ignore&#39;, &#39;ignore&#39;, &#39;ignore&#39;]</code></li>
<li><code class="language-javascript">&#39;inherit&#39;</code> - <code class="language-javascript">[process.stdin, process.stdout, process.stderr]</code> or <code class="language-javascript">[0,1,2]</code></li>
</ul>
<p>Otherwise, the &#39;stdio&#39; option to <code class="language-javascript">child_process.spawn()</code> is an array where each
index corresponds to a fd in the child.  The value is one of the following:

</p>
<ol>
<li><code class="language-javascript">&#39;pipe&#39;</code> - Create a pipe between the child process and the parent process.
The parent end of the pipe is exposed to the parent as a property on the
<code class="language-javascript">child_process</code> object as <code class="language-javascript">ChildProcess.stdio[fd]</code>. Pipes created for
fds 0 - 2 are also available as ChildProcess.stdin, ChildProcess.stdout
and ChildProcess.stderr, respectively.</li>
<li><code class="language-javascript">&#39;ipc&#39;</code> - Create an IPC channel for passing messages/file descriptors
between parent and child. A ChildProcess may have at most <em>one</em> IPC stdio
file descriptor. Setting this option enables the ChildProcess.send() method.
If the child writes JSON messages to this file descriptor, then this will
trigger ChildProcess.on(&#39;message&#39;).  If the child is a Node.js program, then
the presence of an IPC channel will enable process.send() and
process.on(&#39;message&#39;).</li>
<li><code class="language-javascript">&#39;ignore&#39;</code> - Do not set this file descriptor in the child. Note that Node
will always open fd 0 - 2 for the processes it spawns. When any of these is
ignored node will open <code class="language-javascript">/dev/null</code> and attach it to the child&#39;s fd.</li>
<li><code class="language-javascript">Stream</code> object - Share a readable or writable stream that refers to a tty,
file, socket, or a pipe with the child process. The stream&#39;s underlying
file descriptor is duplicated in the child process to the fd that
corresponds to the index in the <code class="language-javascript">stdio</code> array. Note that the stream must
have an underlying descriptor (file streams do not until the <code class="language-javascript">&#39;open&#39;</code>
event has occurred).</li>
<li>Positive integer - The integer value is interpreted as a file descriptor
that is is currently open in the parent process. It is shared with the child
process, similar to how <code class="language-javascript">Stream</code> objects can be shared.</li>
<li><code class="language-javascript">null</code>, <code class="language-javascript">undefined</code> - Use default value. For stdio fds 0, 1 and 2 (in other
words, stdin, stdout, and stderr) a pipe is created. For fd 3 and up, the
default is <code class="language-javascript">&#39;ignore&#39;</code>.</li>
</ol>
<p>Example:

</p>
<pre><code class="language-javascript">var spawn = require(&#39;child_process&#39;).spawn;

// Child will use parent&#39;s stdios
spawn(&#39;prg&#39;, [], { stdio: &#39;inherit&#39; });

// Spawn child sharing only stderr
spawn(&#39;prg&#39;, [], { stdio: [&#39;pipe&#39;, &#39;pipe&#39;, process.stderr] });

// Open an extra fd=4, to interact with programs present a
// startd-style interface.
spawn(&#39;prg&#39;, [], { stdio: [&#39;pipe&#39;, null, null, null, &#39;pipe&#39;] });</code></pre>
<!--next-->
<h2>options.detached</h2>
<p>If the <code class="language-javascript">detached</code> option is set, the child process will be made the leader of a
new process group.  This makes it possible for the child to continue running
after the parent exits.

</p>
<p>By default, the parent will wait for the detached child to exit.  To prevent
the parent from waiting for a given <code class="language-javascript">child</code>, use the <code class="language-javascript">child.unref()</code> method,
and the parent&#39;s event loop will not include the child in its reference count.

</p>
<p>Example of detaching a long-running process and redirecting its output to a
file:

</p>
<pre><code class="language-javascript"> var fs = require(&#39;fs&#39;),
     spawn = require(&#39;child_process&#39;).spawn,
     out = fs.openSync(&#39;./out.log&#39;, &#39;a&#39;),
     err = fs.openSync(&#39;./out.log&#39;, &#39;a&#39;);

 var child = spawn(&#39;prg&#39;, [], {
   detached: true,
   stdio: [ &#39;ignore&#39;, out, err ]
 });

 child.unref();</code></pre>
<p>When using the <code class="language-javascript">detached</code> option to start a long-running process, the process
will not stay running in the background unless it is provided with a <code class="language-javascript">stdio</code>
configuration that is not connected to the parent.  If the parent&#39;s <code class="language-javascript">stdio</code> is
inherited, the child will remain attached to the controlling terminal.

</p>
<!--next-->
<h2>options.customFds</h2>
<p>There is a deprecated option called <code class="language-javascript">customFds</code> which allows one to specify
specific file descriptors for the stdio of the child process. This API was
not portable to all platforms and therefore removed.
With <code class="language-javascript">customFds</code> it was possible to hook up the new process&#39; <code class="language-javascript">[stdin, stdout,
stderr]</code> to existing streams; <code class="language-javascript">-1</code> meant that a new stream should be created.
Use at your own risk.

</p>
<p>See also: <code class="language-javascript">child_process.exec()</code> and <code class="language-javascript">child_process.fork()</code>

</p>
<!--next-->
<h2>child_process.exec(command[, options], callback)</h2>
<div class="signature"><ul>
<li><code class="language-javascript">command</code> <span class="type">String</span> The command to run, with space-separated arguments</li>
<li><code class="language-javascript">options</code> <span class="type">Object</span><ul>
<li><code class="language-javascript">cwd</code> <span class="type">String</span> Current working directory of the child process</li>
<li><code class="language-javascript">env</code> <span class="type">Object</span> Environment key-value pairs</li>
<li><code class="language-javascript">encoding</code> <span class="type">String</span> (Default: &#39;utf8&#39;)</li>
<li><code class="language-javascript">shell</code> <span class="type">String</span> Shell to execute the command with
(Default: &#39;/bin/sh&#39; on UNIX, &#39;cmd.exe&#39; on Windows,  The shell should
 understand the <code class="language-javascript">-c</code> switch on UNIX or <code class="language-javascript">/s /c</code> on Windows. On Windows,
 command line parsing should be compatible with <code class="language-javascript">cmd.exe</code>.)</li>
<li><code class="language-javascript">timeout</code> <span class="type">Number</span> (Default: 0)</li>
<li><code class="language-javascript">maxBuffer</code> <span class="type">Number</span> (Default: <code class="language-javascript">200*1024</code>)</li>
<li><code class="language-javascript">killSignal</code> <span class="type">String</span> (Default: &#39;SIGTERM&#39;)</li>
<li><code class="language-javascript">uid</code> <span class="type">Number</span> Sets the user identity of the process. (See setuid(2).)</li>
<li><code class="language-javascript">gid</code> <span class="type">Number</span> Sets the group identity of the process. (See setgid(2).)</li>
</ul>
</li>
<li><code class="language-javascript">callback</code> <span class="type">Function</span> called with the output when process terminates<ul>
<li><code class="language-javascript">error</code> <span class="type">Error</span></li>
<li><code class="language-javascript">stdout</code> <span class="type">Buffer</span></li>
<li><code class="language-javascript">stderr</code> <span class="type">Buffer</span></li>
</ul>
</li>
<li>Return: ChildProcess object</li>
</div></ul>
<p>Runs a command in a shell and buffers the output.

</p>
<pre><code class="language-javascript">var exec = require(&#39;child_process&#39;).exec,
    child;

child = exec(&#39;cat *.js bad_file | wc -l&#39;,
  function (error, stdout, stderr) {
    console.log(&#39;stdout: &#39; + stdout);
    console.log(&#39;stderr: &#39; + stderr);
    if (error !== null) {
      console.log(&#39;exec error: &#39; + error);
    }
});</code></pre>
<p>The callback gets the arguments <code class="language-javascript">(error, stdout, stderr)</code>. On success, <code class="language-javascript">error</code>
will be <code class="language-javascript">null</code>.  On error, <code class="language-javascript">error</code> will be an instance of <code class="language-javascript">Error</code> and <code class="language-javascript">error.code</code>
will be the exit code of the child process, and <code class="language-javascript">error.signal</code> will be set to the
signal that terminated the process.

</p>
<p>There is a second optional argument to specify several options. The
default options are

</p>
<pre><code class="language-javascript">{ encoding: &#39;utf8&#39;,
  timeout: 0,
  maxBuffer: 200*1024,
  killSignal: &#39;SIGTERM&#39;,
  cwd: null,
  env: null }</code></pre>
<p>If <code class="language-javascript">timeout</code> is greater than 0, then it will kill the child process
if it runs longer than <code class="language-javascript">timeout</code> milliseconds. The child process is killed with
<code class="language-javascript">killSignal</code> (default: <code class="language-javascript">&#39;SIGTERM&#39;</code>). <code class="language-javascript">maxBuffer</code> specifies the largest
amount of data allowed on stdout or stderr - if this value is exceeded then
the child process is killed.


</p>
<!--next-->
<h2>child_process.execFile(file[, args][, options][, callback])</h2>
<div class="signature"><ul>
<li><code class="language-javascript">file</code> <span class="type">String</span> The filename of the program to run</li>
<li><code class="language-javascript">args</code> <span class="type">Array</span> List of string arguments</li>
<li><code class="language-javascript">options</code> <span class="type">Object</span><ul>
<li><code class="language-javascript">cwd</code> <span class="type">String</span> Current working directory of the child process</li>
<li><code class="language-javascript">env</code> <span class="type">Object</span> Environment key-value pairs</li>
<li><code class="language-javascript">encoding</code> <span class="type">String</span> (Default: &#39;utf8&#39;)</li>
<li><code class="language-javascript">timeout</code> <span class="type">Number</span> (Default: 0)</li>
<li><code class="language-javascript">maxBuffer</code> <span class="type">Number</span> (Default: 200*1024)</li>
<li><code class="language-javascript">killSignal</code> <span class="type">String</span> (Default: &#39;SIGTERM&#39;)</li>
<li><code class="language-javascript">uid</code> <span class="type">Number</span> Sets the user identity of the process. (See setuid(2).)</li>
<li><code class="language-javascript">gid</code> <span class="type">Number</span> Sets the group identity of the process. (See setgid(2).)</li>
</ul>
</li>
<li><code class="language-javascript">callback</code> <span class="type">Function</span> called with the output when process terminates<ul>
<li><code class="language-javascript">error</code> <span class="type">Error</span></li>
<li><code class="language-javascript">stdout</code> <span class="type">Buffer</span></li>
<li><code class="language-javascript">stderr</code> <span class="type">Buffer</span></li>
</ul>
</li>
<li>Return: ChildProcess object</li>
</div></ul>
<p>This is similar to <code class="language-javascript">child_process.exec()</code> except it does not execute a
subshell but rather the specified file directly. This makes it slightly
leaner than <code class="language-javascript">child_process.exec</code>. It has the same options.


</p>
<!--next-->
<h2>child_process.fork(modulePath[, args][, options])</h2>
<div class="signature"><ul>
<li><code class="language-javascript">modulePath</code> <span class="type">String</span> The module to run in the child</li>
<li><code class="language-javascript">args</code> <span class="type">Array</span> List of string arguments</li>
<li><code class="language-javascript">options</code> <span class="type">Object</span><ul>
<li><code class="language-javascript">cwd</code> <span class="type">String</span> Current working directory of the child process</li>
<li><code class="language-javascript">env</code> <span class="type">Object</span> Environment key-value pairs</li>
<li><code class="language-javascript">execPath</code> <span class="type">String</span> Executable used to create the child process</li>
<li><code class="language-javascript">execArgv</code> <span class="type">Array</span> List of string arguments passed to the executable
(Default: <code class="language-javascript">process.execArgv</code>)</li>
<li><code class="language-javascript">silent</code> <span class="type">Boolean</span> If true, stdin, stdout, and stderr of the child will be
piped to the parent, otherwise they will be inherited from the parent, see
the &quot;pipe&quot; and &quot;inherit&quot; options for <code class="language-javascript">spawn()</code>&#39;s <code class="language-javascript">stdio</code> for more details
(default is false)</li>
<li><code class="language-javascript">uid</code> <span class="type">Number</span> Sets the user identity of the process. (See setuid(2).)</li>
<li><code class="language-javascript">gid</code> <span class="type">Number</span> Sets the group identity of the process. (See setgid(2).)</li>
</ul>
</li>
<li>Return: ChildProcess object</li>
</div></ul>
<p>This is a special case of the <code class="language-javascript">spawn()</code> functionality for spawning Node
processes. In addition to having all the methods in a normal ChildProcess
instance, the returned object has a communication channel built-in. See
<code class="language-javascript">child.send(message, [sendHandle])</code> for details.

</p>
<p>These child Nodes are still whole new instances of V8. Assume at least 30ms
startup and 10mb memory for each new Node. That is, you cannot create many
thousands of them.

</p>
<p>The <code class="language-javascript">execPath</code> property in the <code class="language-javascript">options</code> object allows for a process to be
created for the child rather than the current <code class="language-javascript">node</code> executable. This should be
done with care and by default will talk over the fd represented an
environmental variable <code class="language-javascript">NODE_CHANNEL_FD</code> on the child process. The input and
output on this fd is expected to be line delimited JSON objects.

</p>
<!--next-->
<h2>Synchronous Process Creation</h2>
<p>These methods are <strong>synchronous</strong>, meaning they <strong>WILL</strong> block the event loop,
pausing execution of your code until the spawned process exits.

</p>
<p>Blocking calls like these are mostly useful for simplifying general purpose
scripting tasks and for simplifying the loading/processing of application
configuration at startup.

</p>
<!--next-->
<h2>child_process.spawnSync(command[, args][, options])</h2>
<div class="signature"><ul>
<li><code class="language-javascript">command</code> <span class="type">String</span> The command to run</li>
<li><code class="language-javascript">args</code> <span class="type">Array</span> List of string arguments</li>
<li><code class="language-javascript">options</code> <span class="type">Object</span><ul>
<li><code class="language-javascript">cwd</code> <span class="type">String</span> Current working directory of the child process</li>
<li><code class="language-javascript">input</code> <span class="type">String|Buffer</span> The value which will be passed as stdin to the spawned process<ul>
<li>supplying this value will override <code class="language-javascript">stdio[0]</code></li>
</ul>
</li>
<li><code class="language-javascript">stdio</code> <span class="type">Array</span> Child&#39;s stdio configuration.</li>
<li><code class="language-javascript">env</code> <span class="type">Object</span> Environment key-value pairs</li>
<li><code class="language-javascript">uid</code> <span class="type">Number</span> Sets the user identity of the process. (See setuid(2).)</li>
<li><code class="language-javascript">gid</code> <span class="type">Number</span> Sets the group identity of the process. (See setgid(2).)</li>
<li><code class="language-javascript">timeout</code> <span class="type">Number</span> In milliseconds the maximum amount of time the process is allowed to run. (Default: undefined)</li>
<li><code class="language-javascript">killSignal</code> <span class="type">String</span> The signal value to be used when the spawned process will be killed. (Default: &#39;SIGTERM&#39;)</li>
<li><code class="language-javascript">maxBuffer</code> <span class="type">Number</span></li>
<li><code class="language-javascript">encoding</code> <span class="type">String</span> The encoding used for all stdio inputs and outputs. (Default: &#39;buffer&#39;)</li>
</ul>
</li>
<li>return: <span class="type">Object</span><ul>
<li><code class="language-javascript">pid</code> <span class="type">Number</span> Pid of the child process</li>
<li><code class="language-javascript">output</code> <span class="type">Array</span> Array of results from stdio output</li>
<li><code class="language-javascript">stdout</code> <span class="type">Buffer|String</span> The contents of <code class="language-javascript">output[1]</code></li>
<li><code class="language-javascript">stderr</code> <span class="type">Buffer|String</span> The contents of <code class="language-javascript">output[2]</code></li>
<li><code class="language-javascript">status</code> <span class="type">Number</span> The exit code of the child process</li>
<li><code class="language-javascript">signal</code> <span class="type">String</span> The signal used to kill the child process</li>
<li><code class="language-javascript">error</code> <span class="type">Error</span> The error object if the child process failed or timed out</li>
</ul>
</li>
</div></ul>
<p><code class="language-javascript">spawnSync</code> will not return until the child process has fully closed. When a
timeout has been encountered and <code class="language-javascript">killSignal</code> is sent, the method won&#39;t return
until the process has completely exited. That is to say, if the process handles
the <code class="language-javascript">SIGTERM</code> signal and doesn&#39;t exit, your process will wait until the child
process has exited.

</p>
<!--next-->
<h2>child_process.execFileSync(command[, args][, options])</h2>
<div class="signature"><ul>
<li><code class="language-javascript">command</code> <span class="type">String</span> The command to run</li>
<li><code class="language-javascript">args</code> <span class="type">Array</span> List of string arguments</li>
<li><code class="language-javascript">options</code> <span class="type">Object</span><ul>
<li><code class="language-javascript">cwd</code> <span class="type">String</span> Current working directory of the child process</li>
<li><code class="language-javascript">input</code> <span class="type">String|Buffer</span> The value which will be passed as stdin to the spawned process<ul>
<li>supplying this value will override <code class="language-javascript">stdio[0]</code></li>
</ul>
</li>
<li><code class="language-javascript">stdio</code> <span class="type">Array</span> Child&#39;s stdio configuration. (Default: &#39;pipe&#39;)<ul>
<li><code class="language-javascript">stderr</code> by default will be output to the parent process&#39; stderr unless
<code class="language-javascript">stdio</code> is specified</li>
</ul>
</li>
<li><code class="language-javascript">env</code> <span class="type">Object</span> Environment key-value pairs</li>
<li><code class="language-javascript">uid</code> <span class="type">Number</span> Sets the user identity of the process. (See setuid(2).)</li>
<li><code class="language-javascript">gid</code> <span class="type">Number</span> Sets the group identity of the process. (See setgid(2).)</li>
<li><code class="language-javascript">timeout</code> <span class="type">Number</span> In milliseconds the maximum amount of time the process is allowed to run. (Default: undefined)</li>
<li><code class="language-javascript">killSignal</code> <span class="type">String</span> The signal value to be used when the spawned process will be killed. (Default: &#39;SIGTERM&#39;)</li>
<li><code class="language-javascript">maxBuffer</code> <span class="type">Number</span></li>
<li><code class="language-javascript">encoding</code> <span class="type">String</span> The encoding used for all stdio inputs and outputs. (Default: &#39;buffer&#39;)</li>
</ul>
</li>
<li>return: <span class="type">Buffer|String</span> The stdout from the command</li>
</div></ul>
<p><code class="language-javascript">execFileSync</code> will not return until the child process has fully closed. When a
timeout has been encountered and <code class="language-javascript">killSignal</code> is sent, the method won&#39;t return
until the process has completely exited. That is to say, if the process handles
the <code class="language-javascript">SIGTERM</code> signal and doesn&#39;t exit, your process will wait until the child
process has exited.

</p>
<p>If the process times out, or has a non-zero exit code, this method <strong><em>will</em></strong>
throw.  The <code class="language-javascript">Error</code> object will contain the entire result from
<a><code class="language-javascript">child_process.spawnSync</code></a>


</p>
<!--next-->
<h2>child_process.execSync(command[, options])</h2>
<div class="signature"><ul>
<li><code class="language-javascript">command</code> <span class="type">String</span> The command to run</li>
<li><code class="language-javascript">options</code> <span class="type">Object</span><ul>
<li><code class="language-javascript">cwd</code> <span class="type">String</span> Current working directory of the child process</li>
<li><code class="language-javascript">input</code> <span class="type">String|Buffer</span> The value which will be passed as stdin to the spawned process<ul>
<li>supplying this value will override <code class="language-javascript">stdio[0]</code></li>
</ul>
</li>
<li><code class="language-javascript">stdio</code> <span class="type">Array</span> Child&#39;s stdio configuration. (Default: &#39;pipe&#39;)<ul>
<li><code class="language-javascript">stderr</code> by default will be output to the parent process&#39; stderr unless
<code class="language-javascript">stdio</code> is specified</li>
</ul>
</li>
<li><code class="language-javascript">env</code> <span class="type">Object</span> Environment key-value pairs</li>
<li><code class="language-javascript">uid</code> <span class="type">Number</span> Sets the user identity of the process. (See setuid(2).)</li>
<li><code class="language-javascript">gid</code> <span class="type">Number</span> Sets the group identity of the process. (See setgid(2).)</li>
<li><code class="language-javascript">timeout</code> <span class="type">Number</span> In milliseconds the maximum amount of time the process is allowed to run. (Default: undefined)</li>
<li><code class="language-javascript">killSignal</code> <span class="type">String</span> The signal value to be used when the spawned process will be killed. (Default: &#39;SIGTERM&#39;)</li>
<li><code class="language-javascript">maxBuffer</code> <span class="type">Number</span></li>
<li><code class="language-javascript">encoding</code> <span class="type">String</span> The encoding used for all stdio inputs and outputs. (Default: &#39;buffer&#39;)</li>
</ul>
</li>
<li>return: <span class="type">Buffer|String</span> The stdout from the command</li>
</div></ul>
<p><code class="language-javascript">execSync</code> will not return until the child process has fully closed. When a
timeout has been encountered and <code class="language-javascript">killSignal</code> is sent, the method won&#39;t return
until the process has completely exited. That is to say, if the process handles
the <code class="language-javascript">SIGTERM</code> signal and doesn&#39;t exit, your process will wait until the child
process has exited.

</p>
<p>If the process times out, or has a non-zero exit code, this method <strong><em>will</em></strong>
throw.  The <code class="language-javascript">Error</code> object will contain the entire result from
<a><code class="language-javascript">child_process.spawnSync</code></a>

</p>
<!--next-->
<h2>Assert</h2>
<pre class="stability">Stability: 5 - Locked</pre><p>This module is used for writing unit tests for your applications, you can
access it with <code class="language-javascript">require(&#39;assert&#39;)</code>.

</p>
<!--next-->
<h2>assert.fail(actual, expected, message, operator)</h2>
<p>Throws an exception that displays the values for <code class="language-javascript">actual</code> and <code class="language-javascript">expected</code> separated by the provided operator.

</p>
<!--next-->
<h2>assert(value[, message]), assert.ok(value[, message])</h2>
<p>Tests if value is truthy, it is equivalent to <code class="language-javascript">assert.equal(true, !!value, message);</code>

</p>
<!--next-->
<h2>assert.equal(actual, expected[, message])</h2>
<p>Tests shallow, coercive equality with the equal comparison operator ( <code class="language-javascript">==</code> ).

</p>
<!--next-->
<h2>assert.notEqual(actual, expected[, message])</h2>
<p>Tests shallow, coercive non-equality with the not equal comparison operator ( <code class="language-javascript">!=</code> ).

</p>
<!--next-->
<h2>assert.deepEqual(actual, expected[, message])</h2>
<p>Tests for deep equality.

</p>
<!--next-->
<h2>assert.notDeepEqual(actual, expected[, message])</h2>
<p>Tests for any deep inequality.

</p>
<!--next-->
<h2>assert.strictEqual(actual, expected[, message])</h2>
<p>Tests strict equality, as determined by the strict equality operator ( <code class="language-javascript">===</code> )

</p>
<!--next-->
<h2>assert.notStrictEqual(actual, expected[, message])</h2>
<p>Tests strict non-equality, as determined by the strict not equal operator ( <code class="language-javascript">!==</code> )

</p>
<!--next-->
<h2>assert.throws(block[, error][, message])</h2>
<p>Expects <code class="language-javascript">block</code> to throw an error. <code class="language-javascript">error</code> can be constructor, <code class="language-javascript">RegExp</code> or
validation function.

</p>
<p>Validate instanceof using constructor:

</p>
<pre><code class="language-javascript">assert.throws(
  function() {
    throw new Error(&quot;Wrong value&quot;);
  },
  Error
);</code></pre>
<p>Validate error message using RegExp:

</p>
<pre><code class="language-javascript">assert.throws(
  function() {
    throw new Error(&quot;Wrong value&quot;);
  },
  /value/
);</code></pre>
<p>Custom error validation:

</p>
<pre><code class="language-javascript">assert.throws(
  function() {
    throw new Error(&quot;Wrong value&quot;);
  },
  function(err) {
    if ( (err instanceof Error) &amp;&amp; /value/.test(err) ) {
      return true;
    }
  },
  &quot;unexpected error&quot;
);</code></pre>
<!--next-->
<h2>assert.doesNotThrow(block[, message])</h2>
<p>Expects <code class="language-javascript">block</code> not to throw an error, see <code class="language-javascript">assert.throws</code> for details.

</p>
<!--next-->
<h2>assert.ifError(value)</h2>
<p>Tests if value is not a false value, throws if it is a true value. Useful when
testing the first argument, <code class="language-javascript">error</code> in callbacks.

</p>
<!--next-->
<h2>TTY</h2>
<pre class="stability">Stability: 2 - Unstable</pre><p>The <code class="language-javascript">tty</code> module houses the <code class="language-javascript">tty.ReadStream</code> and <code class="language-javascript">tty.WriteStream</code> classes. In
most cases, you will not need to use this module directly.

</p>
<p>When node detects that it is being run inside a TTY context, then <code class="language-javascript">process.stdin</code>
will be a <code class="language-javascript">tty.ReadStream</code> instance and <code class="language-javascript">process.stdout</code> will be
a <code class="language-javascript">tty.WriteStream</code> instance. The preferred way to check if node is being run in
a TTY context is to check <code class="language-javascript">process.stdout.isTTY</code>:

</p>
<pre><code class="language-javascript">$ node -p -e &quot;Boolean(process.stdout.isTTY)&quot;
true
$ node -p -e &quot;Boolean(process.stdout.isTTY)&quot; | cat
false</code></pre>
<!--next-->
<h2>tty.isatty(fd)</h2>
<p>Returns <code class="language-javascript">true</code> or <code class="language-javascript">false</code> depending on if the <code class="language-javascript">fd</code> is associated with a
terminal.


</p>
<!--next-->
<h2>tty.setRawMode(mode)</h2>
<p>Deprecated. Use <code class="language-javascript">tty.ReadStream#setRawMode()</code>
(i.e. <code class="language-javascript">process.stdin.setRawMode()</code>) instead.


</p>
<!--next-->
<h2>Class: ReadStream</h2>
<p>A <code class="language-javascript">net.Socket</code> subclass that represents the readable portion of a tty. In normal
circumstances, <code class="language-javascript">process.stdin</code> will be the only <code class="language-javascript">tty.ReadStream</code> instance in any
node program (only when <code class="language-javascript">isatty(0)</code> is true).

</p>
<!--next-->
<h2>rs.isRaw</h2>
<p>A <code class="language-javascript">Boolean</code> that is initialized to <code class="language-javascript">false</code>. It represents the current &quot;raw&quot; state
of the <code class="language-javascript">tty.ReadStream</code> instance.

</p>
<!--next-->
<h2>rs.setRawMode(mode)</h2>
<p><code class="language-javascript">mode</code> should be <code class="language-javascript">true</code> or <code class="language-javascript">false</code>. This sets the properties of the
<code class="language-javascript">tty.ReadStream</code> to act either as a raw device or default. <code class="language-javascript">isRaw</code> will be set
to the resulting mode.


</p>
<!--next-->
<h2>Class: WriteStream</h2>
<p>A <code class="language-javascript">net.Socket</code> subclass that represents the writable portion of a tty. In normal
circumstances, <code class="language-javascript">process.stdout</code> will be the only <code class="language-javascript">tty.WriteStream</code> instance
ever created (and only when <code class="language-javascript">isatty(1)</code> is true).

</p>
<!--next-->
<h2>ws.columns</h2>
<p>A <code class="language-javascript">Number</code> that gives the number of columns the TTY currently has. This property
gets updated on &quot;resize&quot; events.

</p>
<!--next-->
<h2>ws.rows</h2>
<p>A <code class="language-javascript">Number</code> that gives the number of rows the TTY currently has. This property
gets updated on &quot;resize&quot; events.

</p>
<!--next-->
<h2>Event: &#39;resize&#39;</h2>
<p><code class="language-javascript">function () {}</code>

</p>
<p>Emitted by <code class="language-javascript">refreshSize()</code> when either of the <code class="language-javascript">columns</code> or <code class="language-javascript">rows</code> properties
has changed.

</p>
<pre><code class="language-javascript">process.stdout.on(&#39;resize&#39;, function() {
  console.log(&#39;screen size has changed!&#39;);
  console.log(process.stdout.columns + &#39;x&#39; + process.stdout.rows);
});</code></pre>
<!--next-->
<h2>Zlib</h2>
<pre class="stability">Stability: 3 - Stable</pre><p>You can access this module with:

</p>
<pre><code class="language-javascript">var zlib = require(&#39;zlib&#39;);</code></pre>
<p>This provides bindings to Gzip/Gunzip, Deflate/Inflate, and
DeflateRaw/InflateRaw classes.  Each class takes the same options, and
is a readable/writable Stream.

</p>
<!--next-->
<h2>Examples</h2>
<p>Compressing or decompressing a file can be done by piping an
fs.ReadStream into a zlib stream, then into an fs.WriteStream.

</p>
<pre><code class="language-javascript">var gzip = zlib.createGzip();
var fs = require(&#39;fs&#39;);
var inp = fs.createReadStream(&#39;input.txt&#39;);
var out = fs.createWriteStream(&#39;input.txt.gz&#39;);

inp.pipe(gzip).pipe(out);</code></pre>
<p>Compressing or decompressing data in one step can be done by using
the convenience methods.

</p>
<pre><code class="language-javascript">var input = &#39;.................................&#39;;
zlib.deflate(input, function(err, buffer) {
  if (!err) {
    console.log(buffer.toString(&#39;base64&#39;));
  }
});

var buffer = new Buffer(&#39;eJzT0yMAAGTvBe8=&#39;, &#39;base64&#39;);
zlib.unzip(buffer, function(err, buffer) {
  if (!err) {
    console.log(buffer.toString());
  }
});</code></pre>
<p>To use this module in an HTTP client or server, use the
<a>accept-encoding</a>
on requests, and the
<a>content-encoding</a>
header on responses.

</p>
<p><strong>Note: these examples are drastically simplified to show
the basic concept.</strong>  Zlib encoding can be expensive, and the results
ought to be cached.  See <a>Memory Usage Tuning</a>
below for more information on the speed/memory/compression
tradeoffs involved in zlib usage.

</p>
<pre><code class="language-javascript">// client request example
var zlib = require(&#39;zlib&#39;);
var http = require(&#39;http&#39;);
var fs = require(&#39;fs&#39;);
var request = http.get({ host: &#39;izs.me&#39;,
                         path: &#39;/&#39;,
                         port: 80,
                         headers: { &#39;accept-encoding&#39;: &#39;gzip,deflate&#39; } });
request.on(&#39;response&#39;, function(response) {
  var output = fs.createWriteStream(&#39;izs.me_index.html&#39;);

  switch (response.headers[&#39;content-encoding&#39;]) {
    // or, just use zlib.createUnzip() to handle both cases
    case &#39;gzip&#39;:
      response.pipe(zlib.createGunzip()).pipe(output);
      break;
    case &#39;deflate&#39;:
      response.pipe(zlib.createInflate()).pipe(output);
      break;
    default:
      response.pipe(output);
      break;
  }
});

// server example
// Running a gzip operation on every request is quite expensive.
// It would be much more efficient to cache the compressed buffer.
var zlib = require(&#39;zlib&#39;);
var http = require(&#39;http&#39;);
var fs = require(&#39;fs&#39;);
http.createServer(function(request, response) {
  var raw = fs.createReadStream(&#39;index.html&#39;);
  var acceptEncoding = request.headers[&#39;accept-encoding&#39;];
  if (!acceptEncoding) {
    acceptEncoding = &#39;&#39;;
  }

  // Note: this is not a conformant accept-encoding parser.
  // See http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3
  if (acceptEncoding.match(/\bdeflate\b/)) {
    response.writeHead(200, { &#39;content-encoding&#39;: &#39;deflate&#39; });
    raw.pipe(zlib.createDeflate()).pipe(response);
  } else if (acceptEncoding.match(/\bgzip\b/)) {
    response.writeHead(200, { &#39;content-encoding&#39;: &#39;gzip&#39; });
    raw.pipe(zlib.createGzip()).pipe(response);
  } else {
    response.writeHead(200, {});
    raw.pipe(response);
  }
}).listen(1337);</code></pre>
<!--next-->
<h2>zlib.createGzip([options])</h2>
<p>Returns a new <a>Gzip</a> object with an
<a>options</a>.

</p>
<!--next-->
<h2>zlib.createGunzip([options])</h2>
<p>Returns a new <a>Gunzip</a> object with an
<a>options</a>.

</p>
<!--next-->
<h2>zlib.createDeflate([options])</h2>
<p>Returns a new <a>Deflate</a> object with an
<a>options</a>.

</p>
<!--next-->
<h2>zlib.createInflate([options])</h2>
<p>Returns a new <a>Inflate</a> object with an
<a>options</a>.

</p>
<!--next-->
<h2>zlib.createDeflateRaw([options])</h2>
<p>Returns a new <a>DeflateRaw</a> object with an
<a>options</a>.

</p>
<!--next-->
<h2>zlib.createInflateRaw([options])</h2>
<p>Returns a new <a>InflateRaw</a> object with an
<a>options</a>.

</p>
<!--next-->
<h2>zlib.createUnzip([options])</h2>
<p>Returns a new <a>Unzip</a> object with an
<a>options</a>.


</p>
<!--next-->
<h2>Class: zlib.Zlib</h2>
<p>Not exported by the <code class="language-javascript">zlib</code> module. It is documented here because it is the base
class of the compressor/decompressor classes.

</p>
<!--next-->
<h2>zlib.flush([kind], callback)</h2>
<p><code class="language-javascript">kind</code> defaults to <code class="language-javascript">zlib.Z_FULL_FLUSH</code>.

</p>
<p>Flush pending data. Don&#39;t call this frivolously, premature flushes negatively
impact the effectiveness of the compression algorithm.

</p>
<!--next-->
<h2>zlib.params(level, strategy, callback)</h2>
<p>Dynamically update the compression level and compression strategy.
Only applicable to deflate algorithm.

</p>
<!--next-->
<h2>zlib.reset()</h2>
<p>Reset the compressor/decompressor to factory defaults. Only applicable to
the inflate and deflate algorithms.

</p>
<!--next-->
<h2>Class: zlib.Gzip</h2>
<p>Compress data using gzip.

</p>
<!--next-->
<h2>Class: zlib.Gunzip</h2>
<p>Decompress a gzip stream.

</p>
<!--next-->
<h2>Class: zlib.Deflate</h2>
<p>Compress data using deflate.

</p>
<!--next-->
<h2>Class: zlib.Inflate</h2>
<p>Decompress a deflate stream.

</p>
<!--next-->
<h2>Class: zlib.DeflateRaw</h2>
<p>Compress data using deflate, and do not append a zlib header.

</p>
<!--next-->
<h2>Class: zlib.InflateRaw</h2>
<p>Decompress a raw deflate stream.

</p>
<!--next-->
<h2>Class: zlib.Unzip</h2>
<p>Decompress either a Gzip- or Deflate-compressed stream by auto-detecting
the header.

</p>
<!--next-->
<h2>Convenience Methods</h2>
<p>All of these take a string or buffer as the first argument, an optional second
argument to supply options to the zlib classes and will call the supplied
callback with <code class="language-javascript">callback(error, result)</code>.

</p>
<p>Every method has a <code class="language-javascript">*Sync</code> counterpart, which accept the same arguments, but
without a callback.

</p>
<!--next-->
<h2>zlib.deflate(buf[, options], callback)</h2>
<!--next-->
<h2>zlib.deflateSync(buf[, options])</h2>
<p>Compress a string with Deflate.

</p>
<!--next-->
<h2>zlib.deflateRaw(buf[, options], callback)</h2>
<!--next-->
<h2>zlib.deflateRawSync(buf[, options])</h2>
<p>Compress a string with DeflateRaw.

</p>
<!--next-->
<h2>zlib.gzip(buf[, options], callback)</h2>
<!--next-->
<h2>zlib.gzipSync(buf[, options])</h2>
<p>Compress a string with Gzip.

</p>
<!--next-->
<h2>zlib.gunzip(buf[, options], callback)</h2>
<!--next-->
<h2>zlib.gunzipSync(buf[, options])</h2>
<p>Decompress a raw Buffer with Gunzip.

</p>
<!--next-->
<h2>zlib.inflate(buf[, options], callback)</h2>
<!--next-->
<h2>zlib.inflateSync(buf[, options])</h2>
<p>Decompress a raw Buffer with Inflate.

</p>
<!--next-->
<h2>zlib.inflateRaw(buf[, options], callback)</h2>
<!--next-->
<h2>zlib.inflateRawSync(buf[, options])</h2>
<p>Decompress a raw Buffer with InflateRaw.

</p>
<!--next-->
<h2>zlib.unzip(buf[, options], callback)</h2>
<!--next-->
<h2>zlib.unzipSync(buf[, options])</h2>
<p>Decompress a raw Buffer with Unzip.

</p>
<!--next-->
<h2>Options</h2>
<p>Each class takes an options object.  All options are optional.

</p>
<p>Note that some options are only relevant when compressing, and are
ignored by the decompression classes.

</p>
<ul>
<li>flush (default: <code class="language-javascript">zlib.Z_NO_FLUSH</code>)</li>
<li>chunkSize (default: 16*1024)</li>
<li>windowBits</li>
<li>level (compression only)</li>
<li>memLevel (compression only)</li>
<li>strategy (compression only)</li>
<li>dictionary (deflate/inflate only, empty dictionary by default)</li>
</ul>
<p>See the description of <code class="language-javascript">deflateInit2</code> and <code class="language-javascript">inflateInit2</code> at
</p>
<p><a>http://zlib.net/manual.html#Advanced</a> for more information on these.

</p>
<!--next-->
<h2>Memory Usage Tuning</h2>
<p>From <code class="language-javascript">zlib/zconf.h</code>, modified to node&#39;s usage:

</p>
<p>The memory requirements for deflate are (in bytes):

</p>
<pre><code class="language-javascript">(1 &lt;&lt; (windowBits+2)) +  (1 &lt;&lt; (memLevel+9))</code></pre>
<p>that is: 128K for windowBits=15  +  128K for memLevel = 8
(default values) plus a few kilobytes for small objects.

</p>
<p>For example, if you want to reduce
the default memory requirements from 256K to 128K, set the options to:

</p>
<pre><code class="language-javascript">{ windowBits: 14, memLevel: 7 }</code></pre>
<p>Of course this will generally degrade compression (there&#39;s no free lunch).

</p>
<p>The memory requirements for inflate are (in bytes)

</p>
<pre><code class="language-javascript">1 &lt;&lt; windowBits</code></pre>
<p>that is, 32K for windowBits=15 (default value) plus a few kilobytes
for small objects.

</p>
<p>This is in addition to a single internal output slab buffer of size
<code class="language-javascript">chunkSize</code>, which defaults to 16K.

</p>
<p>The speed of zlib compression is affected most dramatically by the
<code class="language-javascript">level</code> setting.  A higher level will result in better compression, but
will take longer to complete.  A lower level will result in less
compression, but will be much faster.

</p>
<p>In general, greater memory usage options will mean that node has to make
fewer calls to zlib, since it&#39;ll be able to process more data in a
single <code class="language-javascript">write</code> operation.  So, this is another factor that affects the
speed, at the cost of memory usage.

</p>
<!--next-->
<h2>Constants</h2>
<p>All of the constants defined in zlib.h are also defined on
<code class="language-javascript">require(&#39;zlib&#39;)</code>.
In the normal course of operations, you will not need to ever set any of
these.  They are documented here so that their presence is not
surprising.  This section is taken almost directly from the <a>zlib
documentation</a>.  See
</p>
<p><a>http://zlib.net/manual.html#Constants</a> for more details.

</p>
<p>Allowed flush values.

</p>
<ul>
<li><code class="language-javascript">zlib.Z_NO_FLUSH</code></li>
<li><code class="language-javascript">zlib.Z_PARTIAL_FLUSH</code></li>
<li><code class="language-javascript">zlib.Z_SYNC_FLUSH</code></li>
<li><code class="language-javascript">zlib.Z_FULL_FLUSH</code></li>
<li><code class="language-javascript">zlib.Z_FINISH</code></li>
<li><code class="language-javascript">zlib.Z_BLOCK</code></li>
<li><code class="language-javascript">zlib.Z_TREES</code></li>
</ul>
<p>Return codes for the compression/decompression functions. Negative
values are errors, positive values are used for special but normal
events.

</p>
<ul>
<li><code class="language-javascript">zlib.Z_OK</code></li>
<li><code class="language-javascript">zlib.Z_STREAM_END</code></li>
<li><code class="language-javascript">zlib.Z_NEED_DICT</code></li>
<li><code class="language-javascript">zlib.Z_ERRNO</code></li>
<li><code class="language-javascript">zlib.Z_STREAM_ERROR</code></li>
<li><code class="language-javascript">zlib.Z_DATA_ERROR</code></li>
<li><code class="language-javascript">zlib.Z_MEM_ERROR</code></li>
<li><code class="language-javascript">zlib.Z_BUF_ERROR</code></li>
<li><code class="language-javascript">zlib.Z_VERSION_ERROR</code></li>
</ul>
<p>Compression levels.

</p>
<ul>
<li><code class="language-javascript">zlib.Z_NO_COMPRESSION</code></li>
<li><code class="language-javascript">zlib.Z_BEST_SPEED</code></li>
<li><code class="language-javascript">zlib.Z_BEST_COMPRESSION</code></li>
<li><code class="language-javascript">zlib.Z_DEFAULT_COMPRESSION</code></li>
</ul>
<p>Compression strategy.

</p>
<ul>
<li><code class="language-javascript">zlib.Z_FILTERED</code></li>
<li><code class="language-javascript">zlib.Z_HUFFMAN_ONLY</code></li>
<li><code class="language-javascript">zlib.Z_RLE</code></li>
<li><code class="language-javascript">zlib.Z_FIXED</code></li>
<li><code class="language-javascript">zlib.Z_DEFAULT_STRATEGY</code></li>
</ul>
<p>Possible values of the data_type field.

</p>
<ul>
<li><code class="language-javascript">zlib.Z_BINARY</code></li>
<li><code class="language-javascript">zlib.Z_TEXT</code></li>
<li><code class="language-javascript">zlib.Z_ASCII</code></li>
<li><code class="language-javascript">zlib.Z_UNKNOWN</code></li>
</ul>
<p>The deflate compression method (the only one supported in this version).

</p>
<ul>
<li><code class="language-javascript">zlib.Z_DEFLATED</code></li>
</ul>
<p>For initializing zalloc, zfree, opaque.

</p>
<ul>
<li><code class="language-javascript">zlib.Z_NULL</code></li>
</ul>
<!--next-->
<h2>os</h2>
<pre class="stability">Stability: 4 - API Frozen</pre><p>Provides a few basic operating-system related utility functions.

</p>
<p>Use <code class="language-javascript">require(&#39;os&#39;)</code> to access this module.

</p>
<!--next-->
<h2>os.tmpdir()</h2>
<p>Returns the operating system&#39;s default directory for temp files.

</p>
<!--next-->
<h2>os.endianness()</h2>
<p>Returns the endianness of the CPU. Possible values are <code class="language-javascript">&quot;BE&quot;</code> or <code class="language-javascript">&quot;LE&quot;</code>.

</p>
<!--next-->
<h2>os.hostname()</h2>
<p>Returns the hostname of the operating system.

</p>
<!--next-->
<h2>os.type()</h2>
<p>Returns the operating system name.

</p>
<!--next-->
<h2>os.platform()</h2>
<p>Returns the operating system platform.

</p>
<!--next-->
<h2>os.arch()</h2>
<p>Returns the operating system CPU architecture. Possible values are <code class="language-javascript">&quot;x64&quot;</code>,
<code class="language-javascript">&quot;arm&quot;</code> and <code class="language-javascript">&quot;ia32&quot;</code>.

</p>
<!--next-->
<h2>os.release()</h2>
<p>Returns the operating system release.

</p>
<!--next-->
<h2>os.uptime()</h2>
<p>Returns the system uptime in seconds.

</p>
<!--next-->
<h2>os.loadavg()</h2>
<p>Returns an array containing the 1, 5, and 15 minute load averages.

</p>
<p>The load average is a measure of system activity, calculated by the operating
system and expressed as a fractional number.  As a rule of thumb, the load
average should ideally be less than the number of logical CPUs in the system.

</p>
<p>The load average is a very UNIX-y concept; there is no real equivalent on
Windows platforms.  That is why this function always returns <code class="language-javascript">[0, 0, 0]</code> on
Windows.

</p>
<!--next-->
<h2>os.totalmem()</h2>
<p>Returns the total amount of system memory in bytes.

</p>
<!--next-->
<h2>os.freemem()</h2>
<p>Returns the amount of free system memory in bytes.

</p>
<!--next-->
<h2>os.cpus()</h2>
<p>Returns an array of objects containing information about each CPU/core
installed: model, speed (in MHz), and times (an object containing the number of
milliseconds the CPU/core spent in: user, nice, sys, idle, and irq).

</p>
<p>Example inspection of os.cpus:

</p>
<pre><code class="language-javascript">[ { model: &#39;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&#39;,
    speed: 2926,
    times:
     { user: 252020,
       nice: 0,
       sys: 30340,
       idle: 1070356870,
       irq: 0 } },
  { model: &#39;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&#39;,
    speed: 2926,
    times:
     { user: 306960,
       nice: 0,
       sys: 26980,
       idle: 1071569080,
       irq: 0 } },
  { model: &#39;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&#39;,
    speed: 2926,
    times:
     { user: 248450,
       nice: 0,
       sys: 21750,
       idle: 1070919370,
       irq: 0 } },
  { model: &#39;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&#39;,
    speed: 2926,
    times:
     { user: 256880,
       nice: 0,
       sys: 19430,
       idle: 1070905480,
       irq: 20 } },
  { model: &#39;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&#39;,
    speed: 2926,
    times:
     { user: 511580,
       nice: 20,
       sys: 40900,
       idle: 1070842510,
       irq: 0 } },
  { model: &#39;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&#39;,
    speed: 2926,
    times:
     { user: 291660,
       nice: 0,
       sys: 34360,
       idle: 1070888000,
       irq: 10 } },
  { model: &#39;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&#39;,
    speed: 2926,
    times:
     { user: 308260,
       nice: 0,
       sys: 55410,
       idle: 1071129970,
       irq: 880 } },
  { model: &#39;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&#39;,
    speed: 2926,
    times:
     { user: 266450,
       nice: 1480,
       sys: 34920,
       idle: 1072572010,
       irq: 30 } } ]</code></pre>
<!--next-->
<h2>os.networkInterfaces()</h2>
<p>Get a list of network interfaces:

</p>
<pre><code class="language-javascript">{ lo:
   [ { address: &#39;127.0.0.1&#39;,
       netmask: &#39;255.0.0.0&#39;,
       family: &#39;IPv4&#39;,
       mac: &#39;00:00:00:00:00:00&#39;,
       internal: true },
     { address: &#39;::1&#39;,
       netmask: &#39;ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff&#39;,
       family: &#39;IPv6&#39;,
       mac: &#39;00:00:00:00:00:00&#39;,
       internal: true } ],
  eth0:
   [ { address: &#39;192.168.1.108&#39;,
       netmask: &#39;255.255.255.0&#39;,
       family: &#39;IPv4&#39;,
       mac: &#39;01:02:03:0a:0b:0c&#39;,
       internal: false },
     { address: &#39;fe80::a00:27ff:fe4e:66a1&#39;,
       netmask: &#39;ffff:ffff:ffff:ffff::&#39;,
       family: &#39;IPv6&#39;,
       mac: &#39;01:02:03:0a:0b:0c&#39;,
       internal: false } ] }</code></pre>
<!--next-->
<h2>os.EOL</h2>
<p>A constant defining the appropriate End-of-line marker for the operating system.

</p>
<!--next-->
<h2>Debugger</h2>
<pre class="stability">Stability: 3 - Stable</pre><!-- type=misc -->

<p>V8 comes with an extensive debugger which is accessible out-of-process via a
simple <a>TCP protocol</a>.
Node has a built-in client for this debugger. To use this, start Node with the
<code class="language-javascript">debug</code> argument; a prompt will appear:

</p>
<pre><code class="language-javascript">% node debug myscript.js
&lt; debugger listening on port 5858
connecting... ok
break in /home/indutny/Code/git/indutny/myscript.js:1
  1 x = 5;
  2 setTimeout(function () {
  3   debugger;
debug&gt;</code></pre>
<p>Node&#39;s debugger client doesn&#39;t support the full range of commands, but
simple step and inspection is possible. By putting the statement <code class="language-javascript">debugger;</code>
into the source code of your script, you will enable a breakpoint.

</p>
<p>For example, suppose <code class="language-javascript">myscript.js</code> looked like this:

</p>
<pre><code class="language-javascript">// myscript.js
x = 5;
setTimeout(function () {
  debugger;
  console.log(&quot;world&quot;);
}, 1000);
console.log(&quot;hello&quot;);</code></pre>
<p>Then once the debugger is run, it will break on line 4.

</p>
<pre><code class="language-javascript">% node debug myscript.js
&lt; debugger listening on port 5858
connecting... ok
break in /home/indutny/Code/git/indutny/myscript.js:1
  1 x = 5;
  2 setTimeout(function () {
  3   debugger;
debug&gt; cont
&lt; hello
break in /home/indutny/Code/git/indutny/myscript.js:3
  1 x = 5;
  2 setTimeout(function () {
  3   debugger;
  4   console.log(&quot;world&quot;);
  5 }, 1000);
debug&gt; next
break in /home/indutny/Code/git/indutny/myscript.js:4
  2 setTimeout(function () {
  3   debugger;
  4   console.log(&quot;world&quot;);
  5 }, 1000);
  6 console.log(&quot;hello&quot;);
debug&gt; repl
Press Ctrl + C to leave debug repl
&gt; x
5
&gt; 2+2
4
debug&gt; next
&lt; world
break in /home/indutny/Code/git/indutny/myscript.js:5
  3   debugger;
  4   console.log(&quot;world&quot;);
  5 }, 1000);
  6 console.log(&quot;hello&quot;);
  7
debug&gt; quit
%</code></pre>
<p>The <code class="language-javascript">repl</code> command allows you to evaluate code remotely. The <code class="language-javascript">next</code> command
steps over to the next line. There are a few other commands available and more
to come. Type <code class="language-javascript">help</code> to see others.

</p>
<!--next-->
<h2>Watchers</h2>
<p>You can watch expression and variable values while debugging your code.
On every breakpoint each expression from the watchers list will be evaluated
in the current context and displayed just before the breakpoint&#39;s source code
listing.

</p>
<p>To start watching an expression, type <code class="language-javascript">watch(&quot;my_expression&quot;)</code>. <code class="language-javascript">watchers</code>
prints the active watchers. To remove a watcher, type
<code class="language-javascript">unwatch(&quot;my_expression&quot;)</code>.

</p>
<!--next-->
<h2>Commands reference</h2>
<!--next-->
<h2>Stepping</h2>
<ul>
<li><code class="language-javascript">cont</code>, <code class="language-javascript">c</code> - Continue execution</li>
<li><code class="language-javascript">next</code>, <code class="language-javascript">n</code> - Step next</li>
<li><code class="language-javascript">step</code>, <code class="language-javascript">s</code> - Step in</li>
<li><code class="language-javascript">out</code>, <code class="language-javascript">o</code> - Step out</li>
<li><code class="language-javascript">pause</code> - Pause running code (like pause button in Developer Tools)</li>
</ul>
<!--next-->
<h2>Breakpoints</h2>
<div class="signature"><ul>
<li><code class="language-javascript">setBreakpoint()</code>, <code class="language-javascript">sb()</code> - Set breakpoint on current line</li>
<li><code class="language-javascript">setBreakpoint(line)</code>, <code class="language-javascript">sb(line)</code> - Set breakpoint on specific line</li>
<li><code class="language-javascript">setBreakpoint(&#39;fn()&#39;)</code>, <code class="language-javascript">sb(...)</code> - Set breakpoint on a first statement in
functions body</li>
<li><code class="language-javascript">setBreakpoint(&#39;script.js&#39;, 1)</code>, <code class="language-javascript">sb(...)</code> - Set breakpoint on first line of
script.js</li>
<li><code class="language-javascript">clearBreakpoint</code>, <code class="language-javascript">cb(...)</code> - Clear breakpoint</li>
</div></ul>
<p>It is also possible to set a breakpoint in a file (module) that
isn&#39;t loaded yet:

</p>
<pre><code class="language-javascript">% ./node debug test/fixtures/break-in-module/main.js
&lt; debugger listening on port 5858
connecting to port 5858... ok
break in test/fixtures/break-in-module/main.js:1
  1 var mod = require(&#39;./mod.js&#39;);
  2 mod.hello();
  3 mod.hello();
debug&gt; setBreakpoint(&#39;mod.js&#39;, 23)
Warning: script &#39;mod.js&#39; was not loaded yet.
  1 var mod = require(&#39;./mod.js&#39;);
  2 mod.hello();
  3 mod.hello();
debug&gt; c
break in test/fixtures/break-in-module/mod.js:23
 21
 22 exports.hello = function() {
 23   return &#39;hello from module&#39;;
 24 };
 25
debug&gt;</code></pre>
<!--next-->
<h2>Info</h2>
<div class="signature"><ul>
<li><code class="language-javascript">backtrace</code>, <code class="language-javascript">bt</code> - Print backtrace of current execution frame</li>
<li><code class="language-javascript">list(5)</code> - List scripts source code with 5 line context (5 lines before and
after)</li>
<li><code class="language-javascript">watch(expr)</code> - Add expression to watch list</li>
<li><code class="language-javascript">unwatch(expr)</code> - Remove expression from watch list</li>
<li><code class="language-javascript">watchers</code> - List all watchers and their values (automatically listed on each
breakpoint)</li>
<li><code class="language-javascript">repl</code> - Open debugger&#39;s repl for evaluation in debugging script&#39;s context</li>
</div></ul>
<!--next-->
<h2>Execution control</h2>
<div class="signature"><ul>
<li><code class="language-javascript">run</code> - Run script (automatically runs on debugger&#39;s start)</li>
<li><code class="language-javascript">restart</code> - Restart script</li>
<li><code class="language-javascript">kill</code> - Kill script</li>
</div></ul>
<!--next-->
<h2>Various</h2>
<div class="signature"><ul>
<li><code class="language-javascript">scripts</code> - List all loaded scripts</li>
<li><code class="language-javascript">version</code> - Display v8&#39;s version</li>
</div></ul>
<!--next-->
<h2>Advanced Usage</h2>
<p>The V8 debugger can be enabled and accessed either by starting Node with
the <code class="language-javascript">--debug</code> command-line flag or by signaling an existing Node process
with <code class="language-javascript">SIGUSR1</code>.

</p>
<p>Once a process has been set in debug mode with this it can be connected to
with the node debugger. Either connect to the <code class="language-javascript">pid</code> or the URI to the debugger.
The syntax is:

</p>
<ul>
<li><code class="language-javascript">node debug -p &lt;pid&gt;</code> - Connects to the process via the <code class="language-javascript">pid</code></li>
<li><code class="language-javascript">node debug &lt;URI&gt;</code> - Connects to the process via the URI such as localhost:5858</li>
</ul>
<!--next-->
<h2>Cluster</h2>
<pre class="stability">Stability: 2 - Unstable</pre><p>A single instance of Node runs in a single thread. To take advantage of
multi-core systems the user will sometimes want to launch a cluster of Node
processes to handle the load.

</p>
<p>The cluster module allows you to easily create child processes that
all share server ports.

</p>
<pre><code class="language-javascript">var cluster = require(&#39;cluster&#39;);
var http = require(&#39;http&#39;);
var numCPUs = require(&#39;os&#39;).cpus().length;

if (cluster.isMaster) {
  // Fork workers.
  for (var i = 0; i &lt; numCPUs; i++) {
    cluster.fork();
  }

  cluster.on(&#39;exit&#39;, function(worker, code, signal) {
    console.log(&#39;worker &#39; + worker.process.pid + &#39; died&#39;);
  });
} else {
  // Workers can share any TCP connection
  // In this case its a HTTP server
  http.createServer(function(req, res) {
    res.writeHead(200);
    res.end(&quot;hello world\n&quot;);
  }).listen(8000);
}</code></pre>
<p>Running node will now share port 8000 between the workers:

</p>
<pre><code class="language-javascript">% NODE_DEBUG=cluster node server.js
23521,Master Worker 23524 online
23521,Master Worker 23526 online
23521,Master Worker 23523 online
23521,Master Worker 23528 online</code></pre>
<p>This feature was introduced recently, and may change in future versions.
Please try it out and provide feedback.

</p>
<p>Also note that, on Windows, it is not yet possible to set up a named pipe
server in a worker.

</p>
<!--next-->
<h2>How It Works</h2>
<p>The worker processes are spawned using the <code class="language-javascript">child_process.fork</code> method,
so that they can communicate with the parent via IPC and pass server
handles back and forth.

</p>
<p>The cluster module supports two methods of distributing incoming
connections.

</p>
<p>The first one (and the default one on all platforms except Windows),
is the round-robin approach, where the master process listens on a
port, accepts new connections and distributes them across the workers
in a round-robin fashion, with some built-in smarts to avoid
overloading a worker process.

</p>
<p>The second approach is where the master process creates the listen
socket and sends it to interested workers. The workers then accept
incoming connections directly.

</p>
<p>The second approach should, in theory, give the best performance.
In practice however, distribution tends to be very unbalanced due
to operating system scheduler vagaries. Loads have been observed
where over 70% of all connections ended up in just two processes,
out of a total of eight.

</p>
<p>Because <code class="language-javascript">server.listen()</code> hands off most of the work to the master
process, there are three cases where the behavior between a normal
node.js process and a cluster worker differs:

</p>
<ol>
<li><code class="language-javascript">server.listen({fd: 7})</code> Because the message is passed to the master,
file descriptor 7 <strong>in the parent</strong> will be listened on, and the
handle passed to the worker, rather than listening to the worker&#39;s
idea of what the number 7 file descriptor references.</li>
<li><code class="language-javascript">server.listen(handle)</code> Listening on handles explicitly will cause
the worker to use the supplied handle, rather than talk to the master
process.  If the worker already has the handle, then it&#39;s presumed
that you know what you are doing.</li>
<li><code class="language-javascript">server.listen(0)</code> Normally, this will cause servers to listen on a
random port.  However, in a cluster, each worker will receive the
same &quot;random&quot; port each time they do <code class="language-javascript">listen(0)</code>.  In essence, the
port is random the first time, but predictable thereafter.  If you
want to listen on a unique port, generate a port number based on the
cluster worker ID.</li>
</ol>
<p>There is no routing logic in Node.js, or in your program, and no shared
state between the workers.  Therefore, it is important to design your
program such that it does not rely too heavily on in-memory data objects
for things like sessions and login.

</p>
<p>Because workers are all separate processes, they can be killed or
re-spawned depending on your program&#39;s needs, without affecting other
workers.  As long as there are some workers still alive, the server will
continue to accept connections.  Node does not automatically manage the
number of workers for you, however.  It is your responsibility to manage
the worker pool for your application&#39;s needs.

</p>
<!--next-->
<h2>cluster.schedulingPolicy</h2>
<p>The scheduling policy, either <code class="language-javascript">cluster.SCHED_RR</code> for round-robin or
<code class="language-javascript">cluster.SCHED_NONE</code> to leave it to the operating system. This is a
global setting and effectively frozen once you spawn the first worker
or call <code class="language-javascript">cluster.setupMaster()</code>, whatever comes first.

</p>
<p><code class="language-javascript">SCHED_RR</code> is the default on all operating systems except Windows.
Windows will change to <code class="language-javascript">SCHED_RR</code> once libuv is able to effectively
distribute IOCP handles without incurring a large performance hit.

</p>
<p><code class="language-javascript">cluster.schedulingPolicy</code> can also be set through the
<code class="language-javascript">NODE_CLUSTER_SCHED_POLICY</code> environment variable. Valid
values are <code class="language-javascript">&quot;rr&quot;</code> and <code class="language-javascript">&quot;none&quot;</code>.

</p>
<!--next-->
<h2>cluster.settings</h2>
<div class="signature"><ul>
<li><span class="type">Object</span><ul>
<li><code class="language-javascript">execArgv</code> <span class="type">Array</span> list of string arguments passed to the node executable.
(Default=<code class="language-javascript">process.execArgv</code>)</li>
<li><code class="language-javascript">exec</code> <span class="type">String</span> file path to worker file.  (Default=<code class="language-javascript">process.argv[1]</code>)</li>
<li><code class="language-javascript">args</code> <span class="type">Array</span> string arguments passed to worker.
(Default=<code class="language-javascript">process.argv.slice(2)</code>)</li>
<li><code class="language-javascript">silent</code> <span class="type">Boolean</span> whether or not to send output to parent&#39;s stdio.
(Default=<code class="language-javascript">false</code>)</li>
<li><code class="language-javascript">uid</code> <span class="type">Number</span> Sets the user identity of the process. (See setuid(2).)</li>
<li><code class="language-javascript">gid</code> <span class="type">Number</span> Sets the group identity of the process. (See setgid(2).)</li>
</ul>
</li>
</div></ul>
<p>After calling <code class="language-javascript">.setupMaster()</code> (or <code class="language-javascript">.fork()</code>) this settings object will contain
the settings, including the default values.

</p>
<p>It is effectively frozen after being set, because <code class="language-javascript">.setupMaster()</code> can
only be called once.

</p>
<p>This object is not supposed to be changed or set manually, by you.

</p>
<!--next-->
<h2>cluster.isMaster</h2>
<div class="signature"><ul>
<li><span class="type">Boolean</span></li>
</div></ul>
<p>True if the process is a master. This is determined
by the <code class="language-javascript">process.env.NODE_UNIQUE_ID</code>. If <code class="language-javascript">process.env.NODE_UNIQUE_ID</code> is
undefined, then <code class="language-javascript">isMaster</code> is <code class="language-javascript">true</code>.

</p>
<!--next-->
<h2>cluster.isWorker</h2>
<div class="signature"><ul>
<li><span class="type">Boolean</span></li>
</div></ul>
<p>True if the process is not a master (it is the negation of <code class="language-javascript">cluster.isMaster</code>).

</p>
<!--next-->
<h2>Event: &#39;fork&#39;</h2>
<div class="signature"><ul>
<li><code class="language-javascript">worker</code> <span class="type">Worker object</span></li>
</div></ul>
<p>When a new worker is forked the cluster module will emit a &#39;fork&#39; event.
This can be used to log worker activity, and create your own timeout.

</p>
<pre><code class="language-javascript">var timeouts = [];
function errorMsg() {
  console.error(&quot;Something must be wrong with the connection ...&quot;);
}

cluster.on(&#39;fork&#39;, function(worker) {
  timeouts[worker.id] = setTimeout(errorMsg, 2000);
});
cluster.on(&#39;listening&#39;, function(worker, address) {
  clearTimeout(timeouts[worker.id]);
});
cluster.on(&#39;exit&#39;, function(worker, code, signal) {
  clearTimeout(timeouts[worker.id]);
  errorMsg();
});</code></pre>
<!--next-->
<h2>Event: &#39;online&#39;</h2>
<div class="signature"><ul>
<li><code class="language-javascript">worker</code> <span class="type">Worker object</span></li>
</div></ul>
<p>After forking a new worker, the worker should respond with an online message.
When the master receives an online message it will emit this event.
The difference between &#39;fork&#39; and &#39;online&#39; is that fork is emitted when the
master forks a worker, and &#39;online&#39; is emitted when the worker is running.

</p>
<pre><code class="language-javascript">cluster.on(&#39;online&#39;, function(worker) {
  console.log(&quot;Yay, the worker responded after it was forked&quot;);
});</code></pre>
<!--next-->
<h2>Event: &#39;listening&#39;</h2>
<div class="signature"><ul>
<li><code class="language-javascript">worker</code> <span class="type">Worker object</span></li>
<li><code class="language-javascript">address</code> <span class="type">Object</span></li>
</div></ul>
<p>After calling <code class="language-javascript">listen()</code> from a worker, when the &#39;listening&#39; event is emitted on
the server, a listening event will also be emitted on <code class="language-javascript">cluster</code> in the master.

</p>
<p>The event handler is executed with two arguments, the <code class="language-javascript">worker</code> contains the worker
object and the <code class="language-javascript">address</code> object contains the following connection properties:
<code class="language-javascript">address</code>, <code class="language-javascript">port</code> and <code class="language-javascript">addressType</code>. This is very useful if the worker is listening
on more than one address.

</p>
<pre><code class="language-javascript">cluster.on(&#39;listening&#39;, function(worker, address) {
  console.log(&quot;A worker is now connected to &quot; + address.address + &quot;:&quot; + address.port);
});</code></pre>
<p>The <code class="language-javascript">addressType</code> is one of:

</p>
<ul>
<li><code class="language-javascript">4</code> (TCPv4)</li>
<li><code class="language-javascript">6</code> (TCPv6)</li>
<li><code class="language-javascript">-1</code> (unix domain socket)</li>
<li><code class="language-javascript">&quot;udp4&quot;</code> or <code class="language-javascript">&quot;udp6&quot;</code> (UDP v4 or v6)</li>
</ul>
<!--next-->
<h2>Event: &#39;disconnect&#39;</h2>
<div class="signature"><ul>
<li><code class="language-javascript">worker</code> <span class="type">Worker object</span></li>
</div></ul>
<p>Emitted after the worker IPC channel has disconnected. This can occur when a
worker exits gracefully, is killed, or is disconnected manually (such as with
worker.disconnect()).

</p>
<p>There may be a delay between the <code class="language-javascript">disconnect</code> and <code class="language-javascript">exit</code> events.  These events
can be used to detect if the process is stuck in a cleanup or if there are
long-living connections.

</p>
<pre><code class="language-javascript">cluster.on(&#39;disconnect&#39;, function(worker) {
  console.log(&#39;The worker #&#39; + worker.id + &#39; has disconnected&#39;);
});</code></pre>
<!--next-->
<h2>Event: &#39;exit&#39;</h2>
<div class="signature"><ul>
<li><code class="language-javascript">worker</code> <span class="type">Worker object</span></li>
<li><code class="language-javascript">code</code> <span class="type">Number</span> the exit code, if it exited normally.</li>
<li><code class="language-javascript">signal</code> <span class="type">String</span> the name of the signal (eg. <code class="language-javascript">&#39;SIGHUP&#39;</code>) that caused
the process to be killed.</li>
</div></ul>
<p>When any of the workers die the cluster module will emit the &#39;exit&#39; event.

</p>
<p>This can be used to restart the worker by calling <code class="language-javascript">.fork()</code> again.

</p>
<pre><code class="language-javascript">cluster.on(&#39;exit&#39;, function(worker, code, signal) {
  console.log(&#39;worker %d died (%s). restarting...&#39;,
    worker.process.pid, signal || code);
  cluster.fork();
});</code></pre>
<p>See <a>child_process event: &#39;exit&#39;</a>.

</p>
<!--next-->
<h2>Event: &#39;setup&#39;</h2>
<div class="signature"><ul>
<li><code class="language-javascript">settings</code> <span class="type">Object</span></li>
</div></ul>
<p>Emitted every time <code class="language-javascript">.setupMaster()</code> is called.

</p>
<p>The <code class="language-javascript">settings</code> object is the <code class="language-javascript">cluster.settings</code> object at the time
<code class="language-javascript">.setupMaster()</code> was called and is advisory only, since multiple calls to
<code class="language-javascript">.setupMaster()</code> can be made in a single tick.

</p>
<p>If accuracy is important, use <code class="language-javascript">cluster.settings</code>.

</p>
<!--next-->
<h2>cluster.setupMaster([settings])</h2>
<div class="signature"><ul>
<li><code class="language-javascript">settings</code> <span class="type">Object</span><ul>
<li><code class="language-javascript">exec</code> <span class="type">String</span> file path to worker file.  (Default=<code class="language-javascript">process.argv[1]</code>)</li>
<li><code class="language-javascript">args</code> <span class="type">Array</span> string arguments passed to worker.
(Default=<code class="language-javascript">process.argv.slice(2)</code>)</li>
<li><code class="language-javascript">silent</code> <span class="type">Boolean</span> whether or not to send output to parent&#39;s stdio.
(Default=<code class="language-javascript">false</code>)</li>
</ul>
</li>
</div></ul>
<p><code class="language-javascript">setupMaster</code> is used to change the default &#39;fork&#39; behavior. Once called,
the settings will be present in <code class="language-javascript">cluster.settings</code>.

</p>
<p>Note that:

</p>
<ul>
<li>any settings changes only affect future calls to <code class="language-javascript">.fork()</code> and have no
effect on workers that are already running</li>
<li>The <em>only</em> attribute of a worker that cannot be set via <code class="language-javascript">.setupMaster()</code> is
the <code class="language-javascript">env</code> passed to <code class="language-javascript">.fork()</code></li>
<li>the defaults above apply to the first call only, the defaults for later
calls is the current value at the time of <code class="language-javascript">cluster.setupMaster()</code> is called</li>
</ul>
<p>Example:

</p>
<pre><code class="language-javascript">var cluster = require(&#39;cluster&#39;);
cluster.setupMaster({
  exec: &#39;worker.js&#39;,
  args: [&#39;--use&#39;, &#39;https&#39;],
  silent: true
});
cluster.fork(); // https worker
cluster.setupMaster({
  args: [&#39;--use&#39;, &#39;http&#39;]
});
cluster.fork(); // http worker</code></pre>
<p>This can only be called from the master process.

</p>
<!--next-->
<h2>cluster.fork([env])</h2>
<div class="signature"><ul>
<li><code class="language-javascript">env</code> <span class="type">Object</span> Key/value pairs to add to worker process environment.</li>
<li>return <span class="type">Worker object</span></li>
</div></ul>
<p>Spawn a new worker process.

</p>
<p>This can only be called from the master process.

</p>
<!--next-->
<h2>cluster.disconnect([callback])</h2>
<div class="signature"><ul>
<li><code class="language-javascript">callback</code> <span class="type">Function</span> called when all workers are disconnected and handles are
closed</li>
</div></ul>
<p>Calls <code class="language-javascript">.disconnect()</code> on each worker in <code class="language-javascript">cluster.workers</code>.

</p>
<p>When they are disconnected all internal handles will be closed, allowing the
master process to die gracefully if no other event is waiting.

</p>
<p>The method takes an optional callback argument which will be called when finished.

</p>
<p>This can only be called from the master process.

</p>
<!--next-->
<h2>cluster.worker</h2>
<div class="signature"><ul>
<li><span class="type">Object</span></li>
</div></ul>
<p>A reference to the current worker object. Not available in the master process.

</p>
<pre><code class="language-javascript">var cluster = require(&#39;cluster&#39;);

if (cluster.isMaster) {
  console.log(&#39;I am master&#39;);
  cluster.fork();
  cluster.fork();
} else if (cluster.isWorker) {
  console.log(&#39;I am worker #&#39; + cluster.worker.id);
}</code></pre>
<!--next-->
<h2>cluster.workers</h2>
<div class="signature"><ul>
<li><span class="type">Object</span></li>
</div></ul>
<p>A hash that stores the active worker objects, keyed by <code class="language-javascript">id</code> field. Makes it
easy to loop through all the workers. It is only available in the master
process.

</p>
<p>A worker is removed from cluster.workers after the worker has disconnected <em>and</em>
exited. The order between these two events cannot be determined in advance.
However, it is guaranteed that the removal from the cluster.workers list happens
before last <code class="language-javascript">&#39;disconnect&#39;</code> or <code class="language-javascript">&#39;exit&#39;</code> event is emitted.

</p>
<pre><code class="language-javascript">// Go through all workers
function eachWorker(callback) {
  for (var id in cluster.workers) {
    callback(cluster.workers[id]);
  }
}
eachWorker(function(worker) {
  worker.send(&#39;big announcement to all workers&#39;);
});</code></pre>
<p>Should you wish to reference a worker over a communication channel, using
the worker&#39;s unique id is the easiest way to find the worker.

</p>
<pre><code class="language-javascript">socket.on(&#39;data&#39;, function(id) {
  var worker = cluster.workers[id];
});</code></pre>
<!--next-->
<h2>Class: Worker</h2>
<p>A Worker object contains all public information and method about a worker.
In the master it can be obtained using <code class="language-javascript">cluster.workers</code>. In a worker
it can be obtained using <code class="language-javascript">cluster.worker</code>.

</p>
<!--next-->
<h2>worker.id</h2>
<div class="signature"><ul>
<li><span class="type">String</span></li>
</div></ul>
<p>Each new worker is given its own unique id, this id is stored in the
<code class="language-javascript">id</code>.

</p>
<p>While a worker is alive, this is the key that indexes it in
cluster.workers

</p>
<!--next-->
<h2>worker.process</h2>
<div class="signature"><ul>
<li><span class="type">ChildProcess object</span></li>
</div></ul>
<p>All workers are created using <code class="language-javascript">child_process.fork()</code>, the returned object
from this function is stored as <code class="language-javascript">.process</code>. In a worker, the global <code class="language-javascript">process</code>
is stored.

</p>
<p>See: <a>Child Process module</a>

</p>
<p>Note that workers will call <code class="language-javascript">process.exit(0)</code> if the <code class="language-javascript">&#39;disconnect&#39;</code> event occurs
on <code class="language-javascript">process</code> and <code class="language-javascript">.suicide</code> is not <code class="language-javascript">true</code>. This protects against accidental
disconnection.

</p>
<!--next-->
<h2>worker.suicide</h2>
<div class="signature"><ul>
<li><span class="type">Boolean</span></li>
</div></ul>
<p>Set by calling <code class="language-javascript">.kill()</code> or <code class="language-javascript">.disconnect()</code>, until then it is <code class="language-javascript">undefined</code>.

</p>
<p>The boolean <code class="language-javascript">worker.suicide</code> lets you distinguish between voluntary and accidental
exit, the master may choose not to respawn a worker based on this value.

</p>
<pre><code class="language-javascript">cluster.on(&#39;exit&#39;, function(worker, code, signal) {
  if (worker.suicide === true) {
    console.log(&#39;Oh, it was just suicide\&#39;  no need to worry&#39;).
  }
});

// kill worker
worker.kill();</code></pre>
<!--next-->
<h2>worker.send(message[, sendHandle])</h2>
<div class="signature"><ul>
<li><code class="language-javascript">message</code> <span class="type">Object</span></li>
<li><code class="language-javascript">sendHandle</code> <span class="type">Handle object</span></li>
</div></ul>
<p>This function is equal to the send methods provided by
<code class="language-javascript">child_process.fork()</code>.  In the master you should use this function to
send a message to a specific worker.

</p>
<p>In a worker you can also use <code class="language-javascript">process.send(message)</code>, it is the same function.

</p>
<p>This example will echo back all messages from the master:

</p>
<pre><code class="language-javascript">if (cluster.isMaster) {
  var worker = cluster.fork();
  worker.send(&#39;hi there&#39;);

} else if (cluster.isWorker) {
  process.on(&#39;message&#39;, function(msg) {
    process.send(msg);
  });
}</code></pre>
<!--next-->
<h2>worker.kill([signal=&#39;SIGTERM&#39;])</h2>
<div class="signature"><ul>
<li><code class="language-javascript">signal</code> <span class="type">String</span> Name of the kill signal to send to the worker
process.</li>
</div></ul>
<p>This function will kill the worker. In the master, it does this by disconnecting
the <code class="language-javascript">worker.process</code>, and once disconnected, killing with <code class="language-javascript">signal</code>. In the
worker, it does it by disconnecting the channel, and then exiting with code <code class="language-javascript">0</code>.

</p>
<p>Causes <code class="language-javascript">.suicide</code> to be set.

</p>
<p>This method is aliased as <code class="language-javascript">worker.destroy()</code> for backwards compatibility.

</p>
<p>Note that in a worker, <code class="language-javascript">process.kill()</code> exists, but it is not this function,
it is <a>kill</a>.

</p>
<!--next-->
<h2>worker.disconnect()</h2>
<p>In a worker, this function will close all servers, wait for the &#39;close&#39; event on
those servers, and then disconnect the IPC channel.

</p>
<p>In the master, an internal message is sent to the worker causing it to call
<code class="language-javascript">.disconnect()</code> on itself.

</p>
<p>Causes <code class="language-javascript">.suicide</code> to be set.

</p>
<p>Note that after a server is closed, it will no longer accept new connections,
but connections may be accepted by any other listening worker. Existing
connections will be allowed to close as usual. When no more connections exist,
see <a>server.close()</a>, the IPC channel to the worker
will close allowing it to die gracefully.

</p>
<p>The above applies <em>only</em> to server connections, client connections are not
automatically closed by workers, and disconnect does not wait for them to close
before exiting.

</p>
<p>Note that in a worker, <code class="language-javascript">process.disconnect</code> exists, but it is not this function,
it is <a>disconnect</a>.

</p>
<p>Because long living server connections may block workers from disconnecting, it
may be useful to send a message, so application specific actions may be taken to
close them. It also may be useful to implement a timeout, killing a worker if
the <code class="language-javascript">disconnect</code> event has not been emitted after some time.

</p>
<pre><code class="language-javascript">if (cluster.isMaster) {
  var worker = cluster.fork();
  var timeout;

  worker.on(&#39;listening&#39;, function(address) {
    worker.send(&#39;shutdown&#39;);
    worker.disconnect();
    timeout = setTimeout(function() {
      worker.kill();
    }, 2000);
  });

  worker.on(&#39;disconnect&#39;, function() {
    clearTimeout(timeout);
  });

} else if (cluster.isWorker) {
  var net = require(&#39;net&#39;);
  var server = net.createServer(function(socket) {
    // connections never end
  });

  server.listen(8000);

  process.on(&#39;message&#39;, function(msg) {
    if(msg === &#39;shutdown&#39;) {
      // initiate graceful close of any connections to server
    }
  });
}</code></pre>
<!--next-->
<h2>worker.isDead()</h2>
<p>This function returns <code class="language-javascript">true</code> if the worker&#39;s process has terminated (either
because of exiting or being signaled). Otherwise, it returns <code class="language-javascript">false</code>.

</p>
<!--next-->
<h2>worker.isConnected()</h2>
<p>This function returns <code class="language-javascript">true</code> if the worker is connected to its master via its IPC
channel, <code class="language-javascript">false</code> otherwise. A worker is connected to its master after it&#39;s been
created. It is disconnected after the <code class="language-javascript">disconnect</code> event is emitted.

</p>
<!--next-->
<h2>Event: &#39;message&#39;</h2>
<div class="signature"><ul>
<li><code class="language-javascript">message</code> <span class="type">Object</span></li>
</div></ul>
<p>This event is the same as the one provided by <code class="language-javascript">child_process.fork()</code>.

</p>
<p>In a worker you can also use <code class="language-javascript">process.on(&#39;message&#39;)</code>.

</p>
<p>As an example, here is a cluster that keeps count of the number of requests
in the master process using the message system:

</p>
<pre><code class="language-javascript">var cluster = require(&#39;cluster&#39;);
var http = require(&#39;http&#39;);

if (cluster.isMaster) {

  // Keep track of http requests
  var numReqs = 0;
  setInterval(function() {
    console.log(&quot;numReqs =&quot;, numReqs);
  }, 1000);

  // Count requestes
  function messageHandler(msg) {
    if (msg.cmd &amp;&amp; msg.cmd == &#39;notifyRequest&#39;) {
      numReqs += 1;
    }
  }

  // Start workers and listen for messages containing notifyRequest
  var numCPUs = require(&#39;os&#39;).cpus().length;
  for (var i = 0; i &lt; numCPUs; i++) {
    cluster.fork();
  }

  Object.keys(cluster.workers).forEach(function(id) {
    cluster.workers[id].on(&#39;message&#39;, messageHandler);
  });

} else {

  // Worker processes have a http server.
  http.Server(function(req, res) {
    res.writeHead(200);
    res.end(&quot;hello world\n&quot;);

    // notify master about the request
    process.send({ cmd: &#39;notifyRequest&#39; });
  }).listen(8000);
}</code></pre>
<!--next-->
<h2>Event: &#39;online&#39;</h2>
<p>Similar to the <code class="language-javascript">cluster.on(&#39;online&#39;)</code> event, but specific to this worker.

</p>
<pre><code class="language-javascript">cluster.fork().on(&#39;online&#39;, function() {
  // Worker is online
});</code></pre>
<p>It is not emitted in the worker.

</p>
<!--next-->
<h2>Event: &#39;listening&#39;</h2>
<div class="signature"><ul>
<li><code class="language-javascript">address</code> <span class="type">Object</span></li>
</div></ul>
<p>Similar to the <code class="language-javascript">cluster.on(&#39;listening&#39;)</code> event, but specific to this worker.

</p>
<pre><code class="language-javascript">cluster.fork().on(&#39;listening&#39;, function(address) {
  // Worker is listening
});</code></pre>
<p>It is not emitted in the worker.

</p>
<!--next-->
<h2>Event: &#39;disconnect&#39;</h2>
<p>Similar to the <code class="language-javascript">cluster.on(&#39;disconnect&#39;)</code> event, but specfic to this worker.

</p>
<pre><code class="language-javascript">cluster.fork().on(&#39;disconnect&#39;, function() {
  // Worker has disconnected
});</code></pre>
<!--next-->
<h2>Event: &#39;exit&#39;</h2>
<div class="signature"><ul>
<li><code class="language-javascript">code</code> <span class="type">Number</span> the exit code, if it exited normally.</li>
<li><code class="language-javascript">signal</code> <span class="type">String</span> the name of the signal (eg. <code class="language-javascript">&#39;SIGHUP&#39;</code>) that caused
the process to be killed.</li>
</div></ul>
<p>Similar to the <code class="language-javascript">cluster.on(&#39;exit&#39;)</code> event, but specific to this worker.

</p>
<pre><code class="language-javascript">var worker = cluster.fork();
worker.on(&#39;exit&#39;, function(code, signal) {
  if( signal ) {
    console.log(&quot;worker was killed by signal: &quot;+signal);
  } else if( code !== 0 ) {
    console.log(&quot;worker exited with error code: &quot;+code);
  } else {
    console.log(&quot;worker success!&quot;);
  }
});</code></pre>
<!--next-->
<h2>Event: &#39;error&#39;</h2>
<p>This event is the same as the one provided by <code class="language-javascript">child_process.fork()</code>.

</p>
<p>In a worker you can also use <code class="language-javascript">process.on(&#39;error&#39;)</code>.

</p>
<!--next-->
<h2>Smalloc</h2>
<pre class="stability">Stability: 1 - Experimental</pre>
<p>Buffers are backed by a simple allocator that only handles the assignation of
external raw memory. Smalloc exposes that functionality.

</p>
<!--next-->
<h2>smalloc.alloc(length[, receiver][, type])</h2>
<div class="signature"><ul>
<li><code class="language-javascript">length</code> <span class="type">Number</span> <code class="language-javascript">&lt;= smalloc.kMaxLength</code></li>
<li><code class="language-javascript">receiver</code> <span class="type">Object</span> Default: <code class="language-javascript">new Object</code></li>
<li><code class="language-javascript">type</code> <span class="type">Enum</span> Default: <code class="language-javascript">Uint8</code></li>
</div></ul>
<p>Returns <code class="language-javascript">receiver</code> with allocated external array data. If no <code class="language-javascript">receiver</code> is
passed then a new Object will be created and returned.

</p>
<p>This can be used to create your own Buffer-like classes. No other properties are
set, so the user will need to keep track of other necessary information (e.g.
<code class="language-javascript">length</code> of the allocation).

</p>
<pre><code class="language-javascript">function SimpleData(n) {
  this.length = n;
  smalloc.alloc(this.length, this);
}

SimpleData.prototype = { /* ... */ };</code></pre>
<p>It only checks if the <code class="language-javascript">receiver</code> is an Object, and also not an Array. Because of
this it is possible to allocate external array data to more than a plain Object.

</p>
<pre><code class="language-javascript">function allocMe() { }
smalloc.alloc(3, allocMe);

// { [Function allocMe] &#39;0&#39;: 0, &#39;1&#39;: 0, &#39;2&#39;: 0 }</code></pre>
<p>v8 does not support allocating external array data to an Array, and if passed
will throw.

</p>
<p>It&#39;s possible is to specify the type of external array data you would like. All
possible options are listed in <code class="language-javascript">smalloc.Types</code>. Example usage:

</p>
<pre><code class="language-javascript">var doubleArr = smalloc.alloc(3, smalloc.Types.Double);

for (var i = 0; i &lt; 3; i++)
  doubleArr = i / 10;

// { &#39;0&#39;: 0, &#39;1&#39;: 0.1, &#39;2&#39;: 0.2 }</code></pre>
<p>It is not possible to freeze, seal and prevent extensions of objects with
external data using <code class="language-javascript">Object.freeze</code>, <code class="language-javascript">Object.seal</code> and
<code class="language-javascript">Object.preventExtensions</code> respectively.

</p>
<!--next-->
<h2>smalloc.copyOnto(source, sourceStart, dest, destStart, copyLength);</h2>
<div class="signature"><ul>
<li><code class="language-javascript">source</code> <span class="type">Object</span> with external array allocation</li>
<li><code class="language-javascript">sourceStart</code> <span class="type">Number</span> Position to begin copying from</li>
<li><code class="language-javascript">dest</code> <span class="type">Object</span> with external array allocation</li>
<li><code class="language-javascript">destStart</code> <span class="type">Number</span> Position to begin copying onto</li>
<li><code class="language-javascript">copyLength</code> <span class="type">Number</span> Length of copy</li>
</div></ul>
<p>Copy memory from one external array allocation to another. No arguments are
optional, and any violation will throw.

</p>
<pre><code class="language-javascript">var a = smalloc.alloc(4);
var b = smalloc.alloc(4);

for (var i = 0; i &lt; 4; i++) {
  a[i] = i;
  b[i] = i * 2;
}

// { &#39;0&#39;: 0, &#39;1&#39;: 1, &#39;2&#39;: 2, &#39;3&#39;: 3 }
// { &#39;0&#39;: 0, &#39;1&#39;: 2, &#39;2&#39;: 4, &#39;3&#39;: 6 }

smalloc.copyOnto(b, 2, a, 0, 2);

// { &#39;0&#39;: 4, &#39;1&#39;: 6, &#39;2&#39;: 2, &#39;3&#39;: 3 }</code></pre>
<p><code class="language-javascript">copyOnto</code> automatically detects the length of the allocation internally, so no
need to set any additional properties for this to work.

</p>
<!--next-->
<h2>smalloc.dispose(obj)</h2>
<div class="signature"><ul>
<li><code class="language-javascript">obj</code> Object</li>
</div></ul>
<p>Free memory that has been allocated to an object via <code class="language-javascript">smalloc.alloc</code>.

</p>
<pre><code class="language-javascript">var a = {};
smalloc.alloc(3, a);

// { &#39;0&#39;: 0, &#39;1&#39;: 0, &#39;2&#39;: 0 }

smalloc.dispose(a);

// {}</code></pre>
<p>This is useful to reduce strain on the garbage collector, but developers must be
careful. Cryptic errors may arise in applications that are difficult to trace.

</p>
<pre><code class="language-javascript">var a = smalloc.alloc(4);
var b = smalloc.alloc(4);

// perform this somewhere along the line
smalloc.dispose(b);

// now trying to copy some data out
smalloc.copyOnto(b, 2, a, 0, 2);

// now results in:
// RangeError: copy_length &gt; source_length</code></pre>
<p>After <code class="language-javascript">dispose()</code> is called object still behaves as one with external data, for
example <code class="language-javascript">smalloc.hasExternalData()</code> returns <code class="language-javascript">true</code>.
<code class="language-javascript">dispose()</code> does not support Buffers, and will throw if passed.

</p>
<!--next-->
<h2>smalloc.hasExternalData(obj)</h2>
<div class="signature"><ul>
<li><code class="language-javascript">obj</code> <span class="type">Object</span></li>
</div></ul>
<p>Returns <code class="language-javascript">true</code> if the <code class="language-javascript">obj</code> has externally allocated memory.

</p>
<!--next-->
<h2>smalloc.kMaxLength</h2>
<p>Size of maximum allocation. This is also applicable to Buffer creation.

</p>
<!--next-->
<h2>smalloc.Types</h2>
<p>Enum of possible external array types. Contains:

</p>
<ul>
<li><code class="language-javascript">Int8</code></li>
<li><code class="language-javascript">Uint8</code></li>
<li><code class="language-javascript">Int16</code></li>
<li><code class="language-javascript">Uint16</code></li>
<li><code class="language-javascript">Int32</code></li>
<li><code class="language-javascript">Uint32</code></li>
<li><code class="language-javascript">Float</code></li>
<li><code class="language-javascript">Double</code></li>
<li><code class="language-javascript">Uint8Clamped</code></li>
</ul>
