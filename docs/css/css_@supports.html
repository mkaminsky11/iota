<h2>@supports</h2>

                                                      <p></p><section  ><!-- --></section><p></p>
<h3>Summary</h3>
<p>The <code class="language-markup">@supports</code> <a  title="CSS">CSS</a> <a  title="en/CSS/At-rule">at-rule</a> associates a set of nested statements, in a CSS block, that is delimited by curly braces, with a condition consisting of testing of CSS declarations, that is property-value pairs, combined with arbitrary conjunctions, disjunctions, and negations of them. Such a condition is called a <em>supports condition</em>.</p>
<p><code class="language-markup">@supports</code> gives CSS the ability to perform a <em>feature query</em>.</p>
<p>The <code class="language-markup">@supports</code> at-rule may be used not only at the top level of a CSS, but also inside any <a  title="en/CSS/At-rule#Conditional_Group_Rules">CSS conditional-group at-rule</a> and can be accessed via the CSS object model interface <a  title="The CSSSupportsRule interface describes an object representing a single CSS @supports at-rule. It implements the CSSConditionRule interface, and therefore the CSSRule and CSSGroupingRule interfaces with a type value of 12 (CSSRule.SUPPORTS_RULE)."><code class="language-markup">CSSSupportsRule</code></a>.</p>
<h3>Syntax</h3>
<pre >@supports <em>&lt;supports_condition&gt;</em> {
  /* specific rules */
}
</code></pre>
<p>A supports condition consists of one or several declarations combined by different logical operators. Precedence of operators can be overruled by using parenthesis.</p>
<h3 >Declaration syntax</h3>
<p>The simplest expression is a CSS declaration, that is a CSS property name followed by a value, separated by a colon. The following expression</p>
<pre >( transform-origin: 5% 5% )</code></pre>
<p>returns true if the <a  title="The transform-origin CSS property lets you modify the origin for transformations of an element. For example, the transform-origin of the rotate() function is the centre of rotation. (This property is applied by first translating the element by the negated value of the property, then applying the element's transform, then translating by the property value.)"><code class="language-markup">transform-origin</code></a> implements a syntax considering <code class="language-markup">5% 5%</code> as valid.</p>
<p>A CSS declaration is always surrounded by parentheses.</p>
<h3 >The <code class="language-markup">not</code> operator</h3>
<p>The <code class="language-markup">not</code> operator can precede any expression to create a new expression, resulting in the negation of the original expression. The following expression</p>
<pre >not ( transform-origin: 10em 10em 10em )</code></pre>
<p>returns true if <a  title="The transform-origin CSS property lets you modify the origin for transformations of an element. For example, the transform-origin of the rotate() function is the centre of rotation. (This property is applied by first translating the element by the negated value of the property, then applying the element's transform, then translating by the property value.)"><code class="language-markup">transform-origin</code></a> doesn't implement a syntax considering <code class="language-markup">10em 10em 10em</code> as valid.</p>
<p>Like any operator, the <code class="language-markup">not</code> operator can be applied to a declaration of any complexity. The following examples are all valid expressions:</p>
<pre >not ( not ( transform-origin: 2px ) )
(display: flexbox) and ( not (display: inline-grid) )</code></pre>
<div >
 <p><strong>Note:</strong> there is no need to enclose the <code class="language-markup">not</code> operator between two parenthesis when at the top level. But to combine it with other operators, like <code class="language-markup">and</code> and <code class="language-markup">or</code>, the parenthesis are required.</p>
</div>
<h3 >The <code class="language-markup">and</code> operator</h3>
<p>From two expressions, the <code class="language-markup">and</code> operator creates a new expression consisting in the conjunction of the two original ones, that is the resulting expression is true only if both of the original expressions also resolve to true. In this example, the complete expression resolves to true if and only if the two expressions are simultaneously true:</p>
<pre >(display: table-cell) and (display: list-item)</code></pre>
<p>Several conjunctions can be juxtaposed without the need of more parenthesis:</p>
<pre >(display: table-cell) and (display: list-item) and (display:run-in)</code></pre>
<p>is equivalent to:</p>
<pre >(display: table-cell) and ((display: list-item) and (display:run-in))</code></pre>
<h3 >The <code class="language-markup">or</code> operator</h3>
<p>From two expressions, the <code class="language-markup">or</code> operator creates a new expression consisting in the disjunction of the two original ones, that is the resulting expression is true if one, or both, of the original expressions also resolves to true. In this example, the complete expression resolves to true if at least one of the two expressions is true:</p>
<pre >( transform-style: preserve ) or ( -moz-transform-style: preserve )</code></pre>
<p>Several disjunctions can be juxtaposed without the need of more parenthesis:</p>
<pre >( transform-style: preserve ) or ( -moz-transform-style: preserve ) or 
( -o-transform-style: preserve ) or ( -webkit-transform-style: preserve  )</code></pre>
<p>is equivalent to:</p>
<pre >( transform-style: preserve-3d ) or (( -moz-transform-style: preserve-3d ) or 
(( -o-transform-style: preserve-3d ) or ( -webkit-transform-style: preserve-3d  )))</code></pre>
<div >
 <p><strong>Note</strong>: when using both <code class="language-markup">and</code> and <code class="language-markup">or</code> operators, the parenthesis must be used in order to define the order in which they apply. If not, the condition is invalid leading to the whole at-rule to be ignored.</p>
</div>
